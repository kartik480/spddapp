import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'dart:async';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb, ValueNotifier;
import 'package:cached_network_image/cached_network_image.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:image_picker/image_picker.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';
import 'package:razorpay_flutter/razorpay_flutter.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:onesignal_flutter/onesignal_flutter.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'firebase_options.dart';
import 'package:firebase_auth_web/firebase_auth_web.dart' if (dart.library.io) 'package:firebase_auth/firebase_auth.dart' as auth_web;

// Global backend base URL and image resolver for use across screens
const String kBackendBaseUrl = 'https://superdailys.com/superdailyapp/';
const String kStorageProductsBase = 'https://superdailys.com/storage/products/';
const String kProfileImageBaseUrl = 'https://superdailys.com/public/storage/profiles/';
const String kProfileImageFallbackBaseUrl = 'https://srv1881-files.hstgr.io/4663f5e73332121d/files/public_html/public/storage/profiles/';
const String kLegacyProfileImageBaseUrl = 'https://superdailys.com/storage/profiles/';
const String kLegacyProfileImageFallbackBaseUrl = 'https://srv1881-files.hstgr.io/4663f5e73332121d/files/public_html/storage/profiles/';
const String kGoogleMapsApiKey = 'AIzaSyDx_sQ51Uv1zBO2CfQSaM5tWMmnUFMIJaA';

// Razorpay Configuration
const String kRazorpayKeyId = 'rzp_test_R8Ilarj7qdqAOS';
const String kRazorpayKeySecret = 'PDiOJq6d7MTHgFCRfFzzVAxs';
const String kRazorpayWebhookSecret = 'whsec_test.';

// Feature switches
const bool kEnableOtpVerification = false; // Temporarily disable OTP until reCAPTCHA is configured

class _StatusMeta {
  final String label;
  final Color color;
  const _StatusMeta(this.label, this.color);
}

String _resolveImageUrl(String raw) {
  if (raw.isEmpty) return raw;
  String p = raw.trim();
  p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
  
  // Already absolute URL starting with https://superdailys.com/storage/products/
  if (p.startsWith('https://superdailys.com/storage/products/')) {
    return p;
  }
  
  // Already absolute URL (any other URL)
  if (p.startsWith('http://') || p.startsWith('https://')) {
    // If it's a full URL but not from the storage/products path, try to extract filename
    if (!p.contains('/storage/products/')) {
      final filename = p.split('/').last.split('?').first.split('#').first;
      if (filename.isNotEmpty && filename.contains('.')) {
        return kStorageProductsBase + filename;
      }
    }
    return p;
  }
  
  // Extract just the filename from the path
  String filename = p.split('/').last.split('\\').last;
  // Remove query parameters and hash
  filename = filename.split('?').first.split('#').first;
  
  // If filename is empty or doesn't have extension, try to find it
  if (filename.isEmpty || !filename.contains('.')) {
    // Try to find filename in the path
    final parts = p.split('/');
    for (var part in parts.reversed) {
      if (part.contains('.') && part.length > 3) {
        filename = part.split('?').first.split('#').first;
        break;
      }
    }
  }
  
  // Build full URL with storage/products base
  if (filename.isNotEmpty && filename.contains('.')) {
    final url = kStorageProductsBase + filename;
    debugPrint('Resolved image URL (storage): ' + url);
    return url;
  }
  
  // Fallback to old method
  while (p.startsWith('./') || p.startsWith('../')) {
    p = p.startsWith('./') ? p.substring(2) : p.substring(3);
  }
  final spdIdx = p.indexOf('/spdbackend/');
  if (spdIdx != -1) {
    p = p.substring(spdIdx + '/spdbackend/'.length);
  }
  for (final marker in ['/htdocs/', '/www/']) {
    final idx = p.indexOf(marker);
    if (idx != -1) {
      p = p.substring(idx + marker.length);
    }
  }
  if (p.startsWith('/')) p = p.substring(1);
  final fileName = _basename(p);
  if (fileName.isNotEmpty) {
    final url = kStorageProductsBase + fileName;
    debugPrint('Resolved image URL (storage fallback): ' + url);
    return url;
  }
  final url = kBackendBaseUrl + p;
  debugPrint('Resolved image URL (fallback backend): ' + url);
  return url;
}

String? _extractProfileImageFileName(String rawPath) {
  if (rawPath.isEmpty) return null;
  final normalized = rawPath.replaceAll('\\', '/');
  for (final segment in normalized.split('/').reversed) {
    final cleanSegment = segment.split('?').first.split('#').first;
    if (cleanSegment.isNotEmpty) {
      return cleanSegment;
    }
  }
  return null;
}

String _normalizeProfileImageUrl(String url) {
  var normalized = url.replaceAll('\\', '/').trim();
  if (normalized.isEmpty) return normalized;
  
  // Convert legacy URLs (without /public/) to new format (with /public/)
  normalized = normalized.replaceAll(kLegacyProfileImageBaseUrl, kProfileImageBaseUrl);
  normalized = normalized.replaceAll(kLegacyProfileImageFallbackBaseUrl, kProfileImageFallbackBaseUrl);
  
  // Ensure consistent format - use the standard base URL
  if (normalized.contains('/storage/profiles/') && !normalized.contains('/public/storage/profiles/')) {
    final filename = normalized.split('/storage/profiles/').last.split('?').first.split('#').first;
    normalized = kProfileImageBaseUrl + filename;
    // Preserve query params and hash if they exist
    final originalUrl = url;
    if (originalUrl.contains('?')) {
      normalized += '?' + originalUrl.split('?').last;
    } else if (originalUrl.contains('#')) {
      normalized += '#' + originalUrl.split('#').last;
    }
  }
  
  // Guard against accidental double "public" segments
  normalized = normalized.replaceAll('/public/public/', '/public/');
  return normalized;
}

String? _resolveProfileImageValue(dynamic profileImage) {
  if (profileImage == null) return null;

  final raw = profileImage.toString().trim();
  if (raw.isEmpty || raw.toLowerCase() == 'null') {
    return null;
  }

  if (raw.startsWith('http://') || raw.startsWith('https://')) {
    return _normalizeProfileImageUrl(raw);
  }

  var normalizedPath = raw.replaceAll('\\', '/');
  while (normalizedPath.startsWith('/')) {
    normalizedPath = normalizedPath.substring(1);
  }
  
  // Extract filename directly - faster path
  final fileName = _extractProfileImageFileName(normalizedPath);
  if (fileName == null || fileName.isEmpty) {
    return null;
  }
  return '$kProfileImageBaseUrl$fileName';
}

String _getBackendBaseUrl() {
  // Always use production URL for hosted backend
    return kBackendBaseUrl;
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const MyApp());
}

// Global ValueNotifier for theme changes
final ValueNotifier<ThemeMode> themeNotifier = ValueNotifier<ThemeMode>(ThemeMode.light);

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  ThemeMode _themeMode = ThemeMode.light;

  @override
  void initState() {
    super.initState();
    _loadThemePreference();
    // Listen to theme changes
    themeNotifier.addListener(_onThemeChanged);
  }

  @override
  void dispose() {
    themeNotifier.removeListener(_onThemeChanged);
    super.dispose();
  }

  void _onThemeChanged() {
    setState(() {
      _themeMode = themeNotifier.value;
    });
  }

  Future<void> _loadThemePreference() async {
    final prefs = await SharedPreferences.getInstance();
    final themeMode = prefs.getString('theme_mode') ?? 'Light';
    setState(() {
      _themeMode = themeMode == 'Dark' ? ThemeMode.dark : ThemeMode.light;
      themeNotifier.value = _themeMode;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'SPD App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.green,
          primary: Colors.green.shade700,
          secondary: Colors.green.shade600,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
        textTheme: GoogleFonts.poppinsTextTheme(),
        scaffoldBackgroundColor: const Color(0xFFE0F2F1),
      ),
      darkTheme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.green,
          primary: const Color(0xFF00BFA5),
          secondary: Colors.green.shade600,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
        textTheme: GoogleFonts.poppinsTextTheme(ThemeData.dark().textTheme),
        scaffoldBackgroundColor: const Color(0xFF121212),
        appBarTheme: const AppBarTheme(
          backgroundColor: Color(0xFF1E1E1E),
          foregroundColor: Colors.white,
        ),
        cardColor: const Color(0xFF1E1E1E),
        dialogBackgroundColor: const Color(0xFF1E1E1E),
      ),
      themeMode: _themeMode,
      home: const AuthWrapper(),
    );
  }
}

// A widget that tries multiple URLs in order until one loads successfully
class FallbackImage extends StatefulWidget {
  final List<String> urls;
  final BoxFit fit;
  final Widget? placeholder;
  final Widget? error;

  const FallbackImage({
    super.key,
    required this.urls,
    this.fit = BoxFit.cover,
    this.placeholder,
    this.error,
  });

  @override
  State<FallbackImage> createState() => _FallbackImageState();
}

class _FallbackImageState extends State<FallbackImage> {
  int _index = 0;

  @override
  Widget build(BuildContext context) {
    if (_index >= widget.urls.length) {
      return widget.error ?? const SizedBox.shrink();
    }
    final resolved = _resolveImageUrl(widget.urls[_index]);
    final url = Uri.encodeFull(resolved + (resolved.contains('?') ? '&' : '?') + 'v=' + DateTime.now().millisecondsSinceEpoch.toString());
    debugPrint('Image try [' + _index.toString() + "/" + widget.urls.length.toString() + ']: ' + resolved);
    return CachedNetworkImage(
      imageUrl: url,
      fit: widget.fit,
      placeholder: (context, _) => widget.placeholder ?? const Center(child: CircularProgressIndicator(strokeWidth: 2)),
      errorWidget: (context, _, __) {
        debugPrint('Image failed: ' + resolved);
        if (_index < widget.urls.length - 1) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) {
              setState(() { _index += 1; });
            }
          });
          return widget.placeholder ?? const SizedBox.shrink();
        }
        return widget.error ?? const SizedBox.shrink();
      },
    );
  }
}

String _basename(String p) {
  if (p.isEmpty) return p;
  p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
  final i = p.lastIndexOf('/');
  return i == -1 ? p : p.substring(i + 1);
}

// Auth Wrapper to check login status on app start
class AuthWrapper extends StatefulWidget {
  const AuthWrapper({super.key});

  @override
  State<AuthWrapper> createState() => _AuthWrapperState();
}

class _AuthWrapperState extends State<AuthWrapper> {
  bool _isLoading = true;
  bool _isLoggedIn = false;
  bool _hasSeenOnboarding = false;
  bool _showSplash = true;
  bool _showLoadingScreen = false;
  Map<String, dynamic>? _userData;

  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  Future<void> _initializeApp() async {
    // Initialize OneSignal
    await _initializeOneSignal();
    
    // Show splash screen for minimum 2 seconds
    await Future.delayed(const Duration(seconds: 2));
    
    if (!mounted) return;
    
    // Now check login status
    await _checkLoginStatus();
  }

  Future<void> _initializeOneSignal() async {
    if (kIsWeb) return; // OneSignal not supported on web
    
    try {
      // OneSignal App ID
      const String onesignalAppId = '63b3f137-b249-4425-8479-5419cd54b076';
      
      // Initialize OneSignal
      OneSignal.initialize(onesignalAppId);
      
      // Request permission for notifications
      OneSignal.Notifications.requestPermission(true);
      
      // Handle notification received
      OneSignal.Notifications.addClickListener((event) {
        debugPrint('OneSignal notification clicked: ${event.notification}');
        // Handle navigation based on notification data
        if (event.notification.additionalData != null) {
          final data = event.notification.additionalData!;
          final url = data['url'];
          if (url != null && url.toString().isNotEmpty) {
            // Navigate to URL if provided
            debugPrint('Navigate to: $url');
          }
        }
      });
      
      // Get player ID and save to backend
      final playerId = await OneSignal.User.pushSubscription.id;
      if (playerId != null && playerId.isNotEmpty) {
        await _saveOneSignalPlayerId(playerId);
      }
      
      // Listen for player ID changes
      OneSignal.User.pushSubscription.addObserver((state) {
        if (state.current.id != null && state.current.id!.isNotEmpty) {
          _saveOneSignalPlayerId(state.current.id!);
        }
      });
      
    } catch (e) {
      debugPrint('Error initializing OneSignal: $e');
    }
  }

  Future<void> _saveOneSignalPlayerId(String playerId) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
      
      if (!isLoggedIn) {
        // Save player ID temporarily, will save with user_id after login
        await prefs.setString('onesignal_player_id', playerId);
        return;
      }
      
      final userDataJson = prefs.getString('userData');
      if (userDataJson == null) return;
      
      final userData = jsonDecode(userDataJson);
      final userId = userData['id']?.toString();
      
      if (userId == null || userId.isEmpty) return;
      
      // Save to backend
      final response = await http.post(
        Uri.parse('${kBackendBaseUrl}save_push_subscription.php'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'user_id': int.parse(userId),
          'player_id': playerId,
          'endpoint': '', // Not needed for OneSignal
          'keys': {}, // Not needed for OneSignal
        }),
      );
      
      if (response.statusCode == 200) {
        debugPrint('OneSignal player ID saved successfully');
      } else {
        debugPrint('Failed to save OneSignal player ID: ${response.body}');
      }
    } catch (e) {
      debugPrint('Error saving OneSignal player ID: $e');
    }
  }

  Future<void> _checkLoginStatus() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // Check if this is a fresh install by checking for install ID
      String? installId = prefs.getString('appInstallId');
      if (installId == null || installId.isEmpty) {
        // Fresh install - generate new install ID and clear login state
        installId = DateTime.now().millisecondsSinceEpoch.toString() + '_' + 
                   (1000 + (9999 * (DateTime.now().millisecond / 1000)).round()).toString();
        await prefs.setString('appInstallId', installId);
        // Clear login state on fresh install
        await prefs.setBool('isLoggedIn', false);
        await prefs.remove('userData');
        // Reset onboarding for fresh install
        await prefs.setBool('hasSeenOnboarding', false);
        debugPrint('ðŸ†• Fresh install detected - login state and onboarding cleared');
      }
      
      // Check app version - if version changed, reset onboarding
      const String currentAppVersion = '1.0.1'; // Update this when you want to show onboarding again
      final String? storedVersion = prefs.getString('appVersion');
      
      // If version changed or not set, reset onboarding
      if (storedVersion != currentAppVersion) {
        await prefs.setString('appVersion', currentAppVersion);
        await prefs.setBool('hasSeenOnboarding', false);
      }
      
      final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
      final userDataJson = prefs.getString('userData');

      if (isLoggedIn && userDataJson != null) {
        if (mounted) {
    setState(() {
          _isLoggedIn = true;
          _userData = jsonDecode(userDataJson);
          _hasSeenOnboarding = true;
          _isLoading = false;
          _showSplash = false;
            _showLoadingScreen = false;
        });
        }
      } else {
        final hasSeenOnboarding = prefs.getBool('hasSeenOnboarding') ?? false;
        if (mounted) {
        setState(() {
          _isLoggedIn = false;
          _hasSeenOnboarding = hasSeenOnboarding;
          _isLoading = false;
            _showSplash = false;
            // Show loading screen before onboarding if user hasn't seen it
            _showLoadingScreen = !hasSeenOnboarding;
        });
        }
        
        // If showing loading screen, transition to onboarding after delay
        if (_showLoadingScreen) {
          await Future.delayed(const Duration(seconds: 2));
          if (mounted) {
            setState(() {
              _showLoadingScreen = false;
            });
          }
        }
      }
    } catch (e) {
      final prefs = await SharedPreferences.getInstance();
      
      // Check if this is a fresh install by checking for install ID
      String? installId = prefs.getString('appInstallId');
      if (installId == null || installId.isEmpty) {
        // Fresh install - generate new install ID and clear login state
        installId = DateTime.now().millisecondsSinceEpoch.toString() + '_' + 
                   (1000 + (9999 * (DateTime.now().millisecond / 1000)).round()).toString();
        await prefs.setString('appInstallId', installId);
        // Clear login state on fresh install
        await prefs.setBool('isLoggedIn', false);
        await prefs.remove('userData');
        // Reset onboarding for fresh install
        await prefs.setBool('hasSeenOnboarding', false);
        debugPrint('ðŸ†• Fresh install detected (error handler) - login state and onboarding cleared');
      }
      
      // Check app version - if version changed, reset onboarding
      const String currentAppVersion = '1.0.1'; // Update this when you want to show onboarding again
      final String? storedVersion = prefs.getString('appVersion');
      
      // If version changed or not set, reset onboarding
      if (storedVersion != currentAppVersion) {
        await prefs.setString('appVersion', currentAppVersion);
        await prefs.setBool('hasSeenOnboarding', false);
      }
      
      final hasSeenOnboarding = prefs.getBool('hasSeenOnboarding') ?? false;
      if (mounted) {
      setState(() {
        _isLoggedIn = false;
          _hasSeenOnboarding = hasSeenOnboarding;
        _isLoading = false;
        _showSplash = false;
          _showLoadingScreen = !hasSeenOnboarding;
        });
      }
      
      // If showing loading screen, transition to onboarding after delay
      if (_showLoadingScreen) {
        await Future.delayed(const Duration(seconds: 2));
        if (mounted) {
          setState(() {
            _showLoadingScreen = false;
          });
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading || _showSplash) {
      return const SplashScreen();
    }

    if (_isLoggedIn && _userData != null) {
      return HomeScreen(userData: _userData!);
    }

    if (_showLoadingScreen) {
      return const LoadingScreen();
    }

    if (!_hasSeenOnboarding) {
      return const GetStartedPage();
    }

    return const HomeScreen();
  }
}

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    
    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeIn,
    ));
    
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF00BFA5),
        body: Center(
        child: FadeTransition(
          opacity: _fadeAnimation,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Logo
              ColorFiltered(
                colorFilter: const ColorFilter.mode(
                  Colors.white,
                  BlendMode.srcIn,
                ),
                child: Image.asset(
                  'images/logo.png',
                  height: 180,
                  width: 180,
                  fit: BoxFit.contain,
                  errorBuilder: (context, error, stackTrace) {
                    return Container(
                      height: 180,
                      width: 180,
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: const Icon(
                        Icons.image,
                        color: Colors.white,
                        size: 90,
                      ),
                    );
                  },
                ),
              ),
              const SizedBox(height: 24),
              // Super Daily Text
              Text(
                'Super Daily',
                style: GoogleFonts.poppins(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                  letterSpacing: 1.2,
                ),
              ),
            ],
          ),
          ),
        ),
      );
  }
}

class LoadingScreen extends StatefulWidget {
  const LoadingScreen({super.key});

  @override
  State<LoadingScreen> createState() => _LoadingScreenState();
}

class _LoadingScreenState extends State<LoadingScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF06E6C8),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Super Daily...',
              style: GoogleFonts.poppins(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Colors.white,
                letterSpacing: 1.0,
              ),
            ),
            const SizedBox(height: 24),
            SizedBox(
              width: 40,
              height: 40,
              child: CircularProgressIndicator(
                strokeWidth: 3,
                valueColor: const AlwaysStoppedAnimation<Color>(Colors.white),
              ),
            ),
          ],
          ),
        ),
      );
  }
}

class GetStartedPage extends StatefulWidget {
  const GetStartedPage({super.key});

  @override
  State<GetStartedPage> createState() => _GetStartedPageState();
}

class _GetStartedPageState extends State<GetStartedPage> {
  final PageController _pageController = PageController();
  int _currentPage = 0;
  double _pageOffset = 0.0;

  // Parallax data for each screen
  final List<Map<String, dynamic>> _screens = [
    {
      'folder': 'paralax1',
      'leftImage': 'st1.png',
      'rightImage': 'st11.png',
      'centerImage': 'maid.png',
      'title': 'All Professional Maids',
      'description': 'Experience premium cleaning services with our certified and professional maids. Quality guaranteed for your home and office.',
    },
    {
      'folder': 'paralax2',
      'leftImage': 'st2.png',
      'rightImage': 'st22.png',
      'centerImage': 'grocery.png',
      'title': 'Fresh Grocery Delivery',
      'description': 'Get fresh groceries delivered right to your doorstep. Wide selection of quality products at your convenience.',
    },
    {
      'folder': 'paralax3',
      'leftImage': 'st2.png',
      'rightImage': 'st22.png',
      'centerImage': 'delivery.png',
      'title': 'Fast & Reliable Delivery',
      'description': 'Quick and secure delivery services. Your orders delivered on time, every time with our trusted network.',
    },
  ];

  @override
  void initState() {
    super.initState();
    _pageController.addListener(() {
      setState(() {
        if (_pageController.hasClients) {
          _pageOffset = _pageController.page ?? 0.0;
          _currentPage = _pageOffset.round();
        }
      });
    });
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  Future<void> _onGetStarted() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('hasSeenOnboarding', true);
    
    if (mounted) {
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (context) => const HomeScreen()),
      );
    }
  }

  Widget _buildParallaxScreen(int index) {
    final screen = _screens[index];
    final folder = screen['folder'] as String;
    final leftImg = screen['leftImage'] as String;
    final rightImg = screen['rightImage'] as String;
    final centerImg = screen['centerImage'] as String;
    final title = screen['title'] as String;
    final description = screen['description'] as String;

    // Calculate parallax offset based on scroll position
    // When scrolling right (pageOffset increases), elements move
    final pageDiff = _pageOffset - index;
    final screenWidth = MediaQuery.of(context).size.width;
    final screenHeight = MediaQuery.of(context).size.height;
    
    // Parallax multipliers for different elements
    // Positive pageDiff means scrolling forward (right), negative means backward (left)
    final leftImageOffset = -pageDiff * screenWidth * 0.4; // Moves left when scrolling right
    final rightImageOffset = pageDiff * screenWidth * 0.4; // Moves right when scrolling right
    final centerImageOffset = -pageDiff.abs() * screenHeight * 0.3; // Moves up when scrolling
    final textOffset = pageDiff.abs() * screenWidth * 0.6; // Moves right when scrolling

    return Container(
      color: Colors.white,
      child: Stack(
        children: [
          // Left image (st1.png) - moves left when scrolling right
          Positioned(
            left: 20 + leftImageOffset,
            top: screenHeight * 0.15,
            child: Image.asset(
              '$folder/$leftImg',
              width: screenWidth * 0.35,
              fit: BoxFit.contain,
              errorBuilder: (context, error, stackTrace) {
                return const SizedBox.shrink();
              },
            ),
          ),
          // Right image (st11.png) - moves right when scrolling right
          Positioned(
            right: 20 - rightImageOffset,
            top: screenHeight * 0.2,
            child: Image.asset(
              '$folder/$rightImg',
              width: screenWidth * 0.35,
              fit: BoxFit.contain,
              errorBuilder: (context, error, stackTrace) {
                return const SizedBox.shrink();
              },
            ),
          ),
          // Center image (maid.png) - moves up when scrolling right
          Positioned(
            left: screenWidth * 0.075,
            top: screenHeight * 0.08 + centerImageOffset,
            child: Image.asset(
              '$folder/$centerImg',
              width: screenWidth * 0.85,
              fit: BoxFit.contain,
              errorBuilder: (context, error, stackTrace) {
                return const SizedBox.shrink();
              },
            ),
          ),
          // Title and description - moves right when scrolling right
          Positioned(
            left: 30 + textOffset,
            bottom: screenHeight * 0.25,
            right: 30,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: GoogleFonts.poppins(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey.shade800,
                  ),
                ),
                const SizedBox(height: 16),
                Text(
                  description,
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    color: Colors.grey.shade600,
                    height: 1.5,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
          // Parallax screens
          PageView.builder(
            controller: _pageController,
            onPageChanged: (index) {
              setState(() {
                _currentPage = index;
              });
            },
            itemCount: _screens.length,
            itemBuilder: (context, index) {
              return _buildParallaxScreen(index);
            },
          ),
          // Overlay content at the bottom
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: SafeArea(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // Page indicators
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: List.generate(
                      _screens.length,
                      (index) => Container(
                        margin: const EdgeInsets.symmetric(horizontal: 4),
                        width: _currentPage == index ? 24 : 8,
                        height: 8,
                        decoration: BoxDecoration(
                          color: _currentPage == index
                              ? Colors.green.shade700
                              : Colors.grey.shade300,
                          borderRadius: BorderRadius.circular(4),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  // Get Started button (only on last page)
                  if (_currentPage == _screens.length - 1)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 20),
                      child: SizedBox(
                        width: double.infinity,
                        height: 56,
                        child: ElevatedButton(
                          onPressed: _onGetStarted,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.green.shade700,
                            foregroundColor: Colors.white,
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(12),
                            ),
                            elevation: 2,
                          ),
                          child: const Text(
                            'Get Started',
                            style: TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ),
                    )
                  else
                    const SizedBox(height: 20),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> with TickerProviderStateMixin {
  final _loginFormKey = GlobalKey<FormState>();
  final _signupFormKey = GlobalKey<FormState>();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();
  // Sign-up controllers
  final _fullNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _signupPhoneController = TextEditingController();
  final _signupPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _addressController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureSignupPassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;
  bool _isSignupLoading = false;
  late TabController _tabController;
  late AnimationController _animationController;
  late ScrollController _scrollController;
  // Initialize GoogleSignIn with clientId for web (optional - can also use meta tag in index.html)
  final GoogleSignIn _googleSignIn = GoogleSignIn(
    // For web, you can either:
    // 1. Set clientId here, OR
    // 2. Add <meta name="google-signin-client_id" content="YOUR_CLIENT_ID" /> in web/index.html
    // For mobile (Android/iOS), clientId is configured in platform-specific files
    // clientId: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com', // Uncomment and add your client ID
  );
  
  final List<String> _imagePaths = [
    'images/gs1.png',
    'images/gs2.png',
    'images/gs3.png',
  ];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 15), // Medium speed
    )..repeat();
    
    _scrollController = ScrollController();
    
    // Start auto-scrolling with seamless loop
    _animationController.addListener(_animateImages);
    
    // Initialize scroll position after first frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients && _animationController.isAnimating) {
        _animateImages();
      }
    });
  }
  
  void _animateImages() {
    if (!_scrollController.hasClients) return;
    
    final maxScroll = _scrollController.position.maxScrollExtent;
    if (maxScroll == 0) return;
    
    final oneSetWidth = maxScroll / 3; // Since we have 3 sets
    final scrollPosition = _animationController.value * oneSetWidth * 2;
    
    // Reset to beginning when reaching end for seamless loop
    if (scrollPosition >= oneSetWidth * 2) {
      _scrollController.jumpTo(scrollPosition - oneSetWidth * 2);
    } else {
      _scrollController.jumpTo(scrollPosition);
    }
  }

  @override
  void dispose() {
    _phoneController.dispose();
    _passwordController.dispose();
    _fullNameController.dispose();
    _emailController.dispose();
    _signupPhoneController.dispose();
    _signupPasswordController.dispose();
    _confirmPasswordController.dispose();
    _addressController.dispose();
    _tabController.dispose();
    _animationController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  String? _validatePhone(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your phone number';
    }
    // Remove spaces and special characters for validation
    final cleanPhone = value.replaceAll(RegExp(r'[\s\-\(\)]'), '');
    // Check if it contains only digits
    if (!RegExp(r'^\d+$').hasMatch(cleanPhone)) {
      return 'Phone number must contain only digits';
    }
    // Must be exactly 10 digits
    if (cleanPhone.length != 10) {
      return 'Phone number must be exactly 10 digits';
    }
    // Check if it doesn't start with 0
    if (cleanPhone.startsWith('0')) {
      return 'Phone number cannot start with 0';
    }
    return null;
  }

  String? _validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your password';
    }
    if (value.length < 6) {
      return 'Password must be at least 6 characters';
    }
    return null;
  }

  String? _validateFullName(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your full name';
    }
    if (value.trim().length < 2) {
      return 'Name must be at least 2 characters';
    }
    return null;
  }

  String? _validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your email address';
    }
    // Trim whitespace
    final email = value.trim().toLowerCase();
    
    // More comprehensive email regex
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
      caseSensitive: false,
    );
    
    if (!emailRegex.hasMatch(email)) {
      return 'Please enter a valid email address\n(Example: name@example.com)';
    }
    
    // Additional validations
    if (email.startsWith('.') || email.startsWith('@')) {
      return 'Email cannot start with . or @';
    }
    
    if (email.contains('..')) {
      return 'Email cannot contain consecutive dots';
    }
    
    if (email.length > 254) {
      return 'Email address is too long';
    }
    
    // Check for common TLD
    final parts = email.split('@');
    if (parts.length != 2) {
      return 'Invalid email format';
    }
    
    final domain = parts[1];
    if (domain.length < 4) {
      return 'Invalid email domain';
    }
    
    return null;
  }

  String? _validateConfirmPassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please confirm your password';
    }
    if (value != _signupPasswordController.text) {
      return 'Passwords do not match';
    }
    return null;
  }

  String? _validateAddress(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your address';
    }
    if (value.trim().length < 5) {
      return 'Address must be at least 5 characters';
    }
    return null;
  }

  Future<void> _handleSignup() async {
    if (_signupFormKey.currentState!.validate()) {
      setState(() {
        _isSignupLoading = true;
      });

      try {
        // API endpoint - Production
        const String apiUrl = 'https://superdailys.com/superdailyapp/register.php';
        
        // Prepare request body
        final response = await http.post(
          Uri.parse(apiUrl),
          headers: {
            'Content-Type': 'application/json',
          },
          body: jsonEncode({
            'name': _fullNameController.text.trim(),
            'email': _emailController.text.trim(),
            'phone': _signupPhoneController.text.trim(),
            'password': _signupPasswordController.text,
            'address': _addressController.text.trim(),
          }),
        );

        if (mounted) {
          setState(() {
            _isSignupLoading = false;
          });

          if (response.statusCode == 200) {
            final data = jsonDecode(response.body);
            if (data['success'] == true) {
              // Registration successful - Show success message and switch to login
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(data['message'] ?? 'Registration successful! Please login.'),
                  backgroundColor: Colors.green,
                ),
              );
              
              // Clear sign-up form
              _fullNameController.clear();
              _emailController.clear();
              _signupPhoneController.clear();
              _signupPasswordController.clear();
              _confirmPasswordController.clear();
              _addressController.clear();
              
              // Switch to login tab
              _tabController.animateTo(0);
            } else {
              // Registration failed
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(data['message'] ?? 'Registration failed'),
                  backgroundColor: Colors.red,
                ),
              );
            }
          } else {
            // HTTP error
            final data = jsonDecode(response.body);
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Server error occurred'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      } catch (e) {
        if (mounted) {
          setState(() {
            _isSignupLoading = false;
          });

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Connection error: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  Future<void> _handleLogin() async {
    if (_loginFormKey.currentState!.validate()) {
    setState(() {
        _isLoading = true;
      });

      try {
        // API endpoint - Production
        const String apiUrl = 'https://superdailys.com/superdailyapp/login.php';
        
        // Prepare request body
        final response = await http.post(
          Uri.parse(apiUrl),
          headers: {
            'Content-Type': 'application/json',
          },
          body: jsonEncode({
            'phone': _phoneController.text.trim(),
            'password': _passwordController.text,
          }),
        );

        if (mounted) {
          setState(() {
            _isLoading = false;
          });

          if (response.statusCode == 200) {
            final data = jsonDecode(response.body);
            if (data['success'] == true) {
              // Get SharedPreferences instance
              final prefs = await SharedPreferences.getInstance();
              
              // Check if there's a pending cart product, serviceId, productId, or cart checkout BEFORE saving login state
              // This ensures we read the value before any potential state changes
              final pendingCartProductJson = prefs.getString('pendingCartProduct');
              final pendingServiceId = prefs.getInt('pendingServiceId');
              final pendingProductId = prefs.getInt('pendingProductId');
              final pendingCartCheckout = prefs.getBool('pendingCartCheckout') ?? false;
              
              // Save login state and user data
              await prefs.setBool('isLoggedIn', true);
              await prefs.setString('userData', jsonEncode(data['user']));
              
              // Login successful - Navigate based on context
              if (mounted) {
                // Always navigate to HomeScreen first to ensure it's in the stack with userData
                Navigator.pushReplacement(
                  context,
                  MaterialPageRoute(
                    builder: (context) => HomeScreen(userData: data['user']),
                  ),
                );
                
                // Note: pendingCartCheckout is handled in HomeScreen's initState
                // to ensure proper context and state access
                if (pendingCartProductJson != null) {
                  // User came from cart page, push it on top of HomeScreen
                  await prefs.remove('pendingCartProduct'); // Clear the pending cart product
                  final pendingCartProduct = jsonDecode(pendingCartProductJson);
                  // Use a small delay to ensure HomeScreen is built first
                  Future.delayed(const Duration(milliseconds: 100), () {
                    if (mounted) {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => ProductCartPage(product: pendingCartProduct),
                        ),
                      );
                    }
                  });
                } else if (pendingServiceId != null) {
                  // User came from a service panel, push it on top of HomeScreen
                  await prefs.remove('pendingServiceId'); // Clear the pending serviceId
                  // Use a small delay to ensure HomeScreen is built first
                  Future.delayed(const Duration(milliseconds: 100), () {
                    if (mounted) {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => ServiceDetailsScreen(serviceId: pendingServiceId),
                        ),
                      );
                    }
                  });
                } else if (pendingProductId != null) {
                  // User came from a product page, push it on top of HomeScreen
                  await prefs.remove('pendingProductId'); // Clear the pending productId
                  // Use a small delay to ensure HomeScreen is built first
                  Future.delayed(const Duration(milliseconds: 100), () {
                    if (mounted) {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => ProductDetailsScreen(productId: pendingProductId),
                        ),
                      );
                    }
                  });
                }
              }
            } else {
              // Login failed
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(data['message'] ?? 'Login failed'),
                  backgroundColor: Colors.red,
                ),
              );
            }
          } else {
            // HTTP error
            final data = jsonDecode(response.body);
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Server error occurred'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      } catch (e) {
        if (mounted) {
    setState(() {
            _isLoading = false;
          });

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Connection error: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  Future<void> _showForgotPasswordDialog(BuildContext context) async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const ForgotPasswordDialog(),
    );
  }

  Widget _buildIconCircle(IconData icon, Color color) {
    return Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        shape: BoxShape.circle,
      ),
      child: Icon(
        icon,
        color: color,
        size: 20,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    const mintBackground = Color(0xFF00BFA5); // Vibrant teal/aqua color

    return Scaffold(
      backgroundColor: Colors.white,
      body: LayoutBuilder(
        builder: (context, constraints) {
          final availableHeight = constraints.maxHeight > 0 ? constraints.maxHeight : size.height;
          final horizontalPadding = size.width > 720 ? size.width * 0.2 : 24.0;
          final formHeight = availableHeight < 740 ? 420.0 : availableHeight * 0.55;

          return SingleChildScrollView(
            child: ConstrainedBox(
              constraints: BoxConstraints(minHeight: availableHeight),
              child: Padding(
                padding: EdgeInsets.fromLTRB(horizontalPadding, availableHeight * 0.08, horizontalPadding, 32),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                        // Logo Icon - Circular with light green background and darker green shopping cart
                        Container(
                          width: 80,
                          height: 80,
                          decoration: BoxDecoration(
                            color: const Color(0xFF00BFA5).withOpacity(0.2),
                        shape: BoxShape.circle,
                          ),
                          child: Center(
                            child: Icon(
                              Icons.shopping_cart,
                              size: 40,
                              color: const Color(0xFF00BFA5).withOpacity(0.8),
                      ),
                    ),
                  ),
                        const SizedBox(height: 24),
                        Text(
                          'Super Daily',
                          style: GoogleFonts.poppins(
                            fontSize: size.width > 600 ? 36 : 28,
                            fontWeight: FontWeight.bold,
                            color: Colors.grey.shade900,
                            letterSpacing: 0.5,
                          ),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Ease Your Everyday',
                          style: GoogleFonts.poppins(
                            fontSize: 14,
                            fontWeight: FontWeight.w400,
                            color: Colors.grey.shade600,
                          ),
                          textAlign: TextAlign.center,
                        ),
                        SizedBox(height: availableHeight * 0.06),
                        Container(
                          width: double.infinity,
                          padding: const EdgeInsets.fromLTRB(24, 32, 24, 32),
                          decoration: BoxDecoration(
                            color: const Color(0xFF00BFA5),
                            borderRadius: BorderRadius.circular(20),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.08),
                                blurRadius: 20,
                                offset: const Offset(0, 4),
                              ),
                            ],
                          ),
                          child: Column(
                            children: [
                              Container(
                                decoration: BoxDecoration(
                                  color: Colors.white.withOpacity(0.2),
                                  borderRadius: BorderRadius.circular(32),
                                ),
                                padding: const EdgeInsets.all(4),
                                child: TabBar(
                                  controller: _tabController,
                                  dividerColor: Colors.transparent,
                                  indicator: BoxDecoration(
                                    color: Colors.white,
                                    borderRadius: BorderRadius.circular(28),
                                    boxShadow: const [
                                      BoxShadow(
                                        color: Color(0x14000000),
                                        blurRadius: 24,
                                        offset: Offset(0, 10),
                                      ),
                                    ],
                                  ),
                                  indicatorSize: TabBarIndicatorSize.tab,
                                  labelColor: const Color(0xFF00BFA5),
                                  unselectedLabelColor: Colors.white,
                                  labelStyle: GoogleFonts.poppins(
                                    fontSize: 16,
                                    fontWeight: FontWeight.w600,
                                  ),
                                  unselectedLabelStyle: GoogleFonts.poppins(
                                    fontSize: 16,
                                    fontWeight: FontWeight.w500,
                                  ),
                                  tabs: const [
                                    Tab(text: 'Login'),
                                    Tab(text: 'Sign Up'),
                                  ],
                                ),
                              ),
                              const SizedBox(height: 32),
                              SizedBox(
                                height: formHeight,
                                child: TabBarView(
                                  controller: _tabController,
                                  children: [
                                    _buildLoginForm(context),
                                    _buildSignUpForm(context),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildLoginForm(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.zero,
      child: Form(
        key: _loginFormKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                controller: _phoneController,
                keyboardType: TextInputType.phone,
                inputFormatters: [
                  FilteringTextInputFormatter.digitsOnly,
                  LengthLimitingTextInputFormatter(10),
                ],
                decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.email_outlined, color: Colors.grey.shade600),
                  hintText: 'Email or Phone',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                ),
                validator: _validatePhone,
              ),
            ),
            const SizedBox(height: 20),
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                controller: _passwordController,
                obscureText: _obscurePassword,
                decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.lock_outline, color: Colors.grey.shade600),
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword ? Icons.visibility_off_outlined : Icons.visibility_outlined,
                      color: Colors.grey.shade600,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscurePassword = !_obscurePassword;
                      });
                    },
                  ),
                  hintText: 'Password',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                ),
                validator: _validatePassword,
              ),
            ),
            const SizedBox(height: 12),
            Align(
              alignment: Alignment.centerRight,
              child: TextButton(
                onPressed: () => _showForgotPasswordDialog(context),
                child: Text(
                  'Forgot Password?',
                  style: GoogleFonts.poppins(
                    fontSize: 14,
                    color: Colors.white,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _isLoading ? null : _handleLogin,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.white,
                foregroundColor: const Color(0xFF00BFA5),
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                elevation: 0,
              ),
              child: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
                      ),
                    )
                  : Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          'Sign In',
                          style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(width: 8),
                        const Icon(Icons.arrow_forward, size: 20),
                      ],
                    ),
            ),
            const SizedBox(height: 24),
            Center(
              child: Text(
                'or continue with',
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  fontWeight: FontWeight.w400,
                  color: Colors.white,
                ),
              ),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.white,
                foregroundColor: Colors.black,
                padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                elevation: 0,
              ),
              onPressed: _isLoading ? null : () async {
                try {
                  await _handleGoogleSignIn();
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text("Login Successful!"),
                        backgroundColor: Colors.green,
                        duration: Duration(seconds: 2),
                      ),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text("Error: $e"),
                        backgroundColor: Colors.red,
                        duration: const Duration(seconds: 2),
                      ),
                    );
                  }
                }
              },
              child: Row(
                mainAxisSize: MainAxisSize.min,
              children: [
                  Image.asset(
                    'Login panel Assets/social 1.png',
                    height: 24,
                    errorBuilder: (context, error, stackTrace) {
                      return Icon(Icons.g_mobiledata, size: 24, color: Colors.red.shade600);
                    },
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "Sign in with Google",
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSocialButton(IconData icon, Color color) {
    return Container(
      width: 56,
      height: 56,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: IconButton(
        icon: Icon(icon, color: color, size: 24),
        onPressed: () {
          if (icon == Icons.g_mobiledata) {
            // Google Sign-In
            _handleGoogleSignIn();
          } else if (icon == Icons.apple) {
            // Apple Sign-In (coming soon)
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Apple login coming soon'),
                duration: Duration(seconds: 1),
              ),
            );
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Social login coming soon'),
                duration: Duration(seconds: 1),
              ),
            );
          }
        },
      ),
    );
  }

  Future<void> _handleGoogleSignIn() async {
    try {
      setState(() {
        _isLoading = true;
      });

      // Trigger the authentication flow
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      
      if (googleUser == null) {
        // User cancelled the sign-in
        setState(() {
          _isLoading = false;
        });
        return;
      }

      // Obtain auth details
      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;

      // Create a credential
      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      // Sign in with Firebase
      final UserCredential userCredential = await FirebaseAuth.instance.signInWithCredential(credential);
      
      // Get user information from Firebase
      final User? firebaseUser = userCredential.user;
      if (firebaseUser == null) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Unable to sign in with Google'),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 2),
          ),
        );
        return;
      }

      // Get user information - prioritize email from Google account selection
      // Try to get email from googleUser first (the account they selected)
      String email = googleUser.email ?? '';
      // If not available, fall back to Firebase user email
      if (email.isEmpty) {
        email = firebaseUser.email ?? '';
      }
      
      // Get name - prioritize from Google account
      String name = googleUser.displayName ?? '';
      if (name.isEmpty) {
        name = firebaseUser.displayName ?? '';
      }
      
      final String? photoUrl = firebaseUser.photoURL ?? googleUser.photoUrl;
      final String? idToken = googleAuth.idToken;

      // Log the captured email for debugging
      debugPrint("ðŸ” [GOOGLE SIGN-IN] Email captured from selected account: $email");
      debugPrint("ðŸ” [GOOGLE SIGN-IN] Name captured: $name");

      if (email.isEmpty) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Unable to get email from Google account'),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 2),
          ),
        );
        return;
      }

      // Firebase authentication successful
      debugPrint("âœ… [GOOGLE SIGN-IN] Firebase Login Successful! Email: $email");

      // Check if user exists in database or create new account
      // First, try to login with email
      debugPrint("ðŸ” [GOOGLE SIGN-IN] Attempting login with email: $email");
      try {
        const String loginUrl = 'https://superdailys.com/superdailyapp/login.php';
        final loginResponse = await http.post(
          Uri.parse(loginUrl),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode({
            'email': email,
            'google_sign_in': true,
            'google_id_token': idToken,
          }),
        );

        if (loginResponse.statusCode == 200) {
          final loginData = jsonDecode(loginResponse.body);
          if (loginData['success'] == true) {
            // User exists, login successful
            debugPrint("âœ… [GOOGLE SIGN-IN] User found in database. Email: ${loginData['user']['email']}");
            await _handleSuccessfulLogin(loginData['user']);
            return;
          }
        } else if (loginResponse.statusCode == 404) {
          // User doesn't exist, proceed to registration
          debugPrint("ðŸ“ [GOOGLE SIGN-IN] User not found. Proceeding to registration with email: $email");
          // This is expected, so we'll continue to registration below
        }
      } catch (e) {
        debugPrint('Login attempt failed: $e');
      }

      // User doesn't exist, try to register
      debugPrint("ðŸ“ [GOOGLE SIGN-IN] Registering new user with email: $email");
      try {
        const String registerUrl = 'https://superdailys.com/superdailyapp/register.php';
        final registerData = {
          'name': name.isNotEmpty ? name : email.split('@')[0],
          'email': email,
          'phone': '', // Google doesn't provide phone, user can update later
          'password': '', // No password for Google sign-in
          'address': '', // User can update later
          'google_sign_in': true,
          'google_id_token': idToken,
        };
        debugPrint("ðŸ“¤ [GOOGLE SIGN-IN] Sending registration data: email=$email, name=${registerData['name']}");
        final registerResponse = await http.post(
          Uri.parse(registerUrl),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(registerData),
        );

        if (registerResponse.statusCode == 200) {
          final registerResponseData = jsonDecode(registerResponse.body);
          if (registerResponseData['success'] == true) {
            // Registration successful, login the user
            debugPrint("âœ… [GOOGLE SIGN-IN] Registration successful! Email stored: ${registerResponseData['user']['email']}");
            await _handleSuccessfulLogin(registerResponseData['user']);
            return;
          } else {
            // Registration failed, show error
            setState(() {
              _isLoading = false;
            });
            debugPrint("âŒ [GOOGLE SIGN-IN] Registration failed: ${registerResponseData['message']}");
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(registerResponseData['message'] ?? 'Registration failed'),
                backgroundColor: Colors.red,
                duration: const Duration(seconds: 2),
              ),
            );
            return;
          }
        }
      } catch (e) {
        debugPrint('Registration attempt failed: $e');
      }

      // If both login and register fail, show error
      setState(() {
        _isLoading = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Unable to sign in with Google. Please try again.'),
          backgroundColor: Colors.red,
          duration: Duration(seconds: 2),
        ),
      );
    } catch (error) {
      setState(() {
        _isLoading = false;
      });
      debugPrint('Google Sign-In error: $error');
      
      String errorMessage = 'Google Sign-In failed';
      if (error.toString().contains('ClientID not set') || error.toString().contains('appClientId')) {
        errorMessage = 'Google Sign-In is not configured. Please add your Google OAuth Client ID in web/index.html or contact support.';
      } else {
        errorMessage = 'Google Sign-In failed: ${error.toString()}';
      }
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(errorMessage),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 4),
        ),
      );
    }
  }

  Future<void> _handleSuccessfulLogin(Map<String, dynamic> userData) async {
    final prefs = await SharedPreferences.getInstance();
    
    // Check for pending navigation
    final pendingCartProductJson = prefs.getString('pendingCartProduct');
    final pendingServiceId = prefs.getInt('pendingServiceId');
    final pendingProductId = prefs.getInt('pendingProductId');
    final pendingCartCheckout = prefs.getBool('pendingCartCheckout') ?? false;
    
    // Save login state and user data
    await prefs.setBool('isLoggedIn', true);
    await prefs.setString('userData', jsonEncode(userData));
    
    // Save OneSignal player ID if available
    if (!kIsWeb) {
      final savedPlayerId = prefs.getString('onesignal_player_id');
      if (savedPlayerId != null && savedPlayerId.isNotEmpty) {
        final userId = userData['id']?.toString();
        if (userId != null && userId.isNotEmpty) {
          try {
            final response = await http.post(
              Uri.parse('${kBackendBaseUrl}save_push_subscription.php'),
              headers: {'Content-Type': 'application/json'},
              body: jsonEncode({
                'user_id': int.parse(userId),
                'player_id': savedPlayerId,
                'endpoint': '',
                'keys': {},
              }),
            );
            if (response.statusCode == 200) {
              await prefs.remove('onesignal_player_id');
              debugPrint('OneSignal player ID saved after login');
            }
          } catch (e) {
            debugPrint('Error saving OneSignal player ID after login: $e');
          }
        }
      }
      
      // Also try to get current player ID
      try {
        final playerId = await OneSignal.User.pushSubscription.id;
        if (playerId != null && playerId.isNotEmpty) {
          final userId = userData['id']?.toString();
          if (userId != null && userId.isNotEmpty) {
            final response = await http.post(
              Uri.parse('${kBackendBaseUrl}save_push_subscription.php'),
              headers: {'Content-Type': 'application/json'},
              body: jsonEncode({
                'user_id': int.parse(userId),
                'player_id': playerId,
                'endpoint': '',
                'keys': {},
              }),
            );
            if (response.statusCode == 200) {
              debugPrint('OneSignal player ID saved after login (current)');
            }
          }
        }
      } catch (e) {
        debugPrint('Error getting OneSignal player ID after login: $e');
      }
    }
    
    setState(() {
      _isLoading = false;
    });
    
    // Navigate based on context
    if (mounted) {
      // Always navigate to HomeScreen first
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(
          builder: (context) => HomeScreen(userData: userData),
        ),
      );
      
      // Note: pendingCartCheckout is handled in HomeScreen's initState
      // to ensure proper context and state access
      if (pendingCartProductJson != null) {
        await prefs.remove('pendingCartProduct');
        final pendingCartProduct = jsonDecode(pendingCartProductJson);
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted) {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ProductCartPage(product: pendingCartProduct),
              ),
            );
          }
        });
      } else if (pendingServiceId != null) {
        await prefs.remove('pendingServiceId');
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted) {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ServiceDetailsScreen(serviceId: pendingServiceId),
              ),
            );
          }
        });
      } else if (pendingProductId != null) {
        await prefs.remove('pendingProductId');
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted) {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ProductDetailsScreen(productId: pendingProductId),
              ),
            );
          }
        });
      }
    }
  }

  Widget _buildLoginFormOld(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.zero,
      child: Form(
        key: _loginFormKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: Text(
                'Phone no:',
                style: GoogleFonts.poppins(
                  fontSize: 15,
                  fontWeight: FontWeight.w600,
                  color: Colors.black87,
                ),
              ),
            ),
            Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(30),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.06),
                    blurRadius: 20,
                    offset: const Offset(0, 10),
                  ),
                ],
              ),
              child: TextFormField(
                controller: _phoneController,
                keyboardType: TextInputType.number,
                inputFormatters: [
                  FilteringTextInputFormatter.digitsOnly,
                  LengthLimitingTextInputFormatter(10),
                ],
                decoration: const InputDecoration(
                  border: InputBorder.none,
                  contentPadding: EdgeInsets.symmetric(horizontal: 24, vertical: 18),
                ),
                validator: _validatePhone,
              ),
            ),
            const SizedBox(height: 24),
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: Text(
                'Password:',
                style: GoogleFonts.poppins(
                  fontSize: 15,
                  fontWeight: FontWeight.w600,
                  color: Colors.black87,
                ),
              ),
            ),
            Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(30),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.06),
                    blurRadius: 20,
                    offset: const Offset(0, 10),
                  ),
                ],
              ),
              child: TextFormField(
                controller: _passwordController,
                obscureText: _obscurePassword,
                decoration: InputDecoration(
                  border: InputBorder.none,
                  contentPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword ? Icons.visibility_outlined : Icons.visibility_off_outlined,
                      color: Colors.grey.shade600,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscurePassword = !_obscurePassword;
                      });
                    },
                  ),
                ),
                validator: _validatePassword,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                GestureDetector(
                  onTap: () {
                    _tabController.animateTo(1);
                  },
                  child: Text(
                    'Register',
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      color: Colors.black87,
                    ),
                  ),
                ),
                GestureDetector(
                  onTap: () {
                    _showForgotPasswordDialog(context);
                  },
                  child: Text(
                    'Forgot Password',
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      color: Colors.black54,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 28),
            ElevatedButton(
              onPressed: _isLoading ? null : _handleLogin,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF0D47A1),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 18),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30),
                ),
                elevation: 0,
              ),
              child: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      ),
                    )
                  : Text(
                      'Login',
                      style: GoogleFonts.poppins(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
            ),
            const SizedBox(height: 28),
            Center(
              child: Text(
                'Or Login with...',
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                  color: Colors.black.withOpacity(0.7),
                ),
              ),
            ),
            const SizedBox(height: 20),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Container(
                  width: 52,
                  height: 52,
                  decoration: const BoxDecoration(
                    color: Colors.black,
                    shape: BoxShape.circle,
                  ),
                  child: Center(
                    child: Text(
                      'G',
                      style: GoogleFonts.poppins(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 20),
                Container(
                  width: 52,
                  height: 52,
                  decoration: const BoxDecoration(
                    color: Colors.black,
                    shape: BoxShape.circle,
                  ),
                  child: const Icon(
                    Icons.apple,
                    color: Colors.white,
                    size: 26,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSignUpForm(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.zero,
                                  child: Form(
                                    key: _signupFormKey,
                                      child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.stretch,
                                        children: [
                                          // Full Name Field
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                                            controller: _fullNameController,
                                            keyboardType: TextInputType.name,
                decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.person_outline, color: Colors.grey.shade600),
                  hintText: 'Full Name',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                ),
                validator: _validateFullName,
              ),
            ),
            const SizedBox(height: 12),

            // Email Field
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                                            controller: _emailController,
                                            keyboardType: TextInputType.emailAddress,
                                            inputFormatters: [
                                              FilteringTextInputFormatter.deny(RegExp(r'\s')),
                                              LengthLimitingTextInputFormatter(254),
                                            ],
                decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.email_outlined, color: Colors.grey.shade600),
                  hintText: 'Email',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                ),
                validator: _validateEmail,
              ),
            ),
            const SizedBox(height: 12),

            // Phone Number Field
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                                            controller: _signupPhoneController,
                                            keyboardType: TextInputType.number,
                                            inputFormatters: [
                                              FilteringTextInputFormatter.digitsOnly,
                                              LengthLimitingTextInputFormatter(10),
                                            ],
                decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.phone_outlined, color: Colors.grey.shade600),
                  hintText: 'Phone Number',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                ),
                validator: _validatePhone,
              ),
            ),
            const SizedBox(height: 12),

            // Password Field
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                                            controller: _signupPasswordController,
                                            obscureText: _obscureSignupPassword,
                                            decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.lock_outline, color: Colors.grey.shade600),
                                              suffixIcon: IconButton(
                                                icon: Icon(
                      _obscureSignupPassword ? Icons.visibility_off_outlined : Icons.visibility_outlined,
                      color: Colors.grey.shade600,
                                                ),
                                                onPressed: () {
                                                  setState(() {
                                                    _obscureSignupPassword = !_obscureSignupPassword;
                                                  });
                                                },
                                              ),
                  hintText: 'Password',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                ),
                validator: _validatePassword,
              ),
            ),
            const SizedBox(height: 12),

            // Confirm Password Field
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                                            controller: _confirmPasswordController,
                                            obscureText: _obscureConfirmPassword,
                                            decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.lock_outline, color: Colors.grey.shade600),
                                              suffixIcon: IconButton(
                                                icon: Icon(
                      _obscureConfirmPassword ? Icons.visibility_off_outlined : Icons.visibility_outlined,
                      color: Colors.grey.shade600,
                                                ),
                                                onPressed: () {
                                                  setState(() {
                                                    _obscureConfirmPassword = !_obscureConfirmPassword;
                                                  });
                                                },
                                              ),
                  hintText: 'Confirm Password',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                ),
                validator: _validateConfirmPassword,
              ),
            ),
            const SizedBox(height: 12),

            // Address Field
            Container(
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TextFormField(
                                            controller: _addressController,
                                            keyboardType: TextInputType.streetAddress,
                                            maxLines: 2,
                decoration: InputDecoration(
                  border: InputBorder.none,
                  prefixIcon: Icon(Icons.location_on_outlined, color: Colors.grey.shade600),
                  hintText: 'Address',
                  hintStyle: GoogleFonts.poppins(
                    color: Colors.grey.shade500,
                    fontSize: 14,
                  ),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey.shade900,
                                            ),
                                            validator: _validateAddress,
              ),
                    ),
            const SizedBox(height: 16),

            // Sign Up Button
                                          ElevatedButton(
                                            onPressed: _isSignupLoading ? null : _handleSignup,
                                            style: ElevatedButton.styleFrom(
                backgroundColor: Colors.white,
                foregroundColor: const Color(0xFF00BFA5),
                padding: const EdgeInsets.symmetric(vertical: 14),
                                              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                                              ),
                elevation: 0,
                                            ),
                                            child: _isSignupLoading
                                                ? const SizedBox(
                                                    height: 20,
                                                    width: 20,
                                                    child: CircularProgressIndicator(
                                                      strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
                                                    ),
                                                  )
                  : Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                            'Sign Up',
                            style: GoogleFonts.poppins(
                                                      fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        const SizedBox(width: 8),
                        const Icon(Icons.arrow_forward, size: 20),
                      ],
            ),
            ),
            const SizedBox(height: 16),
            
            // Sign up with Google button
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.white,
                foregroundColor: Colors.black,
                padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                elevation: 0,
              ),
              onPressed: _isSignupLoading ? null : () async {
                try {
                  await _handleGoogleSignIn();
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text("Error: $e"),
                        backgroundColor: Colors.red,
                        duration: const Duration(seconds: 2),
                      ),
                    );
                  }
                }
              },
              child: Row(
                mainAxisSize: MainAxisSize.min,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Image.asset(
                    'Login panel Assets/social 1.png',
                    height: 24,
                    errorBuilder: (context, error, stackTrace) {
                      return Icon(Icons.g_mobiledata, size: 24, color: Colors.red.shade600);
                    },
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "Sign up with Google",
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Widget for product details image with proxy fallback
class _ProductDetailsImageWidget extends StatefulWidget {
  final String imageUrl;
  final String productName;

  const _ProductDetailsImageWidget({
    required this.imageUrl,
    required this.productName,
  });

  @override
  State<_ProductDetailsImageWidget> createState() => _ProductDetailsImageWidgetState();
}

class _ProductDetailsImageWidgetState extends State<_ProductDetailsImageWidget> {
  int _currentFallbackIndex = 0; // 0 = direct, 1 = proxy
  bool _hasError = false;

  String _getProxiedUrl(String url) {
    final encodedUrl = Uri.encodeComponent(url);
    return 'https://superdailys.com/superdailyapp/proxy_image.php?url=$encodedUrl';
  }

  String _getCurrentImageUrl() {
    // If direct URL failed and we haven't tried proxy yet, use proxy
    if (_currentFallbackIndex == 1) {
      return _getProxiedUrl(widget.imageUrl);
    }
    return widget.imageUrl;
  }

  @override
  Widget build(BuildContext context) {
    if (_hasError) {
      return Center(
        child: Icon(
          Icons.image_not_supported,
          size: 80,
          color: Colors.grey.shade400,
        ),
      );
    }

    final imageUrl = _getCurrentImageUrl();
    debugPrint('ðŸ–¼ï¸ Product Details - Trying to load image (${_currentFallbackIndex == 0 ? 'direct' : 'proxy'}) for "${widget.productName}": $imageUrl');

    return CachedNetworkImage(
      imageUrl: imageUrl,
      fit: BoxFit.cover,
      httpHeaders: {
        'Accept': 'image/*',
      },
      placeholder: (context, url) => Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
        ),
      ),
      errorWidget: (context, url, error) {
        debugPrint('âŒ Product Details - Image failed to load (${_currentFallbackIndex == 0 ? 'direct' : 'proxy'}) for "${widget.productName}": $url');
        debugPrint('   Error type: ${error.runtimeType}');
        debugPrint('   Error: $error');
        
        // If direct URL failed, try proxy
        if (_currentFallbackIndex == 0) {
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _currentFallbackIndex = 1; // Try proxy
              });
            }
          });
          return Center(
            child: CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
            ),
          );
        } else {
          // Proxy also failed
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _hasError = true;
              });
            }
          });
          return Center(
            child: Icon(
              Icons.image_not_supported,
              size: 80,
              color: Colors.grey.shade400,
            ),
          );
        }
      },
    );
  }
}

// Home Screen Widget
// Product Details Screen
class ProductDetailsScreen extends StatefulWidget {
  final int productId;
  final Function(Map<String, dynamic>)? onAddToCart;
  final Function(int, int)? onUpdateCartQuantity;
  final Function(int)? onRemoveFromCart;
  final Function()? onCartUpdated;
  final int Function(dynamic)? getCartItemQuantity;
  final int Function()? getCartItemCount;
  final List<Map<String, dynamic>>? cartItems;

  const ProductDetailsScreen({
    super.key,
    required this.productId,
    this.onAddToCart,
    this.onUpdateCartQuantity,
    this.onRemoveFromCart,
    this.onCartUpdated,
    this.getCartItemQuantity,
    this.getCartItemCount,
    this.cartItems,
  });

  @override
  State<ProductDetailsScreen> createState() => _ProductDetailsScreenState();
}

class _ProductDetailsScreenState extends State<ProductDetailsScreen> {
  Map<String, dynamic>? _product;
  bool _isLoading = true;
  String? _errorMessage;
  PageController _imageController = PageController();
  int _currentImageIndex = 0;
  Razorpay? _razorpay;
  bool _isProcessingPayment = false;
  static const Color _tealColor = Color(0xFF00BFA5);
  static const Color _tealLight = Color(0xFFE0F2F1);

  // Helper to normalize product ID to int for comparison
  int _normalizeProductId(dynamic id) {
    if (id == null) return 0;
    if (id is int) return id;
    if (id is String) {
      final parsed = int.tryParse(id);
      return parsed ?? 0;
    }
    if (id is num) return id.toInt();
    return 0;
  }

  int _getCartItemQuantity() {
    if (widget.getCartItemQuantity == null || _product == null) return 0;
    final productId = _product!['id'];
    return widget.getCartItemQuantity!(productId);
  }

  int _getCartItemCount() {
    if (widget.getCartItemCount == null) return 0;
    return widget.getCartItemCount!();
  }

  @override
  void initState() {
    super.initState();
    _imageController = PageController();
    // Initialize Razorpay only for mobile platforms (Android/iOS)
    if (!kIsWeb) {
      _razorpay = Razorpay();
      _razorpay!.on(Razorpay.EVENT_PAYMENT_SUCCESS, _handlePaymentSuccess);
      _razorpay!.on(Razorpay.EVENT_PAYMENT_ERROR, _handlePaymentError);
      _razorpay!.on(Razorpay.EVENT_EXTERNAL_WALLET, _handleExternalWallet);
    }
    _fetchProductDetails();
  }

  @override
  void dispose() {
    _imageController.dispose();
    if (!kIsWeb && _razorpay != null) {
      _razorpay!.clear();
    }
    super.dispose();
  }

  void _handlePaymentSuccess(PaymentSuccessResponse response) async {
    if (mounted) {
      setState(() {
        _isProcessingPayment = false;
      });
      
      // Create order payload
      final prefs = await SharedPreferences.getInstance();
      final userDataJson = prefs.getString('userData');
      Map<String, dynamic>? userData;
      if (userDataJson != null) {
        userData = jsonDecode(userDataJson);
      }
      
      if (_product != null && userData != null) {
        final sellingPrice = _product!['selling_price'] ?? _product!['price'] ?? 0.0;
        final price = (sellingPrice is String) ? double.tryParse(sellingPrice) ?? 0.0 : (sellingPrice as num).toDouble();
        
        final orderPayload = {
          'user_id': userData['id'] ?? userData['user_id'],
          'product_id': widget.productId,
          'quantity': 1,
          'price': price,
          'total_amount': price,
          'payment_status': 'paid',
          'payment_method': 'razorpay',
          'payment_id': response.paymentId,
          'transaction_id': response.orderId ?? response.paymentId,
          'status': 'pending',
          'order_date': DateTime.now().toIso8601String(),
        };
        
        // Submit order to backend
        final orderResult = await _submitProductOrder(orderPayload);
        
        if (orderResult['success'] == true) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(orderResult['message'] ?? 'Payment successful! Order placed successfully.'),
              backgroundColor: Colors.green,
              duration: const Duration(seconds: 2),
            ),
          );
          
          // Navigate to My Orders screen
          Future.delayed(const Duration(seconds: 1), () {
            if (mounted) {
              // Pop all screens until we reach home, then navigate to My Orders
              Navigator.of(context).popUntil((route) => route.isFirst);
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => MyOrdersScreen(userData: userData!),
                ),
              );
            }
          });
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Payment successful but order creation failed: ${orderResult['message'] ?? 'Unknown error. Please contact support.'}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 5),
            ),
          );
        }
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Payment successful but order creation failed. Please contact support.'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 4),
          ),
        );
      }
    }
  }
  
  Future<Map<String, dynamic>> _submitProductOrder(Map<String, dynamic> payload) async {
    try {
      debugPrint('Submitting order with payload: ${jsonEncode(payload)}');
      final uri = Uri.parse('https://superdailys.com/superdailyapp/orders_create.php');
      final res = await http.post(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(payload),
      );
      debugPrint('Order create response status: ${res.statusCode}');
      debugPrint('Order create response body: ${res.body}');
      
      if (res.statusCode == 200) {
        final data = jsonDecode(res.body);
        if (data is Map && (data['success'] == true || data['status'] == 'ok')) {
          return {'success': true, 'message': data['message'] ?? 'Order created successfully'};
        }
        // Return error message from backend
        final errorMsg = data is Map ? (data['message'] ?? data['error'] ?? 'Order creation failed') : 'Order creation failed';
        debugPrint('Order create response (not success): ' + jsonEncode(data));
        return {'success': false, 'message': errorMsg};
      }
      // Try to parse error from response body
      String errorMsg = 'Order creation failed (Status: ${res.statusCode})';
      try {
        final errorData = jsonDecode(res.body);
        if (errorData is Map) {
          errorMsg = errorData['message'] ?? errorData['error'] ?? errorMsg;
        }
      } catch (_) {
        errorMsg = 'Order creation failed (Status: ${res.statusCode})';
      }
      debugPrint('Order create failed: ' + res.statusCode.toString() + ' ' + res.body);
      return {'success': false, 'message': errorMsg};
    } catch (e) {
      debugPrint('Order create error: ' + e.toString());
      return {'success': false, 'message': 'Network error: ${e.toString()}'};
    }
  }

  void _handlePaymentError(PaymentFailureResponse response) {
    if (mounted) {
      setState(() {
        _isProcessingPayment = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Payment failed: ${response.message ?? "Unknown error"}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _handleExternalWallet(ExternalWalletResponse response) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('External wallet selected: ${response.walletName}'),
        ),
      );
    }
  }

  Future<void> _initiateProductPayment() async {
    if (_product == null) return;

    // Check if user is logged in
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    if (!isLoggedIn) {
      if (mounted) {
        // Store the productId so we can return to this product page after login
        await prefs.setInt('pendingProductId', widget.productId);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please login to add products to cart'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 2),
          ),
        );
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const LoginPage()),
        );
      }
      return;
    }

    try {
      // Get product price
      final sellingPrice = _product!['selling_price'] ?? _product!['price'] ?? 0.0;
      final price = (sellingPrice is String) ? double.tryParse(sellingPrice) ?? 0.0 : (sellingPrice as num).toDouble();
      
      if (price <= 0) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Invalid product price'),
            backgroundColor: Colors.red,
          ),
        );
        return;
      }

      final productName = _product!['name'] ?? 'Product';
      
      setState(() {
        _isProcessingPayment = true;
      });

      // Get user data from SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      final userDataJson = prefs.getString('userData');
      Map<String, dynamic>? userData;
      if (userDataJson != null) {
        userData = jsonDecode(userDataJson);
      }

      final options = {
        'key': kRazorpayKeyId,
        'amount': (price * 100).toInt(), // Amount in paise
        'name': 'Super Daily',
        'description': 'Product Purchase: $productName',
        'prefill': {
          'contact': userData?['phone'] ?? '',
          'email': userData?['email'] ?? '',
        },
        'external': {
          'wallets': ['paytm']
        },
      };

      if (kIsWeb) {
        // For web, show payment dialog
        await _initiateRazorpayWeb(options, price);
      } else {
        // Use Razorpay Flutter SDK for mobile
        if (_razorpay != null) {
          _razorpay!.open(options);
        } else {
          setState(() {
            _isProcessingPayment = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isProcessingPayment = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error initiating payment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _initiateRazorpayWeb(Map<String, dynamic> options, double amount) async {
    if (mounted) {
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Payment Required'),
          content: Text(
            'Product purchase requires payment of â‚¹${amount.toStringAsFixed(2)}.\n\n'
            'For web payments, Razorpay integration requires server-side order creation.\n\n'
            'Would you like to proceed?',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Continue'),
            ),
          ],
        ),
      );
      
      if (confirm == true) {
        setState(() {
          _isProcessingPayment = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please complete payment via mobile app or contact support.'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 4),
          ),
        );
      } else {
        setState(() {
          _isProcessingPayment = false;
        });
      }
    }
  }

  Future<void> _fetchProductDetails() async {
    try {
      final response = await http.get(
        Uri.parse('https://superdailys.com/superdailyapp/get_product_details.php?id=${widget.productId}'),
        headers: {'Content-Type': 'application/json'},
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            setState(() {
              _product = data['product'];
              _isLoading = false;
            });
            // Set image count for page indicator
            if (_product != null) {
              List<String> images = _getProductImages();
              if (images.isNotEmpty && _imageController.hasClients) {
                _imageController.jumpToPage(0);
              }
            }
          } else {
            setState(() {
              _errorMessage = data['message'] ?? 'Failed to load product';
              _isLoading = false;
            });
          }
        } else {
          setState(() {
            _errorMessage = 'Failed to load product. Status: ${response.statusCode}';
            _isLoading = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = 'Error: $e';
          _isLoading = false;
        });
      }
    }
  }

  List<String> _getProductImages() {
    if (_product == null) return [];
    List<String> images = [];
    
    // Collect all available images and resolve URLs
    for (var imgKey in ['image', 'image_2', 'image_3', 'image_4']) {
      final imgValue = _product![imgKey];
      if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
        final resolvedUrl = _resolveImageUrl(imgValue.toString());
        if (resolvedUrl.isNotEmpty && resolvedUrl.startsWith('http')) {
          images.add(resolvedUrl);
          debugPrint('ðŸ–¼ï¸ Product Details - Found image from $imgKey: $resolvedUrl');
        }
      }
    }
    
    return images; // Return empty list if no images
  }
  
  String _resolveImageUrl(String raw) {
    if (raw.isEmpty) return raw;
    String p = raw.trim();
    // Normalize slashes
    p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
    
    // Already absolute URL starting with https://superdailys.com/storage/products/
    if (p.startsWith('https://superdailys.com/storage/products/')) {
      return p;
    }
    
    // Handle URLs with superdailyapp/storage/products/ and convert to storage/products/
    if (p.contains('/superdailyapp/storage/products/')) {
      final filename = p.split('/').last.split('?').first.split('#').first;
      if (filename.isNotEmpty && filename.contains('.')) {
        final correctedUrl = 'https://superdailys.com/storage/products/' + filename;
        debugPrint('ðŸ”„ Product Details - Corrected URL from superdailyapp path: $correctedUrl');
        return correctedUrl;
      }
    }
    
    // Already absolute URL (any other URL)
    if (p.startsWith('http://') || p.startsWith('https://')) {
      // If it's a full URL but not from the storage/products path, try to extract filename
      if (!p.contains('/storage/products/')) {
        final filename = p.split('/').last.split('?').first.split('#').first;
        if (filename.isNotEmpty && filename.contains('.')) {
          return 'https://superdailys.com/storage/products/' + filename;
        }
      }
      return p;
    }
    
    // Extract just the filename from the path
    String filename = p.split('/').last.split('\\').last;
    // Remove query parameters and hash
    filename = filename.split('?').first.split('#').first;
    
    // If filename is empty or doesn't have extension, try to find it
    if (filename.isEmpty || !filename.contains('.')) {
      // Try to find filename in the path
      final parts = p.split('/');
      for (var part in parts.reversed) {
        if (part.contains('.') && part.length > 3) {
          filename = part.split('?').first.split('#').first;
          break;
        }
      }
    }
    
    // Build full URL with storage/products base
    if (filename.isNotEmpty && filename.contains('.')) {
      final url = 'https://superdailys.com/storage/products/' + filename;
      debugPrint('Resolved image URL: $url');
      return url;
    }
    
    // Fallback to old method
    while (p.startsWith('./') || p.startsWith('../')) {
      p = p.startsWith('./') ? p.substring(2) : p.substring(3);
    }
    final spdIdx = p.indexOf('/spdbackend/');
    if (spdIdx != -1) {
      p = p.substring(spdIdx + '/spdbackend/'.length);
    }
    for (final marker in ['/htdocs/', '/www/']) {
      final idx = p.indexOf(marker);
      if (idx != -1) {
        p = p.substring(idx + marker.length);
      }
    }
    if (p.startsWith('/')) p = p.substring(1);
    final url = 'https://superdailys.com/storage/products/' + _basename(p);
    debugPrint('Resolved image URL (fallback): ' + url);
    return url;
  }
  
  String _basename(String p) {
    if (p.isEmpty) return p;
    p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
    final i = p.lastIndexOf('/');
    return i == -1 ? p : p.substring(i + 1);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: _tealColor,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text(
          'Product Details',
          style: GoogleFonts.poppins(
            color: Colors.white,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      body: Stack(
        children: [
          _isLoading
          ? const Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            )
          : _errorMessage != null
              ? Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.error_outline, size: 64, color: Colors.grey.shade400),
                      const SizedBox(height: 16),
            Text(
                        _errorMessage!,
                        style: GoogleFonts.poppins(color: Colors.grey.shade600),
                      ),
                      const SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: () {
                          setState(() {
                            _isLoading = true;
                            _errorMessage = null;
                          });
                          _fetchProductDetails();
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _tealColor,
                        ),
                        child: Text(
                          'Retry',
                          style: GoogleFonts.poppins(color: Colors.white),
                        ),
            ),
          ],
        ),
                )
              : _product == null
                  ? const Center(child: Text('Product not found'))
                  : SingleChildScrollView(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          // Image Carousel
                          _buildImageCarousel(),
                          // Product Details
                          Padding(
                            padding: const EdgeInsets.all(16.0),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                // Product Name
                                Text(
                                  _product!['name'] ?? 'Product Name',
                                  style: GoogleFonts.poppins(
                                    fontSize: 24,
                                    fontWeight: FontWeight.bold,
                                    color: Colors.grey.shade800,
                                  ),
                                ),
                                const SizedBox(height: 8),
                                // Brand Name
                                if (_product!['brand_name'] != null && _product!['brand_name'].toString().isNotEmpty)
                                  Text(
                                    _product!['brand_name'].toString(),
                                    style: GoogleFonts.poppins(
                                      fontSize: 16,
                                      color: Colors.grey.shade600,
                                    ),
                                  ),
                                const SizedBox(height: 16),
                                // Price Section
                                _buildPriceSection(),
                                const SizedBox(height: 16),
                                // Stock Status
                                _buildStockStatus(),
                                const SizedBox(height: 24),
                                // Divider
                                Divider(color: Colors.grey.shade300),
                                const SizedBox(height: 24),
                                // Description Section
                                _buildDescriptionSection(),
                                const SizedBox(height: 24),
                                // Specifications Section
                                if (_product!['specifications'] != null && _product!['specifications'].toString().isNotEmpty)
                                  _buildSpecificationsSection(),
                                // Additional Details
                                const SizedBox(height: 24),
                                _buildAdditionalDetails(),
                                const SizedBox(height: 80), // Space for bottom button
                              ],
                            ),
                          ),
                        ],
                      ),
                        ),
          // View Cart Box
          if (_getCartItemCount() > 0 && widget.cartItems != null && widget.cartItems!.isNotEmpty)
            Positioned(
              bottom: 0, // Position at bottom navbar box
              left: 0,
              right: 0,
              child: GestureDetector(
                onTap: () {
                  // Navigate to ShoppingCartPage
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => ShoppingCartPage(
                        cartItems: widget.cartItems!,
                        onUpdateQuantity: widget.onUpdateCartQuantity ?? (_, __) {},
                        onRemoveItem: widget.onRemoveFromCart ?? (_) {},
                        onClearCart: () {},
                        onCartUpdated: widget.onCartUpdated ?? () {},
                      ),
                    ),
                  ).then((_) {
                    if (widget.onCartUpdated != null) {
                      widget.onCartUpdated!();
                    }
                    setState(() {}); // Refresh to update cart count
                  });
                },
                child: Container(
                  margin: EdgeInsets.only(
                    left: 20,
                    right: 20,
                    bottom: MediaQuery.of(context).padding.bottom,
                  ),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  decoration: BoxDecoration(
                    color: _tealColor,
                    borderRadius: BorderRadius.circular(12),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: Row(
                    children: [
                      // Product Image (first item in cart)
                      if (widget.cartItems!.isNotEmpty)
                        Container(
                          width: 40,
                          height: 40,
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(8),
                            child: widget.cartItems![0]['product']?['image'] != null
                                ? Image.network(
                                    _resolveImageUrl(widget.cartItems![0]['product']?['image']?.toString() ?? ''),
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                      return Icon(Icons.shopping_cart, color: _tealColor, size: 20);
                                    },
                                  )
                                : Icon(Icons.shopping_cart, color: _tealColor, size: 20),
                          ),
                        ),
                      if (widget.cartItems!.isNotEmpty) const SizedBox(width: 12),
                      // View cart text and item count
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              'View cart',
                              style: GoogleFonts.poppins(
                                fontSize: 14,
                                fontWeight: FontWeight.w600,
                                color: Colors.white,
                              ),
                            ),
                            Text(
                              '${_getCartItemCount()} ${_getCartItemCount() == 1 ? 'item' : 'items'}',
                              style: GoogleFonts.poppins(
                                fontSize: 12,
                                color: Colors.white.withOpacity(0.9),
                              ),
                            ),
                          ],
                        ),
                      ),
                      // Arrow icon
                      Icon(Icons.arrow_forward_ios, color: Colors.white, size: 16),
                    ],
                  ),
                ),
              ),
            ),
        ],
                    ),
      bottomNavigationBar: _product != null
          ? Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.white,
                boxShadow: [
                  BoxShadow(
                    color: Colors.grey.withOpacity(0.2),
                    blurRadius: 10,
                    offset: const Offset(0, -2),
                  ),
                ],
              ),
              child: SafeArea(
                child: Builder(
                  builder: (context) {
                    final cartQuantity = _getCartItemQuantity();
                    final stockQuantity = _product!['stock_quantity'] != null
                        ? (_product!['stock_quantity'] is String
                            ? int.tryParse(_product!['stock_quantity']) ?? 0
                            : (_product!['stock_quantity'] as num).toInt())
                        : 0;

                    if (cartQuantity > 0) {
                      // Show increment/decrement buttons
                      return Row(
                  children: [
                          // Decrement button
                          GestureDetector(
                            onTap: () {
                              if (widget.onUpdateCartQuantity != null && widget.onRemoveFromCart != null) {
                                final productId = _normalizeProductId(_product!['id']);
                                if (cartQuantity > 1) {
                                  widget.onUpdateCartQuantity!(productId, cartQuantity - 1);
                                } else {
                                  widget.onRemoveFromCart!(productId);
                                }
                                if (widget.onCartUpdated != null) {
                                  widget.onCartUpdated!();
                                }
                                setState(() {});
                              }
                            },
                            child: Container(
                              width: 48,
                              height: 48,
                              decoration: BoxDecoration(
                                color: _tealColor,
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: const Icon(Icons.remove, color: Colors.white, size: 24),
                            ),
                          ),
                          const SizedBox(width: 16),
                          // Quantity display
                    Expanded(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Text(
                                  '$cartQuantity',
                                  style: GoogleFonts.poppins(
                                    fontSize: 24,
                                    fontWeight: FontWeight.bold,
                                    color: Colors.grey.shade800,
                                  ),
                                ),
                                Text(
                                  'in cart',
                                  style: GoogleFonts.poppins(
                                    fontSize: 12,
                                    color: Colors.grey.shade600,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 16),
                          // Increment button
                          GestureDetector(
                            onTap: () {
                              if (widget.onAddToCart != null && _product != null) {
                                if (cartQuantity < stockQuantity) {
                                  widget.onAddToCart!(_product!);
                                  if (widget.onCartUpdated != null) {
                                    widget.onCartUpdated!();
                                  }
                                  setState(() {});
                                } else {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                      content: Text('Cannot add more. Stock limit reached.'),
                                      backgroundColor: Colors.orange,
                                      duration: Duration(seconds: 2),
                                    ),
                                  );
                                }
                              }
                            },
                            child: Container(
                              width: 48,
                              height: 48,
                              decoration: BoxDecoration(
                                color: _tealColor,
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: const Icon(Icons.add, color: Colors.white, size: 24),
                            ),
                          ),
                        ],
                      );
                    } else {
                      // Show add to cart button
                      return SizedBox(
                        width: double.infinity,
                        child: ElevatedButton.icon(
                          onPressed: _product == null || stockQuantity <= 0
                              ? null
                              : () {
                                  if (widget.onAddToCart != null && _product != null) {
                                    widget.onAddToCart!(_product!);
                                    if (widget.onCartUpdated != null) {
                                      widget.onCartUpdated!();
                                    }
                                    setState(() {});
                                  }
                        },
                        icon: const Icon(Icons.shopping_cart),
                        label: Text(
                            stockQuantity <= 0 ? 'Out of Stock' : 'Add to Cart',
                          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _tealColor,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                        ),
                      ),
                      );
                    }
                  },
                ),
              ),
            )
          : null,
    );
  }

  Widget _buildImageCarousel() {
    List<String> images = _getProductImages();

    return SizedBox(
      height: 350,
      child: Stack(
        children: [
          images.isEmpty
              ? Container(
                  width: double.infinity,
                  color: _tealLight,
                  child: Center(
                    child: Icon(
                      Icons.image,
                      size: 80,
                      color: Colors.grey.shade400,
                    ),
                  ),
                )
              : PageView.builder(
            controller: _imageController,
            itemCount: images.length,
            onPageChanged: (index) {
              setState(() {
                _currentImageIndex = index;
              });
            },
            itemBuilder: (context, index) {
              final imageUrl = images[index];
              return Container(
                width: double.infinity,
                color: _tealLight,
                      child: _ProductDetailsImageWidget(
                        imageUrl: imageUrl,
                        productName: _product?['name'] ?? 'Product',
                      ),
              );
            },
          ),
          // Page Indicator
          if (images.length > 1)
            Positioned(
              bottom: 16,
              left: 0,
              right: 0,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(
                  images.length,
                  (index) => Container(
                    width: 8,
                    height: 8,
                    margin: const EdgeInsets.symmetric(horizontal: 4),
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: _currentImageIndex == index
                          ? Colors.white
                          : Colors.white.withOpacity(0.5),
                    ),
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildPriceSection() {
    final sellingPrice = _product!['selling_price'] ?? _product!['price'] ?? 0;
    final mrpPrice = _product!['mrp_price'] ?? sellingPrice;
    final discountPercentage = _product!['discount_percentage'] ?? 0;

    // Convert to numbers safely - handle null, string, and number types
    double sellingPriceNum = 0.0;
    if (sellingPrice != null) {
      if (sellingPrice is String) {
        sellingPriceNum = double.tryParse(sellingPrice) ?? 0.0;
      } else if (sellingPrice is num) {
        sellingPriceNum = sellingPrice.toDouble();
      }
    }
    
    double mrpPriceNum = sellingPriceNum;
    if (mrpPrice != null) {
      if (mrpPrice is String) {
        mrpPriceNum = double.tryParse(mrpPrice) ?? sellingPriceNum;
      } else if (mrpPrice is num) {
        mrpPriceNum = mrpPrice.toDouble();
      } else {
        mrpPriceNum = sellingPriceNum;
      }
    }
    
    double discountPercentageNum = 0.0;
    if (discountPercentage != null) {
      if (discountPercentage is String) {
        discountPercentageNum = double.tryParse(discountPercentage) ?? 0.0;
      } else if (discountPercentage is num) {
        discountPercentageNum = discountPercentage.toDouble();
      }
    }

    final hasDiscount = discountPercentageNum > 0 && mrpPriceNum > sellingPriceNum;

    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Text(
          'â‚¹${sellingPriceNum.toStringAsFixed(2)}',
          style: GoogleFonts.poppins(
            fontSize: 28,
            fontWeight: FontWeight.bold,
            color: _tealColor,
          ),
        ),
        if (hasDiscount) ...[
          const SizedBox(width: 12),
          Text(
            'â‚¹${mrpPriceNum.toStringAsFixed(2)}',
            style: GoogleFonts.poppins(
              fontSize: 18,
              decoration: TextDecoration.lineThrough,
              color: Colors.grey.shade500,
            ),
          ),
          const SizedBox(width: 12),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Colors.red.shade100,
              borderRadius: BorderRadius.circular(6),
            ),
            child: Text(
              '${discountPercentageNum.toStringAsFixed(0)}% OFF',
              style: GoogleFonts.poppins(
                fontSize: 12,
                fontWeight: FontWeight.bold,
                color: Colors.red.shade700,
              ),
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildStockStatus() {
    final stockQuantity = _product!['stock_quantity'] ?? 0;
    final isInStock = stockQuantity > 0;
    
    // Only show stock status when stock is below 5
    if (stockQuantity >= 5) {
      return const SizedBox.shrink();
    }
    
    // Show alert message when stock is below 5
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: isInStock ? Colors.orange.shade100 : Colors.red.shade100,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: isInStock ? Colors.orange.shade300 : Colors.red.shade300,
          width: 1,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            isInStock ? Icons.warning_amber_rounded : Icons.cancel,
            size: 18,
            color: isInStock ? Colors.orange.shade700 : Colors.red.shade700,
          ),
          const SizedBox(width: 8),
          Text(
            isInStock ? 'Low Stock! Only $stockQuantity available' : 'Out of Stock',
            style: GoogleFonts.poppins(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: isInStock ? Colors.orange.shade700 : Colors.red.shade700,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDescriptionSection() {
    final description = _product!['description'] ?? 'No description available';
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: _tealLight.withOpacity(0.3),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: _tealColor.withOpacity(0.2)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.description_outlined, color: _tealColor, size: 20),
              const SizedBox(width: 8),
              Text(
                'Description',
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey.shade800,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            description,
            style: GoogleFonts.poppins(
              fontSize: 14,
              color: Colors.grey.shade700,
              height: 1.6,
              letterSpacing: 0.2,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSpecificationsSection() {
    String specificationsText = _product!['specifications'].toString();
    
    // Try to parse as JSON if it looks like JSON
    dynamic specsData;
    bool isMap = false;
    bool isList = false;
    
    try {
      if (specificationsText.trim().startsWith('{') || specificationsText.trim().startsWith('[')) {
        specsData = jsonDecode(specificationsText);
        isMap = specsData is Map<String, dynamic>;
        isList = specsData is List;
      }
    } catch (e) {
      // If not JSON, treat as plain text
      specsData = null;
    }

    // Build list of specification items
    List<String> specItems = [];
    
    if (isMap) {
      // If it's a map, format as "Key : Value"
      (specsData as Map<String, dynamic>).forEach((key, value) {
        final formattedKey = key.toString().replaceAll('_', ' ').trim();
        // Clean value - remove escape characters and backslashes
        String formattedValue = value.toString().trim();
        formattedValue = formattedValue.replaceAll('\\n', ' '); // Replace escaped newlines with space
        formattedValue = formattedValue.replaceAll('\\t', ' '); // Replace escaped tabs with space
        formattedValue = formattedValue.replaceAll('\\"', '"'); // Replace escaped double quotes
        formattedValue = formattedValue.replaceAll("\\'", "'"); // Replace escaped single quotes
        formattedValue = formattedValue.replaceAll('\\', ''); // Remove any remaining backslashes
        
        if (formattedKey.isNotEmpty && formattedValue.isNotEmpty) {
          // Format key with first letter uppercase for each word
          final formattedKeyTitle = formattedKey.split(' ').map((word) {
            if (word.isEmpty) return word;
            return word[0].toUpperCase() + word.substring(1).toLowerCase();
          }).join(' ');
          specItems.add('$formattedKeyTitle : $formattedValue');
        }
      });
    } else if (isList) {
      // If it's a list, use the values directly (each item should already be formatted)
      specItems = (specsData as List)
          .map((e) {
            String item = e.toString().trim();
            // Clean escape characters and backslashes
            item = item.replaceAll('\\n', ' '); // Replace escaped newlines with space
            item = item.replaceAll('\\t', ' '); // Replace escaped tabs with space
            item = item.replaceAll('\\"', '"'); // Replace escaped double quotes
            item = item.replaceAll("\\'", "'"); // Replace escaped single quotes
            item = item.replaceAll('\\', ''); // Remove any remaining backslashes
            return item;
          })
          .where((item) => item.isNotEmpty)
          .toList();
    } else {
      // If it's plain text, split by common separators
      specItems = _parseSpecificationsText(specificationsText);
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Title
          Text(
            'Specifications',
            style: GoogleFonts.poppins(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: Colors.grey.shade900,
            ),
          ),
          const SizedBox(height: 16),
          // Specification items with checkmarks and dividers
          ...specItems.asMap().entries.map((entry) {
            final index = entry.key;
            final item = entry.value;
            final isLast = index == specItems.length - 1;
            
            return Column(
              children: [
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Green checkmark icon
                    Icon(
                      Icons.check_circle,
                      color: Colors.green,
                      size: 20,
                    ),
                    const SizedBox(width: 12),
                    // Specification text
                    Expanded(
                      child: Text(
                        item,
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          fontWeight: FontWeight.normal,
                          color: Colors.grey.shade800,
                          height: 1.5,
                        ),
                        overflow: TextOverflow.visible,
                        softWrap: true,
                      ),
                    ),
                  ],
                ),
                // Divider line (not after last item)
                if (!isLast) ...[
                  const SizedBox(height: 12),
                  Divider(
                    color: Colors.grey.shade300,
                    height: 1,
                    thickness: 1,
                  ),
                  const SizedBox(height: 12),
                ],
              ],
            );
          }).toList(),
        ],
      ),
    );
  }

  List<String> _parseSpecificationsText(String text) {
    // Parse text into list items
    List<String> items = [];
    
    // Try splitting by newlines first
    if (text.contains('\n')) {
      items = text.split('\n')
          .map((line) => line.trim())
          .where((line) => line.isNotEmpty)
          .toList();
    } 
    // Try splitting by semicolons
    else if (text.contains(';')) {
      items = text.split(';')
          .map((item) => item.trim())
          .where((item) => item.isNotEmpty)
          .toList();
    }
    // Try splitting by pipes
    else if (text.contains('|')) {
      items = text.split('|')
          .map((item) => item.trim())
          .where((item) => item.isNotEmpty)
          .toList();
    }
    // Try splitting by commas (but only if it looks like a list, not a single sentence)
    else if (text.contains(',') && text.split(',').length > 2) {
      items = text.split(',')
          .map((item) => item.trim())
          .where((item) => item.isNotEmpty)
          .toList();
    }
    // Otherwise, return as single item
    else {
      items = [text.trim()];
    }
    
    // Clean up items - remove bullet points, dashes, escape characters, and extra formatting
    items = items.map((item) {
      item = item.trim();
      // Remove backslashes and escape characters first (order matters - escape sequences before backslash)
      item = item.replaceAll('\\n', ' '); // Replace escaped newlines with space
      item = item.replaceAll('\\t', ' '); // Replace escaped tabs with space
      item = item.replaceAll('\\"', '"'); // Replace escaped double quotes
      item = item.replaceAll("\\'", "'"); // Replace escaped single quotes
      item = item.replaceAll('\\', ''); // Remove any remaining backslashes
      
      // Remove bullet points and dashes at the start
      while (item.isNotEmpty && 
             (item.startsWith('â€¢') || item.startsWith('-') || item.startsWith('*') || item.startsWith('â—‹'))) {
        item = item.substring(1).trim();
      }
      // Remove any leading brackets or quotes
      while (item.isNotEmpty && 
             (item.startsWith('[') || item.startsWith('{') || item.startsWith('(') || 
              item.startsWith('"') || item.startsWith("'"))) {
        item = item.substring(1).trim();
      }
      // Remove any trailing brackets or quotes
      while (item.isNotEmpty && 
             (item.endsWith(']') || item.endsWith('}') || item.endsWith(')') || 
              item.endsWith('"') || item.endsWith("'"))) {
        item = item.substring(0, item.length - 1).trim();
      }
      return item;
    }).toList();
    
    return items.where((item) => item.isNotEmpty).toList();
  }

  String _formatSpecificationsText(String text) {
    // Format the text - replace common separators with line breaks
    String formatted = text
        .replaceAll('\\n', '\n')
        .replaceAll('; ', '\nâ€¢ ')
        .replaceAll(', ', '\nâ€¢ ')
        .replaceAll('|', '\nâ€¢ ');
    
    // Add bullet point if lines don't start with one
    if (!formatted.trim().startsWith('â€¢') && !formatted.trim().startsWith('-')) {
      List<String> lines = formatted.split('\n');
      lines = lines.map((line) {
        line = line.trim();
        if (line.isNotEmpty && !line.startsWith('â€¢') && !line.startsWith('-')) {
          return 'â€¢ $line';
        }
        return line;
      }).toList();
      formatted = lines.join('\n');
    }
    
    return formatted;
  }

  Widget _buildAdditionalDetails() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.info_outline, color: _tealColor, size: 20),
              const SizedBox(width: 8),
              Text(
                'Product Information',
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey.shade800,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          _buildInfoRow('Unit', _product!['unit']),
          _buildInfoRow('Size', _product!['size']),
          _buildInfoRow('Weight', _product!['weight']),
          _buildInfoRow('Dimensions', _product!['dimensions']),
          _buildInfoRow('Color', _product!['color']),
          _buildInfoRow('Material', _product!['material']),
          _buildInfoRow('SKU', _product!['sku'] ?? _product!['sku_code']),
          _buildInfoRow('HSN Code', _product!['hsn_code']),
          _buildInfoRow('Barcode', _product!['barcode']),
          if (_product!['tax_rate'] != null) ...[
            Builder(
              builder: (context) {
              final taxRate = _product!['tax_rate'];
              final taxRateNum = taxRate is String 
                  ? double.tryParse(taxRate) ?? 0.0 
                  : (taxRate is num ? taxRate.toDouble() : 0.0);
              if (taxRateNum > 0) {
                return _buildInfoRow('Tax Rate', '${taxRateNum.toStringAsFixed(2)}% (${_product!['tax_type'] ?? 'Inclusive'})');
              }
                return const SizedBox.shrink();
              },
            ),
          ],
          if (_product!['expiry_date'] != null && _product!['expiry_date'].toString().isNotEmpty)
            _buildInfoRow('Expiry Date', _product!['expiry_date'].toString()),
          if (_product!['variant_name'] != null && _product!['variant_name'].toString().isNotEmpty)
            _buildInfoRow('Variant', _product!['variant_name'].toString()),
        ],
      ),
    );
  }

  Widget _buildInfoRow(String label, dynamic value) {
    if (value == null || value.toString().isEmpty) return const SizedBox.shrink();
    return Padding(
      padding: const EdgeInsets.only(bottom: 14),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 120,
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: 13,
                fontWeight: FontWeight.w600,
                color: Colors.grey.shade700,
                letterSpacing: 0.2,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value.toString(),
              style: GoogleFonts.poppins(
                fontSize: 14,
                color: Colors.grey.shade800,
                fontWeight: FontWeight.w500,
                height: 1.4,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// Widget for service images with proxy fallback
class _ServiceImageWidget extends StatefulWidget {
  final List<String> imageUrls;
  final String serviceName;

  const _ServiceImageWidget({
    super.key,
    required this.imageUrls,
    required this.serviceName,
  });

  @override
  State<_ServiceImageWidget> createState() => _ServiceImageWidgetState();
}

class _ServiceImageWidgetState extends State<_ServiceImageWidget> {
  int _currentImageIndex = 0;
  // For web, use proxy first (CORS blocks direct URLs). For mobile, try primary first.
  int _currentUrlIndex = kIsWeb ? 2 : 0; // 0 = primary URL, 1 = fallback URL, 2 = proxy
  bool _hasError = false;

  String _getFallbackUrl(String originalUrl) {
    // Convert Hostinger file server URLs to regular domain (since file server is failing)
    if (originalUrl.contains('srv1881-files.hstgr.io')) {
      final filename = originalUrl.split('/').last.split('?').first.split('#').first;
      return 'https://superdailys.com/storage/services/' + filename;
    }
    // If already using regular domain, try Hostinger file server as fallback
    if (originalUrl.contains('superdailys.com/storage/services/')) {
      final filename = originalUrl.split('/').last.split('?').first.split('#').first;
      return 'https://srv1881-files.hstgr.io/4663f5e73332121d/files/public_html/public/storage/services/' + filename;
    }
    return originalUrl;
  }

  String _getProxiedUrl(String url) {
    final encodedUrl = Uri.encodeComponent(url);
    return 'https://superdailys.com/superdailyapp/proxy_image.php?url=$encodedUrl';
  }

  String _getCurrentImageUrl() {
    if (_currentImageIndex >= widget.imageUrls.length) return '';
    final baseUrl = widget.imageUrls[_currentImageIndex];
    
    // Try primary URL first (might work if CORS is configured), then fallback, then proxy
    // 0 = primary URL (from API) - try first
    if (_currentUrlIndex == 0) {
      return baseUrl;
    }
    // 1 = fallback URL (alternative server)
    if (_currentUrlIndex == 1) {
      return _getFallbackUrl(baseUrl);
    }
    // 2 = proxy (fallback if direct URLs fail)
    if (_currentUrlIndex == 2) {
      return _getProxiedUrl(baseUrl);
    }
    return baseUrl;
  }

  @override
  Widget build(BuildContext context) {
    if (_hasError || _currentImageIndex >= widget.imageUrls.length) {
      // All images failed or no images
      return Container(
        color: const Color(0xFFE0F2F1),
        child: Icon(Icons.room_service, color: Colors.grey.shade400, size: 40),
      );
    }

    final imageUrl = _getCurrentImageUrl();
    if (imageUrl.isEmpty) {
      return Container(
        color: const Color(0xFFE0F2F1),
        child: Icon(Icons.room_service, color: Colors.grey.shade400, size: 40),
      );
    }

    final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
    debugPrint('ðŸ–¼ï¸ Service - Trying to load image [${_currentImageIndex + 1}/${widget.imageUrls.length}] ($urlType) for "${widget.serviceName}": $imageUrl');

    return CachedNetworkImage(
      key: ValueKey('${imageUrl}_${_currentUrlIndex}_${_currentImageIndex}'), // Force rebuild on URL change
      imageUrl: imageUrl,
      fit: BoxFit.cover,
      maxWidthDiskCache: 1000,
      maxHeightDiskCache: 1000,
      cacheKey: '${imageUrl}_${_currentUrlIndex}_${_currentImageIndex}', // Unique cache key per URL/fallback/image
      httpHeaders: {
        'Accept': 'image/*',
      },
      placeholder: (context, url) => Container(
        color: const Color(0xFFE0F2F1),
        child: const Center(
          child: CircularProgressIndicator(
            strokeWidth: 2,
            valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
          ),
        ),
      ),
      fadeInDuration: const Duration(milliseconds: 200),
      fadeOutDuration: const Duration(milliseconds: 100),
      errorWidget: (context, url, error) {
        final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
        debugPrint('âŒ Service - Image failed to load [${_currentImageIndex + 1}/${widget.imageUrls.length}] ($urlType) for "${widget.serviceName}": $url');
        debugPrint('   Error type: ${error.runtimeType}');
        debugPrint('   Error: $error');
        
        // Add delay before retrying to avoid rapid state changes
        Future.delayed(const Duration(milliseconds: 300), () {
          if (!mounted) return;
          
          // Try fallback URL if primary failed
          if (_currentUrlIndex == 0) {
            setState(() {
              _currentUrlIndex = 1; // Try fallback URL
            });
            return;
          }
          
          // Try proxy if fallback also failed
          if (_currentUrlIndex == 1) {
            setState(() {
              _currentUrlIndex = 2; // Try proxy
            });
            return;
          }
          
          // All URLs failed for this image, try next image if available
          if (_currentImageIndex < widget.imageUrls.length - 1) {
            setState(() {
              _currentImageIndex++;
              _currentUrlIndex = 0; // Reset to try primary first
            });
            return;
          }
          
          // No more images to try
          setState(() {
            _hasError = true;
          });
        });
        
        // Show loading indicator while retrying
        return Container(
          color: const Color(0xFFE0F2F1),
          child: const Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
              valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
            ),
          ),
        );
      },
    );
  }
}

// Widget for booking images with fallback (direct URL first, then proxy)
class _BookingImageWidget extends StatefulWidget {
  final String imageUrl;
  final double? width;
  final double? height;
  final Widget placeholder;

  const _BookingImageWidget({
    required this.imageUrl,
    this.width,
    this.height,
    required this.placeholder,
  });

  @override
  State<_BookingImageWidget> createState() => _BookingImageWidgetState();
}

class _BookingImageWidgetState extends State<_BookingImageWidget> {
  // For web, use proxy first (CORS blocks direct URLs). For mobile, try primary first.
  int _currentUrlIndex = kIsWeb ? 2 : 0; // 0 = primary URL, 1 = fallback URL, 2 = proxy
  bool _hasError = false;

  String _getFallbackUrl(String originalUrl) {
    // Convert Hostinger file server URLs to regular domain (since file server is failing)
    if (originalUrl.contains('srv1881-files.hstgr.io')) {
      final filename = originalUrl.split('/').last.split('?').first.split('#').first;
      return 'https://superdailys.com/storage/services/' + filename;
    }
    // If already using regular domain, try Hostinger file server as fallback
    if (originalUrl.contains('superdailys.com/storage/services/')) {
      final filename = originalUrl.split('/').last.split('?').first.split('#').first;
      return 'https://srv1881-files.hstgr.io/4663f5e73332121d/files/public_html/public/storage/services/' + filename;
    }
    return originalUrl;
  }

  String _getProxiedUrl(String url) {
    final encodedUrl = Uri.encodeComponent(url);
    return 'https://superdailys.com/superdailyapp/proxy_image.php?url=$encodedUrl';
  }

  String _getCurrentImageUrl() {
    // Try primary URL first (might work if CORS is configured), then fallback, then proxy
    // 0 = primary URL (from API) - try first
    if (_currentUrlIndex == 0) {
      return widget.imageUrl;
    }
    // 1 = fallback URL (alternative server)
    if (_currentUrlIndex == 1) {
      return _getFallbackUrl(widget.imageUrl);
    }
    // 2 = proxy (fallback if direct URLs fail)
    if (_currentUrlIndex == 2) {
      return _getProxiedUrl(widget.imageUrl);
    }
    return widget.imageUrl;
  }

  @override
  Widget build(BuildContext context) {
    if (_hasError) {
      return widget.placeholder;
    }

    final imageUrl = _getCurrentImageUrl();
    if (imageUrl.isEmpty) {
      return widget.placeholder;
    }

    final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
    debugPrint('ðŸ–¼ï¸ Booking - Trying to load image ($urlType): $imageUrl');

    return CachedNetworkImage(
      key: ValueKey('${imageUrl}_${_currentUrlIndex}'), // Force rebuild on URL change
      imageUrl: imageUrl,
      width: widget.width,
      height: widget.height,
      fit: BoxFit.cover,
      maxWidthDiskCache: 1000,
      maxHeightDiskCache: 1000,
      cacheKey: '${imageUrl}_${_currentUrlIndex}', // Unique cache key per URL/fallback
      httpHeaders: {
        'Accept': 'image/*',
      },
      placeholder: (context, url) => widget.placeholder,
      fadeInDuration: const Duration(milliseconds: 200),
      fadeOutDuration: const Duration(milliseconds: 100),
      errorWidget: (context, url, error) {
        final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
        debugPrint('âŒ Booking - Image failed to load ($urlType): $url');
        debugPrint('   Error type: ${error.runtimeType}');
        debugPrint('   Error: $error');
        
        // Add delay before retrying to avoid rapid state changes
        Future.delayed(const Duration(milliseconds: 300), () {
          if (!mounted) return;
          
          // Try fallback URL if primary failed
          if (_currentUrlIndex == 0) {
            setState(() {
              _currentUrlIndex = 1; // Try fallback URL
            });
            return;
          }
          
          // Try proxy if fallback also failed
          if (_currentUrlIndex == 1) {
            setState(() {
              _currentUrlIndex = 2; // Try proxy
            });
            return;
          }
          
          // All URLs failed
          setState(() {
            _hasError = true;
          });
        });
        
        // Show placeholder while retrying
        return widget.placeholder;
      },
    );
  }
}

// Widget to try multiple images in sequence if one fails
class _ProductImageWidget extends StatefulWidget {
  final List<String> imageUrls;
  final String productName;

  const _ProductImageWidget({
    required this.imageUrls,
    required this.productName,
  });

  @override
  State<_ProductImageWidget> createState() => _ProductImageWidgetState();
}

class _ProductImageWidgetState extends State<_ProductImageWidget> {
  int _currentImageIndex = 0;
  // For web, use proxy first (CORS blocks direct URLs). For mobile, try direct first.
  int _currentFallbackIndex = kIsWeb ? 1 : 0; // 0 = direct, 1 = proxy
  bool _hasError = false;

  String _getProxiedUrl(String url) {
    final encodedUrl = Uri.encodeComponent(url);
    // Try proxy - adjust path if your proxy_image.php is in a different location
    return 'https://superdailys.com/superdailyapp/proxy_image.php?url=$encodedUrl';
  }

  String _getCurrentImageUrl() {
    if (_currentImageIndex >= widget.imageUrls.length) return '';
    final baseUrl = widget.imageUrls[_currentImageIndex];
    // For web, use proxy first (CORS issues). For mobile, try direct first.
    // 0 = direct URL
    if (_currentFallbackIndex == 0) {
      return baseUrl;
    }
    // 1 = proxy
    if (_currentFallbackIndex == 1) {
      return _getProxiedUrl(baseUrl);
    }
    return baseUrl;
  }

  @override
  Widget build(BuildContext context) {
    if (_hasError || _currentImageIndex >= widget.imageUrls.length) {
      // All images failed or no images
      return Container(
        width: double.infinity,
        height: double.infinity,
        color: const Color(0xFFE0F2F1),
        child: Icon(Icons.image_not_supported, color: Colors.grey.shade400, size: 32),
      );
    }

    final imageUrl = _getCurrentImageUrl();
    if (imageUrl.isEmpty) {
      return Container(
        width: double.infinity,
        height: double.infinity,
        color: const Color(0xFFE0F2F1),
        child: Icon(Icons.image_not_supported, color: Colors.grey.shade400, size: 32),
      );
    }

    final urlType = ['direct', 'proxy'][_currentFallbackIndex];
    debugPrint('ðŸ–¼ï¸ Product - Trying to load image [${_currentImageIndex + 1}/${widget.imageUrls.length}] ($urlType) for "${widget.productName}": $imageUrl');

    return CachedNetworkImage(
      key: ValueKey('${imageUrl}_${_currentFallbackIndex}_${_currentImageIndex}'),
      imageUrl: imageUrl,
      fit: BoxFit.cover,
      width: double.infinity,
      height: double.infinity,
      maxWidthDiskCache: 1000,
      maxHeightDiskCache: 1000,
      cacheKey: '${imageUrl}_${_currentFallbackIndex}_${_currentImageIndex}',
      httpHeaders: {
        'Accept': 'image/*',
      },
      placeholder: (context, url) => Container(
        width: double.infinity,
        height: double.infinity,
        color: const Color(0xFFE0F2F1),
        child: const Center(
          child: CircularProgressIndicator(
            strokeWidth: 2,
            valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
          ),
        ),
      ),
      errorWidget: (context, url, error) {
        final urlType = ['direct', 'proxy'][_currentFallbackIndex];
        debugPrint('âŒ Image failed to load [${_currentImageIndex + 1}/${widget.imageUrls.length}] ($urlType) for "${widget.productName}": $url');
        debugPrint('   Error type: ${error.runtimeType}');
        debugPrint('   Error: $error');
        
        // If direct URL failed (mobile), try proxy. If proxy failed (web), try direct.
        if (_currentFallbackIndex == 0) {
          // Direct failed, try proxy
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _currentFallbackIndex = 1; // Try proxy
              });
            }
          });
          return Container(
            width: double.infinity,
            height: double.infinity,
            color: const Color(0xFFE0F2F1),
            child: const Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            ),
          );
        }
        
        // Direct URL also failed, try next image if available
        if (_currentImageIndex < widget.imageUrls.length - 1) {
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _currentImageIndex++;
                _currentFallbackIndex = 0; // Reset to try direct first for next image
              });
            }
          });
          return Container(
            width: double.infinity,
            height: double.infinity,
            color: const Color(0xFFE0F2F1),
            child: const Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            ),
          );
        } else {
          // No more images to try
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _hasError = true;
              });
            }
          });
          return Container(
            color: const Color(0xFFE0F2F1),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.image_not_supported, color: Colors.grey.shade400, size: 32),
                const SizedBox(height: 4),
                Text(
                  'No image',
                  style: GoogleFonts.poppins(
                    fontSize: 9,
                    color: Colors.grey.shade500,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          );
        }
      },
    );
  }
}

// Notification Service for handling push notifications
class NotificationService {
  static final FlutterLocalNotificationsPlugin _notifications = FlutterLocalNotificationsPlugin();
  static final NotificationService _instance = NotificationService._internal();
  static const String _backendBaseUrl = 'https://superdailys.com/superdailyapp/';
  
  factory NotificationService() => _instance;
  NotificationService._internal();

  // Track shown notification IDs to avoid duplicates
  final Set<int> _shownNotificationIds = {};

  // Initialize notification service
  Future<void> initialize() async {
    if (kIsWeb) return; // Notifications not supported on web

    const AndroidInitializationSettings androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const DarwinInitializationSettings iosSettings = DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );

    const InitializationSettings initSettings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );

    await _notifications.initialize(
      initSettings,
      onDidReceiveNotificationResponse: _onNotificationTapped,
    );

    // Request permissions
    await _requestPermissions();
  }

  Future<void> _requestPermissions() async {
    if (kIsWeb) return;

    final androidDetails = const AndroidNotificationDetails(
      'push_notifications',
      'Push Notifications',
      channelDescription: 'Notifications for promotions, orders, and updates',
      importance: Importance.high,
      priority: Priority.high,
      showWhen: true,
    );

    final iosDetails = const DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
    );

    final details = NotificationDetails(android: androidDetails, iOS: iosDetails);
    
    // Request permission
    await _notifications
        .resolvePlatformSpecificImplementation<IOSFlutterLocalNotificationsPlugin>()
        ?.requestPermissions(
          alert: true,
          badge: true,
          sound: true,
        );
  }

  // Handle notification tap
  void _onNotificationTapped(NotificationResponse response) {
    // Handle navigation based on notification payload
    debugPrint('Notification tapped: ${response.payload}');
  }

  // Check and display new push notifications
  Future<void> checkAndShowNotifications(int? userId) async {
    if (kIsWeb || userId == null) return;

    try {
      final response = await http.get(
        Uri.parse('$_backendBaseUrl/get_push_notifications.php?user_id=$userId'),
        headers: {'Content-Type': 'application/json'},
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final notifications = data['notifications'] as List<dynamic>;
          
          for (var notification in notifications) {
            final notificationId = notification['id'] as int;
            
            // Only show if not already shown
            if (!_shownNotificationIds.contains(notificationId)) {
              await _showNotification(notification);
              _shownNotificationIds.add(notificationId);
            }
          }
        }
      }
    } catch (e) {
      debugPrint('Error checking notifications: $e');
    }
  }

  // Show a single notification
  Future<void> _showNotification(Map<String, dynamic> notification) async {
    if (kIsWeb) return;

    final title = notification['title'] ?? 'Super Daily';
    final body = notification['body'] ?? '';
    final icon = notification['icon'];
    final notificationId = notification['id'] as int;
    final url = notification['url'];

    // Download icon if available
    String? iconUrl;
    if (icon != null && icon.toString().isNotEmpty) {
      iconUrl = icon.toString();
      // If it's a relative path, make it absolute
      if (!iconUrl.startsWith('http://') && !iconUrl.startsWith('https://')) {
        iconUrl = 'https://superdailys.com/storage/$iconUrl';
      }
    }

    // Build Android notification details with icon support
    AndroidNotificationDetails androidDetails;
    if (iconUrl != null && iconUrl.isNotEmpty) {
      try {
        // Download the icon
        final iconResponse = await http.get(Uri.parse(iconUrl));
        if (iconResponse.statusCode == 200) {
          final bytes = iconResponse.bodyBytes;
          final largeIcon = ByteArrayAndroidBitmap(bytes);
          
          androidDetails = AndroidNotificationDetails(
            'push_notifications',
            'Push Notifications',
            channelDescription: 'Notifications for promotions, orders, and updates',
            importance: Importance.high,
            priority: Priority.high,
            showWhen: true,
            largeIcon: largeIcon,
            styleInformation: BigPictureStyleInformation(
              largeIcon,
              contentTitle: title,
              summaryText: body,
            ),
          );
        } else {
          // Fallback to default icon
          androidDetails = const AndroidNotificationDetails(
            'push_notifications',
            'Push Notifications',
            channelDescription: 'Notifications for promotions, orders, and updates',
            importance: Importance.high,
            priority: Priority.high,
            showWhen: true,
            largeIcon: DrawableResourceAndroidBitmap('@mipmap/ic_launcher'),
          );
        }
      } catch (e) {
        debugPrint('Error loading notification icon: $e');
        // Fallback to default icon
        androidDetails = const AndroidNotificationDetails(
          'push_notifications',
          'Push Notifications',
          channelDescription: 'Notifications for promotions, orders, and updates',
          importance: Importance.high,
          priority: Priority.high,
          showWhen: true,
          largeIcon: DrawableResourceAndroidBitmap('@mipmap/ic_launcher'),
        );
      }
    } else {
      // No icon provided, use default
      androidDetails = const AndroidNotificationDetails(
        'push_notifications',
        'Push Notifications',
        channelDescription: 'Notifications for promotions, orders, and updates',
        importance: Importance.high,
        priority: Priority.high,
        showWhen: true,
        largeIcon: DrawableResourceAndroidBitmap('@mipmap/ic_launcher'),
      );
    }

    const DarwinNotificationDetails iosDetails = DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
    );

    final details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );

    await _notifications.show(
      notificationId,
      title,
      body,
      details,
      payload: url ?? '',
    );
  }

  // Clear shown notification IDs (useful for testing)
  void clearShownNotifications() {
    _shownNotificationIds.clear();
  }
}

class HomeScreen extends StatefulWidget {
  final Map<String, dynamic>? userData;

  const HomeScreen({super.key, this.userData});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  int _currentIndex = 0;
  List<dynamic> _featuredProducts = [];
  bool _isLoadingProducts = true;
  List<dynamic> _allProducts = [];
  bool _isLoadingAllProducts = true;
  List<dynamic> _categories = [];
  bool _isLoadingCategories = true;
  List<dynamic> _oneTimeServices = [];
  bool _isLoadingServices = true;
  List<dynamic> _monthlySubscriptionServices = [];
  bool _isLoadingMonthlyServices = true;
  List<dynamic> _myBookings = [];
  bool _isLoadingBookings = true;
  List<dynamic> _myOrders = [];
  bool _isLoadingOrders = true;
  int _favoriteProductCount = 0;
  int _favoriteServiceCount = 0;
  late PageController _carouselController;
  int _currentCarouselIndex = 0;
  final TextEditingController _bookingSearchController = TextEditingController();
  String _bookingFilter = 'all'; // 'all', 'monthly', 'onetime'
  
  // Cart management
  List<Map<String, dynamic>> _cartItems = [];
  bool _showCartSuccessMessage = false;
  
  static const Color _tealColor = Color(0xFF00BFA5);
  static const Color _tealLight = Color(0xFFE0F2F1);
  static const Color _tealLighter = Color(0xFFF0F9F8);
  static const Color _profileSectionBg = Color(0xFFE6F7F7);
  static const Color _priceDarkBlue = Color(0xFF0D47A1);
  static const String _backendBaseUrl = 'https://superdailys.com/superdailyapp/';
  
  // User data - loaded from SharedPreferences to ensure it's always available
  Map<String, dynamic>? _userData;
  
  // Track failed profile image URLs to prevent repeated error logs
  static final Set<String> _failedProfileImageUrls = {};
  
  // Cache buster for profile images - updated when image is uploaded
  String? _profileImageCacheBuster;
  
  // Favorite management functions
  Future<bool> _isFavorite(String type, String id) async {
    // Only show favorites if user is logged in
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    if (!isLoggedIn) return false;
    
    final key = type == 'product' ? 'favorite_products' : 'favorite_services';
    final favorites = prefs.getStringList(key) ?? [];
    return favorites.contains(id);
  }
  
  Future<void> _toggleFavorite(String type, String id) async {
    // Only allow favoriting if user is logged in
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    
    if (!isLoggedIn) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please login to add favorites'),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 2),
        ),
      );
      return;
    }
    
    final key = type == 'product' ? 'favorite_products' : 'favorite_services';
    final favorites = prefs.getStringList(key) ?? [];
    
    if (favorites.contains(id)) {
      favorites.remove(id);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Removed from favorites'),
          duration: Duration(seconds: 1),
        ),
      );
    } else {
      favorites.add(id);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Added to favorites'),
          duration: Duration(seconds: 1),
        ),
      );
    }
    await prefs.setStringList(key, favorites);
    if (!mounted) return;
    setState(() {
      if (type == 'product') {
        _favoriteProductCount = favorites.length;
      } else {
        _favoriteServiceCount = favorites.length;
      }
    });
  }
  
  // Cart management functions
  // Helper to normalize product ID to int for comparison
  int _normalizeProductId(dynamic id) {
    if (id == null) return 0;
    if (id is int) return id;
    if (id is String) {
      final parsed = int.tryParse(id);
      return parsed ?? 0;
    }
    if (id is num) return id.toInt();
    return 0;
  }
  
  int _getCartItemQuantity(dynamic productId) {
    final normalizedId = _normalizeProductId(productId);
    final item = _cartItems.firstWhere(
      (item) {
        final itemId = _normalizeProductId(item['product']['id']);
        return itemId == normalizedId;
      },
      orElse: () => {'quantity': 0},
    );
    return item['quantity'] ?? 0;
  }
  
  void _addToCart(Map<String, dynamic> product) {
    final productId = product['id'];
    if (productId == null) return;
    
    final normalizedId = _normalizeProductId(productId);
    final existingIndex = _cartItems.indexWhere(
      (item) {
        final itemId = _normalizeProductId(item['product']['id']);
        return itemId == normalizedId;
      },
    );
    
    if (existingIndex >= 0) {
      // Product already in cart, increment quantity
      final currentQuantity = _cartItems[existingIndex]['quantity'] ?? 1;
      final stockQuantity = parseInteger(product['stock_quantity'] ?? 0);
      
      if (currentQuantity < stockQuantity) {
        setState(() {
          _cartItems[existingIndex]['quantity'] = currentQuantity + 1;
          _showCartSuccessMessage = true;
        });
        // Hide success message after 3 seconds
        Future.delayed(const Duration(seconds: 3), () {
          if (mounted) {
            setState(() {
              _showCartSuccessMessage = false;
            });
          }
        });
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Cannot add more. Stock limit reached.'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } else {
      // New product, add to cart
      setState(() {
        _cartItems.add({
          'product': product,
          'quantity': 1,
        });
        _showCartSuccessMessage = true;
      });
      // Hide success message after 3 seconds
      Future.delayed(const Duration(seconds: 3), () {
        if (mounted) {
          setState(() {
            _showCartSuccessMessage = false;
          });
        }
      });
    }
  }
  
  void _removeFromCart(int productId) {
    final normalizedId = _normalizeProductId(productId);
    setState(() {
      _cartItems.removeWhere((item) {
        final itemId = _normalizeProductId(item['product']['id']);
        return itemId == normalizedId;
      });
    });
  }
  
  void _updateCartQuantity(int productId, int newQuantity) {
    if (newQuantity <= 0) {
      _removeFromCart(productId);
      return;
    }
    
    final normalizedId = _normalizeProductId(productId);
    final existingIndex = _cartItems.indexWhere(
      (item) {
        final itemId = _normalizeProductId(item['product']['id']);
        return itemId == normalizedId;
      },
    );
    
    if (existingIndex >= 0) {
      final product = _cartItems[existingIndex]['product'];
      final stockQuantity = parseInteger(product['stock_quantity'] ?? 0);
      
      if (newQuantity <= stockQuantity) {
        setState(() {
          _cartItems[existingIndex]['quantity'] = newQuantity;
        });
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Cannot add more. Stock limit reached.'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 2),
          ),
        );
      }
    }
  }
  
  void _clearCart() {
    setState(() {
      _cartItems.clear();
    });
  }
  
  double _getCartTotal() {
    double total = 0.0;
    for (var item in _cartItems) {
      final product = item['product'];
      final quantity = item['quantity'] ?? 1;
      final sellingPrice = product['selling_price'] ?? product['price'] ?? 0.0;
      final price = parseNumber(sellingPrice, 0.0);
      total += price * quantity;
    }
    return total;
  }
  
  int _getCartItemCount() {
    return _cartItems.fold<int>(0, (sum, item) {
      final quantity = item['quantity'] ?? 1;
      return sum + (quantity is int ? quantity : (quantity as num).toInt());
    });
  }
  
  // Helper function to safely parse numbers
  double parseNumber(dynamic value, [double defaultValue = 0.0]) {
    if (value == null) return defaultValue;
    if (value is double) return value.isNaN || value.isInfinite ? defaultValue : value;
    if (value is int) return value.toDouble();
    if (value is String) {
      final parsed = double.tryParse(value.trim());
      if (parsed != null && !parsed.isNaN && !parsed.isInfinite) return parsed;
    }
    return defaultValue;
  }
  
  // Helper function to safely parse integers
  int parseInteger(dynamic value, [int defaultValue = 0]) {
    if (value == null) return defaultValue;
    if (value is int) return value;
    if (value is double) return value.toInt();
    if (value is String) {
      final parsed = int.tryParse(value.trim());
      if (parsed != null) return parsed;
    }
    return defaultValue;
  }
  
  // Edit Profile Controllers
  final _editProfileFormKey = GlobalKey<FormState>();
  final _editFullNameController = TextEditingController();
  final _editEmailController = TextEditingController();
  final _editPhoneController = TextEditingController();
  final _editPasswordController = TextEditingController();
  final _editConfirmPasswordController = TextEditingController();
  final _editAddressController = TextEditingController();
  bool _obscureEditPassword = true;
  bool _obscureEditConfirmPassword = true;
  bool _isEditingProfile = false;
  XFile? _selectedProfileImage;
  Uint8List? _selectedProfileImageBytes;
  final ImagePicker _imagePicker = ImagePicker();

  ImageProvider? _getSelectedProfileImageProvider() {
    if (_selectedProfileImage == null) return null;
    if (_selectedProfileImageBytes == null) return null;
    return MemoryImage(_selectedProfileImageBytes!);
  }

  Future<http.MultipartFile> _prepareProfileImageMultipartFile() async {
    if (_selectedProfileImage == null) {
      throw StateError('No profile image selected');
    }

    final String fileName = _selectedProfileImage!.name.isNotEmpty
        ? _selectedProfileImage!.name
        : 'profile_${DateTime.now().millisecondsSinceEpoch}.jpg';

    if (kIsWeb || _selectedProfileImage!.path.isEmpty) {
      // On web / platforms without a file path, fall back to in-memory bytes
      final bytes = _selectedProfileImageBytes ?? await _selectedProfileImage!.readAsBytes();
      return http.MultipartFile.fromBytes(
        'profile_image',
        bytes,
        filename: fileName,
      );
    }

    return await http.MultipartFile.fromPath(
      'profile_image',
      _selectedProfileImage!.path,
      filename: fileName,
    );
  }

  String _resolveImageUrl(String raw) {
    if (raw.isEmpty) return raw;
    String p = raw.trim();
    // Normalize slashes
    p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
    
    // Already absolute URL starting with https://superdailys.com/storage/products/
    if (p.startsWith('https://superdailys.com/storage/products/')) {
      return p;
    }
    
    // Already absolute URL (any other URL)
    if (p.startsWith('http://') || p.startsWith('https://')) {
      // If it's a full URL but not from the storage/products path, try to extract filename
      if (!p.contains('/storage/products/')) {
        final filename = p.split('/').last.split('?').first.split('#').first;
        if (filename.isNotEmpty && filename.contains('.')) {
          return 'https://superdailys.com/storage/products/' + filename;
        }
      }
      return p;
    }
    
    // Extract just the filename from the path
    String filename = p.split('/').last.split('\\').last;
    // Remove query parameters and hash
    filename = filename.split('?').first.split('#').first;
    
    // If filename is empty or doesn't have extension, try to find it
    if (filename.isEmpty || !filename.contains('.')) {
      // Try to find filename in the path
      final parts = p.split('/');
      for (var part in parts.reversed) {
        if (part.contains('.') && part.length > 3) {
          filename = part.split('?').first.split('#').first;
          break;
        }
      }
    }
    
    // Build full URL with storage/products base
    if (filename.isNotEmpty && filename.contains('.')) {
      final url = 'https://superdailys.com/storage/products/' + filename;
      debugPrint('Resolved image URL: $url');
      return url;
    }
    
    // Fallback to old method
    // Remove leading ./ or ../
    while (p.startsWith('./') || p.startsWith('../')) {
      p = p.startsWith('./') ? p.substring(2) : p.substring(3);
    }
    // If path contains spdbackend in the middle (e.g., C:/xampp/htdocs/spdbackend/uploads/img.png)
    final spdIdx = p.indexOf('/spdbackend/');
    if (spdIdx != -1) {
      p = p.substring(spdIdx + '/spdbackend/'.length);
    }
    // If path contains htdocs/ or www/ folders, strip up to them
    for (final marker in ['/htdocs/', '/www/']) {
      final idx = p.indexOf(marker);
      if (idx != -1) {
        p = p.substring(idx + marker.length);
      }
    }
    // Ensure no leading slash duplication
    if (p.startsWith('/')) p = p.substring(1);
    final url = _backendBaseUrl + p;
    debugPrint('Resolved image URL (fallback): ' + url);
    return url;
  }

  Timer? _notificationCheckTimer;
  final NotificationService _notificationService = NotificationService();

  @override
  void initState() {
    super.initState();
    _carouselController = PageController(viewportFraction: 1.0);
    _loadUserData(); // Load user data from SharedPreferences
    _loadFavoriteCounts();
    _fetchFeaturedProducts();
    _fetchCategories();
    _fetchOneTimeServices();
    _fetchMonthlySubscriptionServices();
    _startCarouselTimer();
    // Initialize and start notification service
    _initializeNotifications();
    // Check and request push notification permission after a delay
    Future.delayed(const Duration(seconds: 2), () {
      _checkAndRequestPushNotificationPermission();
    });
    // Check for pending cart checkout after login
    _checkPendingCartCheckout();
  }

  // Check if user was redirected to login from cart checkout and restore cart
  Future<void> _checkPendingCartCheckout() async {
    final prefs = await SharedPreferences.getInstance();
    final pendingCartCheckout = prefs.getBool('pendingCartCheckout') ?? false;
    
    if (pendingCartCheckout) {
      // Retrieve stored cart items
      final pendingCartItemsJson = prefs.getString('pendingCartItems');
      await prefs.remove('pendingCartCheckout'); // Clear the pending cart checkout flag
      await prefs.remove('pendingCartItems'); // Clear the stored cart items
      
      if (pendingCartItemsJson != null && mounted) {
        final pendingCartItems = jsonDecode(pendingCartItemsJson) as List;
        // Restore cart items
        setState(() {
          _cartItems = List<Map<String, dynamic>>.from(
            pendingCartItems.map((item) => Map<String, dynamic>.from(item))
          );
        });
        // Navigate to cart page after a short delay to ensure HomeScreen is built
        Future.delayed(const Duration(milliseconds: 300), () {
          if (mounted) {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ShoppingCartPage(
                  cartItems: _cartItems,
                  onUpdateQuantity: _updateCartQuantity,
                  onRemoveItem: _removeFromCart,
                  onClearCart: _clearCart,
                  onCartUpdated: () {
                    setState(() {});
                  },
                ),
              ),
            );
          }
        });
      }
    }
  }

  @override
  void dispose() {
    _notificationCheckTimer?.cancel();
    _carouselController.dispose();
    super.dispose();
  }

  // Initialize notification service and start periodic checking
  Future<void> _initializeNotifications() async {
    if (kIsWeb) return;

    // Initialize notification service
    await _notificationService.initialize();

    // Start periodic notification checking (every 30 seconds)
    _notificationCheckTimer = Timer.periodic(const Duration(seconds: 30), (timer) {
      if (_userData != null && _userData!['id'] != null) {
        _notificationService.checkAndShowNotifications(_userData!['id']);
      }
    });

    // Check immediately after a short delay
    Future.delayed(const Duration(seconds: 5), () {
      if (_userData != null && _userData!['id'] != null) {
        _notificationService.checkAndShowNotifications(_userData!['id']);
      }
    });
  }

  // Load user data from SharedPreferences to ensure it's always available
  // This method ALWAYS prioritizes SharedPreferences when user is logged in
  Future<void> _loadUserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
      
      if (isLoggedIn) {
        // User is logged in - ALWAYS load from SharedPreferences
        final userDataJson = prefs.getString('userData');
        if (userDataJson != null) {
          setState(() {
            _userData = jsonDecode(userDataJson);
          });
          _loadFavoriteCounts();
          _fetchMyOrders();
          // Start checking notifications once user data is loaded
          if (!kIsWeb && _userData != null && _userData!['id'] != null) {
            Future.delayed(const Duration(seconds: 3), () {
              _notificationService.checkAndShowNotifications(_userData!['id']);
            });
          }
          return; // Exit early - we have userData from SharedPreferences
        }
      }
      
      // If not logged in or no userData in SharedPreferences, use widget.userData as fallback
      if (widget.userData != null) {
        setState(() {
          _userData = widget.userData;
        });
        _loadFavoriteCounts();
        _fetchMyOrders();
        // Start checking notifications once user data is loaded
        if (!kIsWeb && _userData != null && _userData!['id'] != null) {
          Future.delayed(const Duration(seconds: 3), () {
            _notificationService.checkAndShowNotifications(_userData!['id']);
          });
        }
      } else {
        // Clear userData if not logged in and no widget.userData
        setState(() {
          _userData = null;
        });
      }
    } catch (e) {
      debugPrint('Error loading user data: $e');
      // Fallback to widget.userData if available
      if (widget.userData != null) {
        setState(() {
          _userData = widget.userData;
        });
        _loadFavoriteCounts();
        _fetchMyOrders();
        // Start checking notifications once user data is loaded
        if (!kIsWeb && _userData != null && _userData!['id'] != null) {
          Future.delayed(const Duration(seconds: 3), () {
            _notificationService.checkAndShowNotifications(_userData!['id']);
          });
        }
      }
    }
  }

  Future<void> _loadFavoriteCounts() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final favoriteProducts = prefs.getStringList('favorite_products') ?? [];
      final favoriteServices = prefs.getStringList('favorite_services') ?? [];
      if (!mounted) return;
      setState(() {
        _favoriteProductCount = favoriteProducts.length;
        _favoriteServiceCount = favoriteServices.length;
      });
    } catch (e) {
      debugPrint('Error loading favorite counts: $e');
    }
  }

  // Check and request push notification permission
  Future<void> _checkAndRequestPushNotificationPermission() async {
    // Only show if user is logged in
    if (_userData == null || _userData!['id'] == null) {
      return;
    }

    final prefs = await SharedPreferences.getInstance();
    final hasAskedPermission = prefs.getBool('push_notification_permission_asked') ?? false;
    
    // If we've already asked, don't ask again
    if (hasAskedPermission) {
      return;
    }

    // Show permission dialog
    if (mounted) {
      final shouldRequest = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(
            'Allow Notifications',
            style: GoogleFonts.poppins(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          content: Text(
            'Stay updated with order status, promotions, and important updates. Allow notifications to receive real-time alerts.',
            style: GoogleFonts.poppins(
              fontSize: 14,
              color: Colors.grey.shade700,
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop(false);
              },
              child: Text(
                'Not Now',
                style: GoogleFonts.poppins(
                  color: Colors.grey.shade600,
                ),
              ),
            ),
            ElevatedButton(
              onPressed: () {
                Navigator.of(context).pop(true);
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: _tealColor,
                foregroundColor: Colors.white,
              ),
              child: Text(
                'Allow',
                style: GoogleFonts.poppins(
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
      );

      // Mark that we've asked for permission
      await prefs.setBool('push_notification_permission_asked', true);

      if (shouldRequest == true && mounted) {
        await _requestPushNotificationPermission();
      }
    }
  }

  // Request push notification permission and save subscription
  Future<void> _requestPushNotificationPermission() async {
    if (!kIsWeb) {
      // For mobile platforms, you would use firebase_messaging or similar
      return;
    }

    try {
      // For web, we'll use JavaScript interop to access the browser's Push API
      // Since we can't directly use JavaScript in Flutter, we'll save a basic subscription
      // In a real implementation, you'd need to use a JavaScript bridge or web_push package
      
      // For now, we'll create a basic subscription object
      // In production, you'd get this from the browser's Push API
      final subscriptionData = {
        'endpoint': 'web_push_endpoint_placeholder', // This would come from the browser
        'keys': {
          'p256dh': 'p256dh_key_placeholder',
          'auth': 'auth_key_placeholder',
        },
      };

      // Save subscription to backend
      await _savePushSubscription(subscriptionData);
    } catch (e) {
      debugPrint('Error requesting push notification permission: $e');
    }
  }

  // Save push subscription to backend
  Future<void> _savePushSubscription(Map<String, dynamic> subscriptionData) async {
    if (_userData == null || _userData!['id'] == null) {
      return;
    }

    try {
      final response = await http.post(
        Uri.parse('${_backendBaseUrl}save_push_subscription.php'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'user_id': _userData!['id'],
          'endpoint': subscriptionData['endpoint'],
          'keys': subscriptionData['keys'],
        }),
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            debugPrint('Push subscription saved successfully');
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Notifications enabled successfully'),
                duration: Duration(seconds: 2),
                backgroundColor: Colors.green,
              ),
            );
          }
        }
      }
    } catch (e) {
      debugPrint('Error saving push subscription: $e');
    }
  }

  void _startCarouselTimer() {
    // Auto-switch carousel every 3 seconds
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        _currentCarouselIndex = (_currentCarouselIndex + 1) % 4;
        _carouselController.animateToPage(
          _currentCarouselIndex,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
        );
        _startCarouselTimer();
      }
    });
  }

  Future<void> _fetchFeaturedProducts() async {
    try {
      const String apiUrl = 'https://superdailys.com/superdailyapp/get_all_products.php';
      
      print('ðŸŒ Fetching products from: $apiUrl');
      
      final response = await http.get(
        Uri.parse(apiUrl),
        // Don't set Content-Type for GET requests to avoid CORS issues
      );

      print('ðŸ“¡ Response Status Code: ${response.statusCode}');
      print('ðŸ“¡ Response Headers: ${response.headers}');

      if (mounted) {
        if (response.statusCode == 200) {
          try {
          final data = jsonDecode(response.body);
            print('âœ… JSON decoded successfully');
            print('ðŸ“‹ Response keys: ${data.keys.toList()}');
            
          if (data['success'] == true) {
            final products = data['products'] ?? [];
              print('âœ… Fetched ${products.length} products'); // Debug
            print('ðŸ“Š Product count from API: ${data['count']}'); // Debug
              print('ðŸ“Š Total in DB: ${data['total_in_db'] ?? 'N/A'}'); // Debug
              
              print('ðŸ“¦ Products array length: ${products.length}'); // Debug
              if (products.isNotEmpty) {
                print('âœ… First product sample: ${products[0]}'); // Debug
              } else {
                print('âš ï¸ Products array is empty even though success=true');
                print('ðŸ“‹ Full API Response: ${response.body}');
            }
            
            setState(() {
              _featuredProducts = products;
              _isLoadingProducts = false;
            });
          } else {
            print('âŒ API returned success=false: ${data['message']}'); // Debug
              print('ðŸ“‹ Full API Response: ${response.body}'); // Debug
              setState(() {
                _isLoadingProducts = false;
              });
            }
          } catch (jsonError) {
            print('âŒ JSON Decode Error: $jsonError');
            print('ðŸ“‹ Raw Response Body: ${response.body}');
            setState(() {
              _isLoadingProducts = false;
            });
          }
        } else {
          print('âŒ API Error Status: ${response.statusCode}'); // Debug
          print('ðŸ“‹ Full Response Body: ${response.body}'); // Debug
          setState(() {
            _isLoadingProducts = false;
          });
        }
      }
    } catch (e, stackTrace) {
      print('âŒ Error fetching products: $e'); // Debug
      print('ðŸ“‹ Stack Trace: $stackTrace');
      if (mounted) {
        setState(() {
          _isLoadingProducts = false;
        });
      }
    }
  }

  Future<void> _fetchAllProducts() async {
    if (!mounted) return;
    
    setState(() {
      _isLoadingAllProducts = true;
    });
    
    try {
      const String apiUrl = 'https://superdailys.com/superdailyapp/get_all_products.php';
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true && data['products'] != null) {
            setState(() {
              _allProducts = data['products'];
              _isLoadingAllProducts = false;
            });
          } else {
            setState(() {
              _allProducts = [];
              _isLoadingAllProducts = false;
            });
          }
        } else {
          setState(() {
            _allProducts = [];
            _isLoadingAllProducts = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        debugPrint('Error fetching all products: $e');
        setState(() {
          _allProducts = [];
          _isLoadingAllProducts = false;
        });
      }
    }
  }

  Future<void> _fetchCategories() async {
    try {
      const String apiUrl = 'https://superdailys.com/superdailyapp/get_categories.php';
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            final categories = data['categories'] ?? [];
            print('Fetched ${categories.length} categories'); // Debug
            setState(() {
              _categories = categories;
              _isLoadingCategories = false;
            });
          } else {
            print('Categories API returned success=false: ${data['message']}'); // Debug
            setState(() {
              _isLoadingCategories = false;
            });
          }
        } else {
          print('Categories API Error Status: ${response.statusCode}'); // Debug
          print('Response: ${response.body}'); // Debug
          setState(() {
            _isLoadingCategories = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        print('Categories fetch error: $e'); // Debug
        setState(() {
          _isLoadingCategories = false;
        });
      }
    }
  }

  Future<void> _fetchOneTimeServices() async {
    try {
      const String apiUrl = 'https://superdailys.com/superdailyapp/get_one_time_services.php';
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            final services = data['services'] ?? [];
            print('âœ… Fetched ${services.length} one-time services'); // Debug
            
            // Debug: Check first service images
            if (services.isNotEmpty) {
              final firstService = services[0];
              print('ðŸ” First service sample: ${firstService['name']}');
              print('   image: ${firstService['image']}');
              print('   image_2: ${firstService['image_2']}');
              print('   image_3: ${firstService['image_3']}');
              print('   image_4: ${firstService['image_4']}');
            }
            
            setState(() {
              _oneTimeServices = services;
              _isLoadingServices = false;
            });
          } else {
            print('âŒ One-time services API returned success=false: ${data['message']}'); // Debug
            setState(() {
              _isLoadingServices = false;
            });
          }
        } else {
          print('âŒ One-time services API Error Status: ${response.statusCode}'); // Debug
          print('ðŸ“‹ Response: ${response.body}'); // Debug
          setState(() {
            _isLoadingServices = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        print('One-time services fetch error: $e'); // Debug
        setState(() {
          _isLoadingServices = false;
        });
      }
    }
  }

  Future<void> _fetchMonthlySubscriptionServices() async {
    try {
      const String apiUrl = 'https://superdailys.com/superdailyapp/get_monthly_subscription_services.php';
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            final services = data['services'] ?? [];
            print('âœ… Fetched ${services.length} monthly subscription services'); // Debug
            
            // Debug: Check first service images
            if (services.isNotEmpty) {
              final firstService = services[0];
              print('ðŸ” First monthly service sample: ${firstService['name']}');
              print('   image: ${firstService['image']}');
              print('   image_2: ${firstService['image_2']}');
              print('   image_3: ${firstService['image_3']}');
              print('   image_4: ${firstService['image_4']}');
            }
            
            setState(() {
              _monthlySubscriptionServices = services;
              _isLoadingMonthlyServices = false;
            });
          } else {
            print('âŒ Monthly subscription services API returned success=false: ${data['message']}'); // Debug
            setState(() {
              _isLoadingMonthlyServices = false;
            });
          }
        } else {
          print('âŒ Monthly subscription services API Error Status: ${response.statusCode}'); // Debug
          print('ðŸ“‹ Response: ${response.body}'); // Debug
          setState(() {
            _isLoadingMonthlyServices = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        print('Monthly subscription services fetch error: $e'); // Debug
        setState(() {
          _isLoadingMonthlyServices = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final cartItemCount = _getCartItemCount();
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Stack(
          children: [
            Column(
          children: [
            // Top Navbar
            _buildAppBar(),
            // Main Content
            Expanded(
              child: _buildBody(),
                ),
              ],
            ),
            // Bottom View Cart Bar
            if (cartItemCount > 0)
              Positioned(
                bottom: 0, // Position at bottom navbar box
                left: 0,
                right: 0,
                child: Container(
                  margin: EdgeInsets.only(
                    left: 20,
                    right: 20,
                    bottom: MediaQuery.of(context).padding.bottom,
                  ),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  decoration: BoxDecoration(
                    color: _tealColor,
                    borderRadius: BorderRadius.circular(12),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 10,
                        offset: const Offset(0, -2),
                      ),
                    ],
                  ),
                  child: GestureDetector(
                    onTap: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => ShoppingCartPage(
                            cartItems: _cartItems,
                            onUpdateQuantity: _updateCartQuantity,
                            onRemoveItem: _removeFromCart,
                            onClearCart: _clearCart,
                            onCartUpdated: () {
                              setState(() {}); // Refresh to update cart count
                            },
                          ),
                        ),
                      ).then((_) {
                        setState(() {}); // Refresh when returning from cart
                      });
                    },
                    child: Row(
                      children: [
                        // Product Image (first item in cart)
                        if (_cartItems.isNotEmpty)
                          Builder(
                            builder: (context) {
                              final product = _cartItems[0]['product'];
                              final productImage = product?['image']?.toString() ?? '';
                              final imageUrl = productImage.isNotEmpty && productImage.startsWith('http')
                                  ? productImage
                                  : productImage.isNotEmpty
                                      ? 'https://superdailys.com/storage/products/${productImage.split('/').last}'
                                      : '';
                              return Container(
                                width: 40,
                                height: 40,
                                decoration: BoxDecoration(
                                  color: Colors.white,
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(8),
                                  child: imageUrl.isNotEmpty
                                      ? Image.network(
                                          imageUrl,
                                          fit: BoxFit.cover,
                                          errorBuilder: (context, error, stackTrace) {
                                            return Icon(
                                              Icons.inventory_2,
                                              color: _tealColor,
                                              size: 20,
                                            );
                                          },
                                        )
                                      : Icon(
                                          Icons.inventory_2,
                                          color: _tealColor,
                                          size: 20,
                                        ),
                                ),
                              );
                            },
                          ),
                        if (_cartItems.isNotEmpty) const SizedBox(width: 12),
                        // View Cart Text
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(
                                'View cart',
                                style: GoogleFonts.poppins(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                  color: Colors.white,
                                ),
                              ),
                              Text(
                                '$cartItemCount ${cartItemCount == 1 ? 'item' : 'items'}',
                                style: GoogleFonts.poppins(
                                  fontSize: 12,
                                  color: Colors.white.withOpacity(0.9),
                                ),
                              ),
                            ],
                          ),
                        ),
                        // Arrow Icon
                        Icon(
                          Icons.arrow_forward_ios,
                          color: Colors.white,
                          size: 18,
                        ),
                      ],
                    ),
                  ),
                ),
            ),
          ],
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) {
          setState(() {
            _currentIndex = index;
          });
          // Always reload user data when switching tabs to ensure it's always up to date
          // This ensures user data persists across all sections until logout
          _loadUserData();
          // Fetch bookings when My Bookings tab is selected
          if (index == 1) {
            _fetchMyBookings();
          }
          // Fetch both bookings and orders when Profile tab is selected
          if (index == 2) {
            _fetchMyOrders();
            _fetchMyBookings();
          }
        },
        selectedItemColor: _tealColor,
        unselectedItemColor: Colors.grey,
        type: BottomNavigationBarType.fixed,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'Home',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.book_online),
            label: 'My bookings',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person),
            label: 'Profile',
          ),
        ],
      ),
    );
  }

  Widget _buildImageCarousel() {
    return SizedBox(
      height: 200,
      width: double.infinity,
      child: Stack(
        children: [
          PageView.builder(
            controller: _carouselController,
            itemCount: 4,
            onPageChanged: (index) {
              setState(() {
                _currentCarouselIndex = index;
              });
            },
            itemBuilder: (context, index) {
              // Carousel images: b1, b2, b3, b4
              final imagePaths = [
                'images/b1.png',
                'images/b2.png',
                'images/b3.png',
                'images/b4.png',
              ];
              
              return Container(
                margin: const EdgeInsets.symmetric(horizontal: 16),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(20),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      blurRadius: 15,
                      offset: const Offset(0, 5),
                      spreadRadius: 0,
                    ),
                  ],
                ),
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(20),
                  child: Image.asset(
                    imagePaths[index],
                    fit: BoxFit.cover,
                    width: double.infinity,
                    height: double.infinity,
                    errorBuilder: (context, error, stackTrace) {
                      return Container(
                        color: _tealColor.withOpacity(0.8),
                        child: Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(
                                Icons.image_not_supported,
                                size: 64,
                                color: Colors.white.withOpacity(0.9),
                              ),
                              const SizedBox(height: 8),
                              Text(
                                'Banner ${index + 1}',
                                style: GoogleFonts.poppins(
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.white,
                                ),
                              ),
                            ],
                          ),
                        ),
                      );
                    },
                  ),
                ),
              );
            },
          ),
          // Page Indicator
          Positioned(
            bottom: 20,
            left: 0,
            right: 0,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: List.generate(
                4,
                (index) => AnimatedContainer(
                  duration: const Duration(milliseconds: 300),
                  width: _currentCarouselIndex == index ? 24 : 8,
                  height: 8,
                  margin: const EdgeInsets.symmetric(horizontal: 4),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(4),
                    color: _currentCarouselIndex == index
                        ? Colors.white
                        : Colors.white.withOpacity(0.4),
                    boxShadow: _currentCarouselIndex == index
                        ? [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.2),
                              blurRadius: 4,
                              offset: const Offset(0, 2),
                            ),
                          ]
                        : null,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAppBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: const BoxDecoration(
        color: Color(0xFF00BFA5),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // Left side: Logo and Text
          Row(
            children: [
          ColorFiltered(
            colorFilter: const ColorFilter.mode(
              Colors.white,
              BlendMode.srcIn,
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(0),
              child: Image.asset(
                'images/logo.png',
                height: 60,
                width: 60,
                fit: BoxFit.contain,
                errorBuilder: (context, error, stackTrace) {
                  return const SizedBox.shrink();
                },
              ),
            ),
              ),
              Text(
                'Super Daily',
                style: GoogleFonts.poppins(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                  letterSpacing: 0.5,
                ),
              ),
            ],
          ),
          // Right side: Notification, Search and Account Icons
          Row(
            children: [
              // Notification Icon
              IconButton(
                icon: const Icon(Icons.notifications, color: Colors.white),
                onPressed: () {
                  // Navigate to notifications screen
                  if (_userData != null && _userData!['id'] != null) {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => NotificationsScreen(
                          userId: _userData!['id'],
                        ),
                      ),
                    );
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Please login to view notifications'),
                        duration: Duration(seconds: 2),
                      ),
                    );
                  }
                },
              ),
              // Search Icon
              IconButton(
                icon: const Icon(Icons.search, color: Colors.white),
                onPressed: () {
                  // Search functionality can be added here
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Search'),
                      duration: Duration(seconds: 1),
                    ),
                  );
                },
              ),
              // Account Icon with Profile Picture
              GestureDetector(
                onTap: () {
                  // Navigate to profile or show account options
                  setState(() {
                    _currentIndex = 2; // Navigate to Profile tab
                  });
                },
                child: Container(
                  width: 40,
                  height: 40,
                  margin: const EdgeInsets.all(4),
                  child: _buildProfilePicture(
                    radius: 18,
                    backgroundColor: Colors.white,
                    iconColor: _tealColor,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildBody() {
    switch (_currentIndex) {
      case 0:
        return _buildHomeTab();
      case 1:
        return _buildBookingsTab();
      case 2:
        return _buildProfileTab();
      default:
        return _buildHomeTab();
    }
  }

  // Helper function to build professional section header
  Widget _buildSectionHeader(String title, IconData icon, {Widget? action}) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16.0),
      padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: _tealColor.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Icon(icon, color: _tealColor, size: 22),
              ),
              const SizedBox(width: 12),
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey.shade900,
                  letterSpacing: -0.5,
                ),
              ),
            ],
          ),
          if (action != null) action,
        ],
      ),
    );
  }

  // Helper function to build section container
  Widget _buildSectionContainer({required Widget child, Color? backgroundColor}) {
    return Container(
      margin: const EdgeInsets.only(bottom: 24),
      decoration: BoxDecoration(
        color: backgroundColor ?? Colors.white,
        borderRadius: BorderRadius.circular(0),
      ),
      child: child,
    );
  }

  Widget _buildHomeTab() {
    return Stack(
      children: [
        Container(
          color: Colors.grey.shade50,
          child: SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Image Carousel
                const SizedBox(height: 20),
          _buildImageCarousel(),
                const SizedBox(height: 24),
          // One Time Service Section
                _buildSectionContainer(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                      _buildSectionHeader(
                  'One Time Service',
                        Icons.room_service,
                        action: !_isLoadingServices && _oneTimeServices.isNotEmpty
                            ? TextButton.icon(
                    onPressed: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => const AllServicesScreen(),
                        ),
                      );
                    },
                                icon: Icon(Icons.arrow_forward_ios, size: 14, color: _tealColor),
                                label: Text(
                      'View All',
                      style: GoogleFonts.poppins(
                        color: _tealColor,
                        fontWeight: FontWeight.w600,
                                    fontSize: 14,
                      ),
                    ),
                              )
                            : null,
          ),
          const SizedBox(height: 8),
          _isLoadingServices
              ? const SizedBox(
                  height: 200,
                  child: Center(
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
                    ),
                  ),
                )
              : _oneTimeServices.isEmpty
                  ? SizedBox(
                      height: 200,
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(
                              Icons.room_service_outlined,
                              size: 64,
                              color: Colors.grey.shade400,
                            ),
                            const SizedBox(height: 16),
                            Text(
                              'No one-time services available',
                              style: GoogleFonts.poppins(
                                fontSize: 16,
                                color: Colors.grey.shade600,
                              ),
                            ),
                          ],
                        ),
                      ),
                    )
                  : SizedBox(
                      height: 200,
                      child: ListView.builder(
                        scrollDirection: Axis.horizontal,
                        padding: const EdgeInsets.symmetric(horizontal: 16.0),
                        itemCount: _oneTimeServices.length,
                        itemBuilder: (context, index) {
                          return Padding(
                            padding: EdgeInsets.only(
                              right: index == _oneTimeServices.length - 1 ? 0 : 12,
                            ),
                            child: _buildOneTimeServiceCard(_oneTimeServices[index]),
                          );
                        },
                      ),
                    ),
                    ],
                  ),
                ),
          // Monthly Subscription Section
                _buildSectionContainer(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                      _buildSectionHeader(
                  'Monthly Subscription',
                        Icons.subscriptions,
                        action: !_isLoadingMonthlyServices && _monthlySubscriptionServices.isNotEmpty
                            ? TextButton.icon(
                    onPressed: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => const AllServicesScreen(),
                        ),
                      );
                    },
                                icon: Icon(Icons.arrow_forward_ios, size: 14, color: _tealColor),
                                label: Text(
                      'View All',
                      style: GoogleFonts.poppins(
                        color: _tealColor,
                        fontWeight: FontWeight.w600,
                                    fontSize: 14,
                      ),
                    ),
                              )
                            : null,
          ),
          const SizedBox(height: 8),
          _isLoadingMonthlyServices
              ? const SizedBox(
                  height: 200,
                  child: Center(
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
                    ),
                  ),
                )
              : _monthlySubscriptionServices.isEmpty
                  ? SizedBox(
                      height: 200,
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(
                              Icons.subscriptions_outlined,
                              size: 64,
                              color: Colors.grey.shade400,
                            ),
                            const SizedBox(height: 16),
                            Text(
                              'No monthly subscription services available',
                              style: GoogleFonts.poppins(
                                fontSize: 16,
                                color: Colors.grey.shade600,
                              ),
                            ),
                          ],
                        ),
                      ),
                    )
                  : SizedBox(
                      height: 200,
                      child: ListView.builder(
                        scrollDirection: Axis.horizontal,
                        padding: const EdgeInsets.symmetric(horizontal: 16.0),
                        itemCount: _monthlySubscriptionServices.length,
                        itemBuilder: (context, index) {
                          return Padding(
                            padding: EdgeInsets.only(
                              right: index == _monthlySubscriptionServices.length - 1 ? 0 : 12,
                            ),
                            child: _buildOneTimeServiceCard(_monthlySubscriptionServices[index]),
                          );
                        },
                      ),
                    ),
                    ],
                  ),
                ),
                // Featured Products Section
                _buildSectionContainer(
                        child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                      _buildSectionHeader(
                        'Featured Products',
                        Icons.star,
                      ),
                      const SizedBox(height: 16),
                      // Categories with Products Section
                      _buildCategoriesWithProductsSection(),
                    ],
                  ),
                ),
                const SizedBox(height: 24),
                          ],
                        ),
                      ),
        ),
        // Success Message Banner
        if (_showCartSuccessMessage)
          Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: Container(
              margin: const EdgeInsets.all(16),
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: Colors.green.shade50,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.green.shade200),
              ),
            child: Row(
              children: [
                  Icon(Icons.check_circle, color: Colors.green.shade700, size: 20),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      'Product added to cart successfully!',
                  style: GoogleFonts.poppins(
                                fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: Colors.green.shade900,
                      ),
                    ),
                  ),
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        _showCartSuccessMessage = false;
                      });
                    },
                    child: Icon(Icons.close, color: Colors.green.shade700, size: 20),
                  ),
              ],
            ),
          ),
          ),
      ],
    );
  }

  Widget _buildCategoriesWithProductsSection() {
    // Fetch all products if not already loaded
    if (_isLoadingAllProducts && _allProducts.isEmpty) {
      _fetchAllProducts();
    }
    // Fetch categories if not already loaded
    if (_isLoadingCategories && _categories.isEmpty) {
      _fetchCategories();
    }
    
    // Group products by category_id
    Map<int, List<dynamic>> productsByCategory = {};
    Map<int, String> categoryNames = {};
    
    // First, create maps from categories table
    for (var category in _categories) {
      final categoryId = category['id'];
      if (categoryId != null) {
        final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
        if (id != null) {
          categoryNames[id] = category['name'] ?? 'Uncategorized';
        }
      }
    }
    
    // Group products by category_id
    for (var product in _allProducts) {
      final categoryId = product['category_id'];
      if (categoryId != null) {
        final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
        if (id != null) {
          if (!productsByCategory.containsKey(id)) {
            productsByCategory[id] = [];
          }
          productsByCategory[id]!.add(product);
        }
      }
    }
    
    // Get list of categories that have products, sorted by category order from database
    final categoriesWithProducts = _categories
        .where((category) {
          final categoryId = category['id'];
          if (categoryId == null) return false;
          final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
          return id != null && productsByCategory.containsKey(id) && productsByCategory[id]!.isNotEmpty;
        })
        .toList();
    
    if (_isLoadingAllProducts || _isLoadingCategories) {
      return const Padding(
        padding: EdgeInsets.all(32.0),
                      child: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }
    
    if (categoriesWithProducts.isEmpty) {
      return const SizedBox.shrink();
    }
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: categoriesWithProducts.map((category) {
        final categoryId = category['id'];
        final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
        if (id == null) return const SizedBox.shrink();
        
        final categoryName = categoryNames[id] ?? category['name'] ?? 'Uncategorized';
        final categoryProducts = productsByCategory[id] ?? [];
        
        if (categoryProducts.isEmpty) return const SizedBox.shrink();
        
        // Get category icon based on category name
        IconData categoryIcon = Icons.category;
        if (categoryName.toLowerCase().contains('grocery') || 
            categoryName.toLowerCase().contains('fresh')) {
          categoryIcon = Icons.shopping_bag;
        } else if (categoryName.toLowerCase().contains('dairy') || 
                   categoryName.toLowerCase().contains('egg')) {
          categoryIcon = Icons.egg;
        } else if (categoryName.toLowerCase().contains('fruit') || 
                   categoryName.toLowerCase().contains('vegetable')) {
          categoryIcon = Icons.apple;
        } else if (categoryName.toLowerCase().contains('bakery') || 
                   categoryName.toLowerCase().contains('bread')) {
          categoryIcon = Icons.bakery_dining;
        } else if (categoryName.toLowerCase().contains('beverage') || 
                   categoryName.toLowerCase().contains('drink')) {
          categoryIcon = Icons.local_drink;
        }
        
        return Container(
          margin: const EdgeInsets.only(bottom: 24),
                        child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
              // Category Header
              Padding(
                padding: const EdgeInsets.fromLTRB(16.0, 8.0, 16.0, 12.0),
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: _tealColor.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Icon(
                        categoryIcon,
                        color: _tealColor,
                        size: 20,
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Text(
                        categoryName,
                              style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.normal,
                          color: Colors.grey.shade900,
                          letterSpacing: -0.3,
                        ),
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.grey.shade100,
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        '${categoryProducts.length}',
                              style: GoogleFonts.poppins(
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade700,
                        ),
                              ),
                            ),
                          ],
                        ),
                      ),
            // Products Horizontal List for this category
            SizedBox(
                      height: 200,
                      child: ListView.builder(
                        scrollDirection: Axis.horizontal,
                        physics: const BouncingScrollPhysics(),
                        padding: const EdgeInsets.symmetric(horizontal: 16.0),
                itemCount: categoryProducts.length,
                        itemBuilder: (context, index) {
                          try {
                          return Padding(
                            padding: EdgeInsets.only(
                        right: index == categoryProducts.length - 1 ? 0 : 12,
                            ),
                              child: SizedBox(
                                width: 160,
                        child: _buildProductListItem(categoryProducts[index]),
                              ),
                            );
                          } catch (e, stackTrace) {
                    debugPrint('âŒ Error building product item at index $index: $e');
                    debugPrint('ðŸ“‹ Stack trace: $stackTrace');
                            return Container(
                              width: 160,
                              padding: const EdgeInsets.all(12),
                              margin: const EdgeInsets.only(right: 12),
                              decoration: BoxDecoration(
                                color: Colors.red.shade50,
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(color: Colors.red.shade200),
                              ),
                              child: Text(
                        'Error loading product',
                                style: GoogleFonts.poppins(fontSize: 12, color: Colors.red.shade700),
                              ),
                            );
                          }
                        },
                      ),
                    ),
              const SizedBox(height: 8),
        ],
      ),
        );
      }).toList(),
    );
  }

  Widget _buildProductsTab() {
    // Fetch products when tab is opened
    if (_isLoadingAllProducts && _allProducts.isEmpty) {
      _fetchAllProducts();
    }
    // Fetch categories if not already loaded
    if (_isLoadingCategories && _categories.isEmpty) {
      _fetchCategories();
    }
    
    // Group products by category_id
    Map<int, List<dynamic>> productsByCategory = {};
    Map<int, String> categoryNames = {};
    Map<int, dynamic> categoryData = {};
    
    // Debug: Print categories
    debugPrint('ðŸ“‹ Total categories fetched: ${_categories.length}');
    for (var cat in _categories) {
      debugPrint('  Category: id=${cat['id']}, name=${cat['name']}');
    }
    
    // First, create maps from categories table
    for (var category in _categories) {
      final categoryId = category['id'];
      if (categoryId != null) {
        final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
        if (id != null) {
          categoryNames[id] = category['name'] ?? 'Uncategorized';
          categoryData[id] = category;
        }
      }
    }
    
    debugPrint('ðŸ“‹ Category names map: $categoryNames');
    debugPrint('ðŸ“¦ Total products: ${_allProducts.length}');
    
    // Group products by category_id
    int productsWithoutCategory = 0;
    for (var product in _allProducts) {
      final categoryId = product['category_id'];
      final productName = product['name'] ?? 'Unknown';
      
      if (categoryId != null) {
        final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
        if (id != null) {
          if (categoryNames.containsKey(id)) {
            // Product belongs to a valid category
            if (!productsByCategory.containsKey(id)) {
              productsByCategory[id] = [];
            }
            productsByCategory[id]!.add(product);
            debugPrint('âœ… Product "$productName" added to category $id (${categoryNames[id]})');
          } else {
            // Category ID exists but not in categories list - still add it
            if (!productsByCategory.containsKey(id)) {
              productsByCategory[id] = [];
              categoryNames[id] = 'Category $id'; // Fallback name
            }
            productsByCategory[id]!.add(product);
            debugPrint('âš ï¸ Product "$productName" has category_id=$id but category not found in categories list');
          }
        } else {
          productsWithoutCategory++;
          debugPrint('âŒ Product "$productName" has invalid category_id: $categoryId');
        }
      } else {
        productsWithoutCategory++;
        debugPrint('âŒ Product "$productName" has no category_id');
      }
    }
    
    debugPrint('ðŸ“Š Products grouped by category:');
    productsByCategory.forEach((catId, products) {
      debugPrint('  Category $catId (${categoryNames[catId]}): ${products.length} products');
    });
    debugPrint('ðŸ“Š Products without valid category: $productsWithoutCategory');
    
    // Get list of category IDs that have products, sorted by category order from database
    final categoriesWithProducts = _categories
        .where((category) {
          final categoryId = category['id'];
          if (categoryId == null) return false;
          final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
          return id != null && productsByCategory.containsKey(id) && productsByCategory[id]!.isNotEmpty;
        })
        .toList();
    
    // Also add categories that have products but aren't in the categories list
    final missingCategories = <Map<String, dynamic>>[];
    for (var catId in productsByCategory.keys) {
      if (!categoriesWithProducts.any((cat) {
        final catIdFromCat = cat['id'];
        final id = catIdFromCat is int ? catIdFromCat : int.tryParse(catIdFromCat.toString());
        return id == catId;
      })) {
        // This category has products but wasn't in the categories list
        // Add it with a fallback name
        missingCategories.add({
          'id': catId,
          'name': categoryNames[catId] ?? 'Category $catId',
        });
      }
    }
    
    // Combine both lists - categories from DB first, then missing ones
    final allCategoriesWithProducts = [...categoriesWithProducts, ...missingCategories];
    
    debugPrint('ðŸ“‹ Categories with products: ${allCategoriesWithProducts.length}');
    debugPrint('  - From categories table: ${categoriesWithProducts.length}');
    debugPrint('  - Missing from table: ${missingCategories.length}');
    
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0),
            child: Text(
            'All Products',
            style: GoogleFonts.poppins(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Colors.grey.shade800,
            ),
          ),
          ),
          _isLoadingAllProducts || _isLoadingCategories
              ? const Center(
                  child: Padding(
                    padding: EdgeInsets.all(32.0),
                    child: CircularProgressIndicator(),
                  ),
                )
              : _allProducts.isEmpty
                  ? Center(
                      child: Padding(
                        padding: const EdgeInsets.all(32.0),
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(
                              Icons.inventory_2_outlined,
                              size: 64,
                              color: Colors.grey.shade400,
                            ),
                            const SizedBox(height: 16),
                            Text(
                              'No products available',
                              style: GoogleFonts.poppins(
                                fontSize: 16,
                                color: Colors.grey.shade600,
                              ),
                            ),
                          ],
                        ),
                      ),
                    )
                  : allCategoriesWithProducts.isEmpty
                      ? Center(
                          child: Padding(
                            padding: const EdgeInsets.all(32.0),
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                Icon(
                                  Icons.inventory_2_outlined,
                                  size: 64,
                                  color: Colors.grey.shade400,
                                ),
                                const SizedBox(height: 16),
                                Text(
                                  'No products available',
                                  style: GoogleFonts.poppins(
                                    fontSize: 16,
                                    color: Colors.grey.shade600,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        )
                      : Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: allCategoriesWithProducts.map((category) {
                            final categoryId = category['id'];
                            final id = categoryId is int ? categoryId : int.tryParse(categoryId.toString());
                            if (id == null) return const SizedBox.shrink();
                            
                            final categoryName = categoryNames[id] ?? category['name'] ?? 'Uncategorized';
                            final categoryProducts = productsByCategory[id] ?? [];
                            
                            // Get category icon based on category name or use default
                            IconData categoryIcon = Icons.category;
                            if (categoryName.toLowerCase().contains('grocery') || 
                                categoryName.toLowerCase().contains('fresh')) {
                              categoryIcon = Icons.shopping_bag;
                            } else if (categoryName.toLowerCase().contains('dairy') || 
                                     categoryName.toLowerCase().contains('egg')) {
                              categoryIcon = Icons.egg;
                            } else if (categoryName.toLowerCase().contains('fruit') || 
                                     categoryName.toLowerCase().contains('vegetable')) {
                              categoryIcon = Icons.apple;
                            } else {
                              categoryIcon = Icons.category;
                            }
                            
                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                // Category Header with Icon
                                Padding(
                                  padding: const EdgeInsets.only(top: 24, bottom: 12, left: 16, right: 16),
                                  child: Row(
                                    children: [
                                      Icon(
                                        categoryIcon,
                                        size: 24,
                                        color: _tealColor,
                                      ),
                                      const SizedBox(width: 12),
                                      Text(
                                        categoryName,
                                        style: GoogleFonts.poppins(
                                          fontSize: 20,
                                          fontWeight: FontWeight.bold,
                                          color: Colors.grey.shade800,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                // Products Horizontal List for this category
                                SizedBox(
                                  height: 200,
                                  child: ListView.builder(
                                    scrollDirection: Axis.horizontal,
                                    physics: const BouncingScrollPhysics(),
                                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
                                    itemCount: categoryProducts.length,
                      itemBuilder: (context, index) {
                                      try {
                                        return Padding(
                                          padding: EdgeInsets.only(
                                            right: index == categoryProducts.length - 1 ? 0 : 12,
                                          ),
                                          child: SizedBox(
                                            width: 160,
                                            child: _buildProductListItem(categoryProducts[index]),
                                          ),
                                        );
                                      } catch (e, stackTrace) {
                                        debugPrint('âŒ Error building product item at index $index: $e');
                                        debugPrint('ðŸ“‹ Stack trace: $stackTrace');
                                        debugPrint('ðŸ“¦ Product data: ${categoryProducts[index]}');
                                        // Return error widget instead of crashing
                                        return Container(
                                          width: 160,
                                          padding: const EdgeInsets.all(12),
                                          margin: const EdgeInsets.only(right: 12),
                                          decoration: BoxDecoration(
                                            color: Colors.red.shade50,
                                            borderRadius: BorderRadius.circular(8),
                                            border: Border.all(color: Colors.red.shade200),
                                          ),
                                          child: Text(
                                            'Error loading product: ${e.toString()}',
                                            style: GoogleFonts.poppins(fontSize: 12, color: Colors.red.shade700),
                                          ),
                                        );
                                      }
                                    },
                                  ),
                                ),
                                const SizedBox(height: 16),
                              ],
                            );
                          }).toList(),
                        ),
        ],
      ),
    );
  }

  Future<void> _fetchMyBookings() async {
    if (!mounted) return;
    
    // If user is not logged in, don't fetch bookings
    if (_userData == null) {
      setState(() {
        _isLoadingBookings = false;
        _myBookings = [];
      });
      return;
    }
    
    setState(() {
      _isLoadingBookings = true;
    });
    
    try {
      final userId = _userData!['id'] ?? _userData!['user_id'];
      if (userId == null) {
        setState(() {
          _isLoadingBookings = false;
          _myBookings = [];
        });
        return;
      }
      
      final apiUrl = 'https://superdailys.com/superdailyapp/get_my_bookings.php?user_id=' + userId.toString();
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );
      
      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true && data['bookings'] != null) {
            // Debug: Check if service_name is present in bookings
            if (data['bookings'].isNotEmpty) {
              debugPrint('ðŸ“‹ [BOOKINGS] First booking service_name: ${data['bookings'][0]['service_name']}');
            }
            setState(() {
              _myBookings = data['bookings'];
              _isLoadingBookings = false;
            });
          } else {
            setState(() {
              _myBookings = [];
              _isLoadingBookings = false;
            });
          }
        } else {
          setState(() {
            _myBookings = [];
            _isLoadingBookings = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        debugPrint('Error fetching bookings: $e');
        setState(() {
          _myBookings = [];
          _isLoadingBookings = false;
        });
      }
    }
  }

  Future<void> _fetchMyOrders() async {
    if (!mounted) return;
    
    // If user is not logged in, don't fetch orders
    if (_userData == null) {
      setState(() {
        _isLoadingOrders = false;
        _myOrders = [];
      });
      return;
    }
    
    setState(() {
      _isLoadingOrders = true;
    });
    
    try {
      final userId = _userData!['id'] ?? _userData!['user_id'];
      if (userId == null) {
        setState(() {
          _isLoadingOrders = false;
          _myOrders = [];
        });
        return;
      }
      
      final apiUrl = '${kBackendBaseUrl}get_my_orders.php?user_id=' + userId.toString();
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );
      
      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true && data['orders'] != null) {
            setState(() {
              _myOrders = data['orders'];
              _isLoadingOrders = false;
            });
          } else {
            setState(() {
              _myOrders = [];
              _isLoadingOrders = false;
            });
          }
        } else {
          setState(() {
            _myOrders = [];
            _isLoadingOrders = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        debugPrint('Error fetching orders: $e');
        setState(() {
          _myOrders = [];
          _isLoadingOrders = false;
        });
      }
    }
  }

  Widget _buildBookingsTab() {
    return RefreshIndicator(
      onRefresh: _fetchMyBookings,
      color: _tealColor,
      child: SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header with title and refresh button
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'My Bookings',
              style: GoogleFonts.poppins(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Colors.grey.shade800,
              ),
                ),
                IconButton(
                  icon: _isLoadingBookings
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
                          ),
                        )
                      : const Icon(Icons.refresh),
                  onPressed: _isLoadingBookings ? null : _fetchMyBookings,
                  tooltip: 'Refresh',
                  color: _tealColor,
                ),
              ],
            ),
            const SizedBox(height: 16),
            // Filter dropdown
            if (!_isLoadingBookings && _myBookings.isNotEmpty)
              Container(
                margin: const EdgeInsets.only(bottom: 16),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.grey.shade300),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.05),
                      blurRadius: 4,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: DropdownButtonHideUnderline(
                  child: DropdownButton<String>(
                    value: _bookingFilter,
                    isExpanded: true,
                    icon: Icon(
                      Icons.filter_list,
                      color: _tealColor,
                    ),
                    style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w500,
                      color: Colors.grey.shade800,
                    ),
                    dropdownColor: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    items: [
                      DropdownMenuItem<String>(
                        value: 'all',
                        child: Row(
                          children: [
                            Icon(
                              Icons.list,
                              size: 20,
                              color: Colors.grey.shade600,
                            ),
                            const SizedBox(width: 12),
                            Text('All Bookings'),
                          ],
                        ),
                      ),
                      DropdownMenuItem<String>(
                        value: 'monthly',
                        child: Row(
                          children: [
                            Icon(
                              Icons.calendar_month,
                              size: 20,
                              color: _tealColor,
                            ),
                            const SizedBox(width: 12),
                            Text('Monthly Subscriptions'),
                          ],
                        ),
                      ),
                      DropdownMenuItem<String>(
                        value: 'onetime',
                        child: Row(
                          children: [
                            Icon(
                              Icons.event,
                              size: 20,
                              color: Colors.orange.shade600,
                            ),
                            const SizedBox(width: 12),
                            Text('One Time Services'),
                          ],
                        ),
                      ),
                    ],
                    onChanged: (String? newValue) {
                      if (newValue != null) {
                        setState(() {
                          _bookingFilter = newValue;
                        });
                      }
                    },
                  ),
                ),
              ),
            _isLoadingBookings
                ? const Center(
                    child: Padding(
                      padding: EdgeInsets.all(32.0),
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
                      ),
                    ),
                  )
                : _myBookings.isEmpty
                    ? Center(
                        child: Padding(
                          padding: const EdgeInsets.all(32.0),
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(
                                Icons.book_online_outlined,
                                size: 64,
                                color: Colors.grey.shade400,
                              ),
                              const SizedBox(height: 16),
                              Text(
                                'No bookings found',
                                style: GoogleFonts.poppins(
                                  fontSize: 16,
                                  color: Colors.grey.shade600,
                                ),
                              ),
                              const SizedBox(height: 8),
                              Text(
                                'Your bookings will appear here',
                                style: GoogleFonts.poppins(
                                  fontSize: 14,
                                  color: Colors.grey.shade500,
                                ),
                              ),
                            ],
                          ),
                        ),
                      )
                    : _buildSeparatedBookingsList(),
          ],
        ),
      ),
    );
  }

  void _openBookingDetails(Map<String, dynamic> booking) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => BookingDetailsScreen(booking: booking),
      ),
    );
  }

  List<dynamic> _filterBookings(List<dynamic> bookings, String query) {
    if (query.trim().isEmpty) {
      return bookings;
    }
    
    final lowerQuery = query.toLowerCase().trim();
    return bookings.where((booking) {
      // Search in service name
      final serviceName = (booking['service_name'] ?? '').toString().toLowerCase();
      if (serviceName.contains(lowerQuery)) return true;
      
      // Search in booking reference
      final bookingRef = (booking['booking_reference'] ?? '').toString().toLowerCase();
      if (bookingRef.contains(lowerQuery)) return true;
      
      // Search in address
      final address = (booking['address'] ?? '').toString().toLowerCase();
      if (address.contains(lowerQuery)) return true;
      
      // Search in status
      final status = (booking['status'] ?? '').toString().toLowerCase();
      if (status.contains(lowerQuery)) return true;
      
      // Search in phone
      final phone = (booking['phone'] ?? '').toString();
      if (phone.contains(lowerQuery)) return true;
      
      // Search in selected price option
      final priceOption = (booking['selected_price_option'] ?? '').toString().toLowerCase();
      if (priceOption.contains(lowerQuery)) return true;
      
      return false;
    }).toList();
  }

  Widget _buildSeparatedBookingsList() {
    // Filter bookings based on search query
    final filteredBookings = _filterBookings(_myBookings, _bookingSearchController.text);
    
    // Separate bookings into monthly subscriptions and one-time services
    final monthlyBookings = <Map<String, dynamic>>[];
    final oneTimeBookings = <Map<String, dynamic>>[];
    
    for (var booking in filteredBookings) {
      if (_isMonthlySubscriptionBooking(booking)) {
        monthlyBookings.add(booking);
      } else {
        oneTimeBookings.add(booking);
      }
    }
    
    // Apply filter selection
    final showMonthly = _bookingFilter == 'all' || _bookingFilter == 'monthly';
    final showOneTime = _bookingFilter == 'all' || _bookingFilter == 'onetime';
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Monthly Subscription Section
        if (showMonthly && monthlyBookings.isNotEmpty) ...[
          Row(
            children: [
              Icon(
                Icons.calendar_month,
                size: 20,
                color: _tealColor,
              ),
              const SizedBox(width: 8),
              Text(
                'Monthly Subscriptions',
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey.shade800,
                ),
              ),
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: _tealColor.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${monthlyBookings.length}',
                  style: GoogleFonts.poppins(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: _tealColor,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          ...monthlyBookings.map((booking) => _buildBookingCard(booking)).toList(),
          if (_bookingFilter == 'all' && oneTimeBookings.isNotEmpty) const SizedBox(height: 24),
        ],
        
        // One Time Services Section
        if (showOneTime && oneTimeBookings.isNotEmpty) ...[
          Row(
            children: [
              Icon(
                Icons.event,
                size: 20,
                color: Colors.orange.shade600,
              ),
              const SizedBox(width: 8),
              Text(
                'One Time Services',
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey.shade800,
                ),
              ),
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: Colors.orange.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${oneTimeBookings.length}',
                  style: GoogleFonts.poppins(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: Colors.orange.shade600,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          ...oneTimeBookings.map((booking) => _buildBookingCard(booking)).toList(),
        ],
        
        // Show message if no bookings match the filter
        if ((showMonthly && monthlyBookings.isEmpty && !showOneTime) ||
            (showOneTime && oneTimeBookings.isEmpty && !showMonthly) ||
            (showMonthly && monthlyBookings.isEmpty && showOneTime && oneTimeBookings.isEmpty))
          Center(
            child: Padding(
              padding: const EdgeInsets.all(32.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    _bookingFilter == 'monthly' 
                        ? Icons.calendar_month_outlined
                        : _bookingFilter == 'onetime'
                            ? Icons.event_outlined
                            : Icons.search_off,
                    size: 64,
                    color: Colors.grey.shade400,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    _bookingFilter == 'monthly'
                        ? 'No monthly subscriptions found'
                        : _bookingFilter == 'onetime'
                            ? 'No one-time services found'
                            : 'No bookings to display',
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey.shade600,
                    ),
                  ),
                  if (_bookingSearchController.text.isNotEmpty) ...[
                    const SizedBox(height: 8),
                    Text(
                      'Try a different search term',
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        color: Colors.grey.shade500,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildBookingCard(Map<String, dynamic> booking) {
    if (_isMonthlySubscriptionBooking(booking)) {
      return _buildMonthlySubscriptionCard(booking);
    }
    return _buildStandardBookingCard(booking);
  }

  Widget _buildStandardBookingCard(Map<String, dynamic> booking) {
    final bookingRef = booking['booking_reference'] ?? 'N/A';
    final bookingDate = booking['booking_date'] ?? '';
    final bookingTime = booking['booking_time'] ?? '';
    final status = booking['status'] ?? 'pending';
    final paymentStatus = booking['payment_status'] ?? 'pending';
    final finalAmount = double.tryParse(booking['final_amount']?.toString() ?? '0') ?? 0.0;
    final address = booking['address'] ?? 'No address';
    final serviceId = booking['service_id'];
    final serviceName = booking['service_name']?.toString() ?? 
        (serviceId != null ? 'Service #$serviceId' : 'Service');
    
    // Collect all available service images (image, image_2, image_3, image_4) - SAME AS MONTHLY SUBSCRIPTION
    final List<String> bookingImages = [];
    debugPrint('ðŸ” One-time Booking "$serviceName" - Checking for images...');
    
    // Check booking object for service_image and other image fields
    for (var imgKey in ['service_image', 'image', 'image_2', 'image_3', 'image_4']) {
      final imgValue = booking[imgKey];
      if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
        final rawUrl = imgValue.toString().trim();
        debugPrint('   Checking booking[$imgKey]: $rawUrl');
        
        // If it's already a valid HTTPS URL starting with superdailys.com/storage/services/, use it directly
        if (rawUrl.startsWith('https://superdailys.com/storage/services/')) {
          if (!bookingImages.contains(rawUrl)) {
            bookingImages.add(rawUrl);
            debugPrint('âœ… One-time Booking "$serviceName" - Added direct URL from booking[$imgKey]: $rawUrl');
          }
        } 
        // If it's any other HTTP/HTTPS URL, use it directly too
        else if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
          if (!bookingImages.contains(rawUrl)) {
            bookingImages.add(rawUrl);
            debugPrint('âœ… One-time Booking "$serviceName" - Added direct URL from booking[$imgKey]: $rawUrl');
          }
        } 
        // If it's just a filename or relative path, build the full URL
        else {
          // Extract filename from the path
          String filename = rawUrl.split('/').last.split('\\').last;
          filename = filename.split('?').first.split('#').first;
          
          // Build full URL
          if (filename.isNotEmpty && filename.contains('.')) {
            final fullUrl = 'https://superdailys.com/storage/services/' + filename;
            if (!bookingImages.contains(fullUrl)) {
              bookingImages.add(fullUrl);
              debugPrint('âœ… One-time Booking "$serviceName" - Built full URL from booking[$imgKey]: $fullUrl (from: $rawUrl)');
            }
          } else {
            debugPrint('âŒ One-time Booking "$serviceName" - Invalid filename from booking[$imgKey]: $rawUrl');
          }
        }
      }
    }
    
    debugPrint('ðŸ“Š One-time Booking "$serviceName" - Total images collected: ${bookingImages.length}');
    
    // Status colors
    Color statusColor;
    String statusText;
    switch (status.toLowerCase()) {
      case 'confirmed':
        statusColor = Colors.green;
        statusText = 'Confirmed';
        break;
      case 'completed':
        statusColor = Colors.blue;
        statusText = 'Completed';
        break;
      case 'cancelled':
        statusColor = Colors.red;
        statusText = 'Cancelled';
        break;
      case 'in_progress':
      case 'started':
        statusColor = Colors.orange;
        statusText = 'In Progress';
        break;
      default:
        statusColor = Colors.grey;
        statusText = 'Pending';
    }
    
    // Payment status colors
    Color paymentColor;
    String paymentText;
    switch (paymentStatus.toLowerCase()) {
      case 'paid':
      case 'completed':
        paymentColor = Colors.green;
        paymentText = 'Paid';
        break;
      case 'failed':
        paymentColor = Colors.red;
        paymentText = 'Failed';
        break;
      case 'pending':
      default:
        paymentColor = Colors.orange;
        paymentText = 'Pending';
    }
    
    return GestureDetector(
      onTap: () => _openBookingDetails(booking),
      child: Container(
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade300),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header with status badges
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: _tealLight,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Ref: $bookingRef',
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade800,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        serviceName,
                        style: GoogleFonts.poppins(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: Colors.grey.shade900,
                        ),
                      ),
                    ],
                  ),
                ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: statusColor.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(6),
                      ),
                      child: Text(
                        statusText,
                        style: GoogleFonts.poppins(
                          fontSize: 11,
                          fontWeight: FontWeight.w600,
                          color: statusColor,
                        ),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: paymentColor.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(6),
                      ),
                      child: Text(
                        paymentText,
                        style: GoogleFonts.poppins(
                          fontSize: 11,
                          fontWeight: FontWeight.w600,
                          color: paymentColor,
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          // Booking details
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Service Image
                if (bookingImages.isNotEmpty) ...[
                  Center(
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(12),
                      child: SizedBox(
                        width: 120,
                        height: 120,
                        child: _ServiceImageWidget(
                          key: ValueKey('booking_${booking['id']}_${bookingImages.join('_')}'),
                          imageUrls: bookingImages,
                          serviceName: serviceName,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                ],
                // Date and Time
                if (bookingDate.isNotEmpty || bookingTime.isNotEmpty)
                  _buildBookingDetailRow(
                    Icons.calendar_today,
                    '${bookingDate.isNotEmpty ? bookingDate : "Not set"} ${bookingTime.isNotEmpty ? "at $bookingTime" : ""}',
                  ),
                const SizedBox(height: 8),
                // Address
                _buildBookingDetailRow(Icons.location_on, address),
                if (booking['phone'] != null && booking['phone'].toString().isNotEmpty) ...[
                  const SizedBox(height: 8),
                  _buildBookingDetailRow(Icons.phone, booking['phone'].toString()),
                ],
                if (finalAmount > 0) ...[
                  const SizedBox(height: 12),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'Total Amount',
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade700,
                        ),
                      ),
                      Text(
                        'â‚¹${finalAmount.toStringAsFixed(2)}',
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: _priceDarkBlue,
                        ),
                      ),
                    ],
                  ),
                ],
                if (booking['special_instructions'] != null && booking['special_instructions'].toString().isNotEmpty) ...[
                  const SizedBox(height: 12),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.grey.shade50,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Special Instructions',
                          style: GoogleFonts.poppins(
                            fontSize: 12,
                            fontWeight: FontWeight.w600,
                            color: Colors.grey.shade700,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          booking['special_instructions'].toString(),
                          style: GoogleFonts.poppins(
                            fontSize: 13,
                            color: Colors.grey.shade800,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
      ),
    );
  }

  Widget _buildMonthlySubscriptionCard(Map<String, dynamic> booking) {
    final subscriptionDetails = _parseSubscriptionPlanDetails(booking['subscription_plan_details']);
    final bookingRef = booking['booking_reference'] ?? 'N/A';
    final planName = (booking['subscription_plan'] ?? 'Monthly Plan').toString();
    final serviceName = booking['service_name']?.toString() ??
        subscriptionDetails?['service_name']?.toString() ??
        (booking['service_id'] != null ? 'Service #${booking['service_id']}' : 'Service');
    
    // Collect all available service images (image, image_2, image_3, image_4) - SAME AS HOME PAGE
    final List<String> bookingImages = [];
    debugPrint('ðŸ” Booking "$serviceName" - Checking for images...');
    
    // Check subscription_plan_details first (for monthly subscriptions)
    if (subscriptionDetails != null) {
      for (var imgKey in ['image', 'image_2', 'image_3', 'image_4']) {
        final imgValue = subscriptionDetails[imgKey];
        if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
          final rawUrl = imgValue.toString().trim();
          debugPrint('   Checking subscriptionDetails[$imgKey]: $rawUrl');
          
          // If it's already a valid HTTPS URL starting with superdailys.com/storage/services/, use it directly
          if (rawUrl.startsWith('https://superdailys.com/storage/services/')) {
            bookingImages.add(rawUrl);
            debugPrint('âœ… Booking "$serviceName" - Added direct URL from subscriptionDetails[$imgKey]: $rawUrl');
          } 
          // If it's any other HTTP/HTTPS URL, use it directly too
          else if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
            bookingImages.add(rawUrl);
            debugPrint('âœ… Booking "$serviceName" - Added direct URL from subscriptionDetails[$imgKey]: $rawUrl');
          } 
          // If it's just a filename or relative path, build the full URL
          else {
            // Extract filename from the path
            String filename = rawUrl.split('/').last.split('\\').last;
            filename = filename.split('?').first.split('#').first;
            
            // Build full URL
            if (filename.isNotEmpty && filename.contains('.')) {
              final fullUrl = 'https://superdailys.com/storage/services/' + filename;
              bookingImages.add(fullUrl);
              debugPrint('âœ… Booking "$serviceName" - Built full URL from subscriptionDetails[$imgKey]: $fullUrl (from: $rawUrl)');
            } else {
              debugPrint('âŒ Booking "$serviceName" - Invalid filename from subscriptionDetails[$imgKey]: $rawUrl');
            }
          }
        }
      }
    }
    
    // Also check booking object for service_image and other image fields
    for (var imgKey in ['service_image', 'image', 'image_2', 'image_3', 'image_4']) {
      final imgValue = booking[imgKey];
      if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
        final rawUrl = imgValue.toString().trim();
        debugPrint('   Checking booking[$imgKey]: $rawUrl');
        
        // If it's already a valid HTTPS URL starting with superdailys.com/storage/services/, use it directly
        if (rawUrl.startsWith('https://superdailys.com/storage/services/')) {
          if (!bookingImages.contains(rawUrl)) {
            bookingImages.add(rawUrl);
            debugPrint('âœ… Booking "$serviceName" - Added direct URL from booking[$imgKey]: $rawUrl');
          }
        } 
        // If it's any other HTTP/HTTPS URL, use it directly too
        else if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
          if (!bookingImages.contains(rawUrl)) {
            bookingImages.add(rawUrl);
            debugPrint('âœ… Booking "$serviceName" - Added direct URL from booking[$imgKey]: $rawUrl');
          }
        } 
        // If it's just a filename or relative path, build the full URL
        else {
          // Extract filename from the path
          String filename = rawUrl.split('/').last.split('\\').last;
          filename = filename.split('?').first.split('#').first;
          
          // Build full URL
          if (filename.isNotEmpty && filename.contains('.')) {
            final fullUrl = 'https://superdailys.com/storage/services/' + filename;
            if (!bookingImages.contains(fullUrl)) {
              bookingImages.add(fullUrl);
              debugPrint('âœ… Booking "$serviceName" - Built full URL from booking[$imgKey]: $fullUrl (from: $rawUrl)');
            }
          } else {
            debugPrint('âŒ Booking "$serviceName" - Invalid filename from booking[$imgKey]: $rawUrl');
          }
        }
      }
    }
    
    debugPrint('ðŸ“Š Booking "$serviceName" - Total images collected: ${bookingImages.length}');
    final bookingDate = booking['booking_date'] ?? '';
    final bookingTime = booking['booking_time'] ?? '';
    final duration = booking['duration_hours']?.toString() ??
        subscriptionDetails?['duration_hours']?.toString() ??
        subscriptionDetails?['duration']?.toString();
    final maidInfo = booking['maid_info'];
    final serviceProvider = maidInfo is Map && maidInfo['name'] != null
        ? maidInfo['name'].toString()
        : 'Not Assigned';
    final statusMeta = _bookingStatusMeta(booking['status']);
    final paymentMeta = _paymentStatusMeta(booking['payment_status']);
    final price = double.tryParse(
          booking['final_amount']?.toString() ??
              subscriptionDetails?['price']?.toString() ??
              '0',
        ) ??
        0.0;
    return GestureDetector(
      onTap: () => _openBookingDetails(booking),
      child: Container(
        margin: const EdgeInsets.only(bottom: 20),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(18),
          border: Border.all(color: Colors.grey.shade200),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.03),
              blurRadius: 12,
              offset: const Offset(0, 6),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  ClipRRect(
                    borderRadius: BorderRadius.circular(12),
                    child: bookingImages.isNotEmpty
                        ? SizedBox(
                            width: 90,
                            height: 90,
                            child: _ServiceImageWidget(
                              key: ValueKey('booking_${booking['id']}_${bookingImages.join('_')}'),
                              imageUrls: bookingImages,
                              serviceName: serviceName,
                            ),
                          )
                        : _buildImagePlaceholder(),
                  ),
                  const SizedBox(width: 14),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          serviceName,
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.w700,
                            color: Colors.grey.shade900,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          'Order #$bookingRef â€¢ Placed ${_formatDisplayDate(booking['created_at']?.toString())}',
                          style: GoogleFonts.poppins(
                            fontSize: 12,
                            color: Colors.grey.shade600,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 8),
                        Wrap(
                          spacing: 8,
                          runSpacing: 8,
                          children: [
                            _buildStatusChip(statusMeta.label, statusMeta.color),
                            _buildStatusChip(paymentMeta.label, paymentMeta.color, icon: Icons.payments_outlined),
                            _buildPlanBadge(planName),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            // Main content area with two columns (responsive)
            Padding(
              padding: const EdgeInsets.all(16),
              child: LayoutBuilder(
                builder: (context, constraints) {
                  final isWideScreen = constraints.maxWidth > 700;
                  
                  if (isWideScreen) {
                    // Two columns for wider screens
                    return Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // LEFT COLUMN: Large image, price card, and booking details
                        Expanded(
                          flex: 2,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Large service image
                              ClipRRect(
                                borderRadius: BorderRadius.circular(16),
                                child: bookingImages.isNotEmpty
                                    ? SizedBox(
                                        width: double.infinity,
                                        height: 200,
                                        child: _ServiceImageWidget(
                                          key: ValueKey('booking_large_${booking['id']}_${bookingImages.join('_')}'),
                                          imageUrls: bookingImages,
                                          serviceName: serviceName,
                                        ),
                                      )
                                    : _buildImagePlaceholder(height: 200, width: double.infinity),
                              ),
                              const SizedBox(height: 16),
                              // Service name and price card
                              Container(
                                padding: const EdgeInsets.all(16),
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF1FFFB),
                                  borderRadius: BorderRadius.circular(16),
                                  border: Border.all(color: Colors.teal.withOpacity(0.1)),
                                ),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      serviceName,
                                      style: GoogleFonts.poppins(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                        color: Colors.grey.shade900,
                                      ),
                                    ),
                                    const SizedBox(height: 6),
                                    Text(
                                      'â‚¹${price.toStringAsFixed(0)}',
                                      style: GoogleFonts.poppins(
                                        fontSize: 28,
                                        fontWeight: FontWeight.bold,
                                        color: _priceDarkBlue,
                                      ),
                                    ),
                                    const SizedBox(height: 12),
                                    SizedBox(
                                      width: double.infinity,
                                      child: ElevatedButton.icon(
                                        onPressed: () => _openBookingDetails(booking),
                                        icon: const Icon(Icons.visibility_outlined),
                                        label: const Text('View Details'),
                                        style: ElevatedButton.styleFrom(
                                          backgroundColor: _priceDarkBlue,
                                          padding: const EdgeInsets.symmetric(vertical: 14),
                                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              const SizedBox(height: 16),
                              // Booking details
                              Container(
                                decoration: BoxDecoration(
                                  borderRadius: BorderRadius.circular(16),
                                  border: Border.all(color: Colors.grey.shade200),
                                ),
                                child: Column(
                                  children: [
                                    _buildSubscriptionInfoRow(
                                      icon: Icons.calendar_month,
                                      label: 'Booking Date',
                                      value: _formatDisplayDate(bookingDate),
                                    ),
                                    const Divider(height: 0),
                                    _buildSubscriptionInfoRow(
                                      icon: Icons.access_time,
                                      label: 'Time',
                                      value: bookingTime.isNotEmpty ? bookingTime : 'Not set',
                                    ),
                                    const Divider(height: 0),
                                    _buildSubscriptionInfoRow(
                                      icon: Icons.timer_outlined,
                                      label: 'Duration',
                                      value: duration != null && duration.isNotEmpty ? '$duration hour(s)' : '--',
                                    ),
                                    const Divider(height: 0),
                                    _buildSubscriptionInfoRow(
                                      icon: Icons.person_pin_circle_outlined,
                                      label: 'Service Provider',
                                      value: serviceProvider,
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    );
                  } else {
                    // Stack vertically for smaller screens
                    return Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Large service image
                        ClipRRect(
                          borderRadius: BorderRadius.circular(16),
                          child: bookingImages.isNotEmpty
                              ? SizedBox(
                                  width: double.infinity,
                                  height: 200,
                                  child: _ServiceImageWidget(
                                    key: ValueKey('booking_narrow_${booking['id']}_${bookingImages.join('_')}'),
                                    imageUrls: bookingImages,
                                    serviceName: serviceName,
                                  ),
                                )
                              : _buildImagePlaceholder(height: 200, width: double.infinity),
                        ),
                        const SizedBox(height: 16),
                        // Service name and price card
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF1FFFB),
                            borderRadius: BorderRadius.circular(16),
                            border: Border.all(color: Colors.teal.withOpacity(0.1)),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                serviceName,
                                style: GoogleFonts.poppins(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                  color: Colors.grey.shade900,
                                ),
                              ),
                              const SizedBox(height: 6),
                              Text(
                                'â‚¹${price.toStringAsFixed(0)}',
                                style: GoogleFonts.poppins(
                                  fontSize: 28,
                                  fontWeight: FontWeight.bold,
                                  color: _priceDarkBlue,
                                ),
                              ),
                              const SizedBox(height: 12),
                              SizedBox(
                                width: double.infinity,
                                child: ElevatedButton.icon(
                                  onPressed: () => _openBookingDetails(booking),
                                  icon: const Icon(Icons.visibility_outlined),
                                  label: const Text('View Details'),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: _priceDarkBlue,
                                    padding: const EdgeInsets.symmetric(vertical: 14),
                                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 16),
                        // Booking details
                        Container(
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(16),
                            border: Border.all(color: Colors.grey.shade200),
                          ),
                          child: Column(
                            children: [
                              _buildSubscriptionInfoRow(
                                icon: Icons.calendar_month,
                                label: 'Booking Date',
                                value: _formatDisplayDate(bookingDate),
                              ),
                              const Divider(height: 0),
                              _buildSubscriptionInfoRow(
                                icon: Icons.access_time,
                                label: 'Time',
                                value: bookingTime.isNotEmpty ? bookingTime : 'Not set',
                              ),
                              const Divider(height: 0),
                              _buildSubscriptionInfoRow(
                                icon: Icons.timer_outlined,
                                label: 'Duration',
                                value: duration != null && duration.isNotEmpty ? '$duration hour(s)' : '--',
                              ),
                              const Divider(height: 0),
                              _buildSubscriptionInfoRow(
                                icon: Icons.person_pin_circle_outlined,
                                label: 'Service Provider',
                                value: serviceProvider,
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 16),
                      ],
                    );
                  }
                },
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  bool _isMonthlySubscriptionBooking(Map<String, dynamic> booking) {
    // Debug: Log booking data to understand what we're checking
    debugPrint('ðŸ” [MONTHLY DETECTION] Checking booking: ${booking['booking_reference']}');
    debugPrint('   - subscription_plan: ${booking['subscription_plan']}');
    debugPrint('   - selected_price_option: ${booking['selected_price_option']}');
    debugPrint('   - subscription_plan_details: ${booking['subscription_plan_details']}');
    
    // PRIMARY CHECK: subscription_plan field - most reliable indicator
    final plan = booking['subscription_plan']?.toString().trim().toLowerCase() ?? '';
    if (plan.isNotEmpty && (plan == 'monthly' || plan.contains('month'))) {
      debugPrint('âœ… [MONTHLY DETECTION] Detected via subscription_plan: $plan');
      return true;
    }
    
    // SECONDARY CHECK: selected_price_option field (e.g., "Monthly Subscription", "price_monthly", etc.)
    final selectedPriceOption = booking['selected_price_option']?.toString().trim().toLowerCase() ?? '';
    if (selectedPriceOption.isNotEmpty) {
      // Check for various monthly subscription indicators
      if (selectedPriceOption.contains('monthly') || 
          selectedPriceOption.contains('subscription') ||
          selectedPriceOption == 'monthly subscription' ||
          selectedPriceOption.startsWith('monthly')) {
        debugPrint('âœ… [MONTHLY DETECTION] Detected via selected_price_option: $selectedPriceOption');
        return true;
      }
    }
    
    // TERTIARY CHECK: subscription_plan_details field - check if it exists and has monthly indicators
    if (booking.containsKey('subscription_plan_details') && booking['subscription_plan_details'] != null) {
      final details = _parseSubscriptionPlanDetails(booking['subscription_plan_details']);
      if (details != null) {
        debugPrint('   - Parsed details: $details');
        // Check plan_type or billing_cycle
        final planType = details['plan_type']?.toString().toLowerCase() ?? '';
        final billingCycle = details['billing_cycle']?.toString().toLowerCase() ?? '';
        if ((planType.isNotEmpty && (planType == 'monthly' || planType.contains('month'))) ||
            (billingCycle.isNotEmpty && (billingCycle == 'monthly' || billingCycle.contains('month')))) {
          debugPrint('âœ… [MONTHLY DETECTION] Detected via plan_type/billing_cycle: $planType / $billingCycle');
          return true;
        }
        
        // If subscription_plan_details has start_date and end_date, it's likely a monthly subscription
        // (we set these for monthly subscriptions)
        if (details['start_date'] != null && details['end_date'] != null) {
          debugPrint('âœ… [MONTHLY DETECTION] Detected via start_date/end_date in subscription_plan_details');
          return true;
        }
      }
    }
    
    // FALLBACK CHECK: service name - only if other checks fail (less reliable)
    final serviceName = (booking['service_name'] ?? '').toString().toLowerCase();
    if (serviceName.contains('monthly') || serviceName.contains('subscription')) {
      debugPrint('âœ… [MONTHLY DETECTION] Detected via service_name: $serviceName');
      return true;
    }
    
    debugPrint('âŒ [MONTHLY DETECTION] Not detected as monthly subscription');
    return false;
  }

  Map<String, dynamic>? _parseSubscriptionPlanDetails(dynamic rawDetails) {
    if (rawDetails == null) return null;
    if (rawDetails is Map<String, dynamic>) return rawDetails;
    if (rawDetails is String && rawDetails.trim().isNotEmpty) {
      try {
        final decoded = jsonDecode(rawDetails);
        if (decoded is Map<String, dynamic>) {
          return decoded.cast<String, dynamic>();
        }
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  DateTime? _tryParseDate(String? value) {
    if (value == null || value.isEmpty) return null;
    try {
      return DateTime.parse(value);
    } catch (_) {
      return null;
    }
  }

  String _formatDisplayDate(String? value) {
    return _formatDisplayDateFromDateTime(_tryParseDate(value));
  }

  String _formatDisplayDateFromDateTime(DateTime? value, {bool useEmptyPlaceholder = false}) {
    const monthNames = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ];
    if (value == null) {
      return useEmptyPlaceholder ? 'dd-mm-yyyy' : 'Not set';
    }
    return '${value.day.toString().padLeft(2, '0')} ${monthNames[value.month - 1]} ${value.year}';
  }

  _StatusMeta _bookingStatusMeta(String? status) {
    switch ((status ?? '').toLowerCase()) {
      case 'confirmed':
        return _StatusMeta('Confirmed', Colors.green);
      case 'completed':
        return _StatusMeta('Completed', Colors.blue);
      case 'cancelled':
        return _StatusMeta('Cancelled', Colors.red);
      case 'in_progress':
      case 'started':
        return _StatusMeta('In Progress', Colors.orange);
      default:
        return _StatusMeta('Pending', Colors.grey);
    }
  }

  _StatusMeta _paymentStatusMeta(String? status) {
    switch ((status ?? '').toLowerCase()) {
      case 'paid':
      case 'completed':
        return _StatusMeta('Paid', Colors.green);
      case 'failed':
        return _StatusMeta('Failed', Colors.red);
      default:
        return _StatusMeta('Pending', Colors.orange);
    }
  }

  Widget _buildStatusChip(String label, Color color, {IconData? icon}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (icon != null) ...[
            Icon(icon, size: 14, color: color),
            const SizedBox(width: 4),
          ],
          Text(
            label,
            style: GoogleFonts.poppins(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPlanBadge(String text) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: const Color(0xFFE0F7FA),
        borderRadius: BorderRadius.circular(24),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.autorenew, size: 14, color: Color(0xFF00796B)),
          const SizedBox(width: 4),
          Text(
            text,
            style: GoogleFonts.poppins(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF00796B),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSubscriptionInfoRow({
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.grey.shade600),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: GoogleFonts.poppins(
                    fontSize: 12,
                    color: Colors.grey.shade500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  value,
                  style: GoogleFonts.poppins(
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey.shade900,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMonthlyTimelineSection(DateTime? start, DateTime? end, List<String> serviceDays, {DateTime? selectedFromDate, DateTime? selectedToDate}) {
    final startLabel = _formatDisplayDateFromDateTime(start);
    final endLabel = _formatDisplayDateFromDateTime(end);
    
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Service Timeline',
              style: GoogleFonts.poppins(
                fontSize: 15,
                fontWeight: FontWeight.w600,
                color: Colors.grey.shade900,
              ),
            ),
            const SizedBox(height: 16),
            // Calendar Widget
            if (start != null && end != null)
              _buildServiceCalendar(start, end, selectedFromDate: selectedFromDate, selectedToDate: selectedToDate)
            else
              Text(
                'Dates not available',
                style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600),
              ),
            const SizedBox(height: 16),
            // Service Start - Green Mark
            Row(
              children: [
                Container(
                  width: 20,
                  height: 20,
                  decoration: BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                    border: Border.all(color: Colors.white, width: 2),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.green.withOpacity(0.3),
                        blurRadius: 4,
                        spreadRadius: 1,
                      ),
                    ],
                  ),
                  child: const Icon(Icons.check, size: 12, color: Colors.white),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Service Start: $startLabel',
                    style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade700),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            // Service End - Blue Mark
            Row(
              children: [
                Container(
                  width: 20,
                  height: 20,
                  decoration: BoxDecoration(
                    color: Colors.blue.shade600,
                    shape: BoxShape.circle,
                    border: Border.all(color: Colors.white, width: 2),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.blue.withOpacity(0.3),
                        blurRadius: 4,
                        spreadRadius: 1,
                      ),
                    ],
                  ),
                  child: const Icon(Icons.flag, size: 12, color: Colors.white),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Service End: $endLabel',
                    style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade700),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildServiceCalendar(DateTime startDate, DateTime endDate, {DateTime? selectedFromDate, DateTime? selectedToDate}) {
    // Determine which month to show (prefer the month containing start date)
    final displayMonth = DateTime(startDate.year, startDate.month, 1);
    final firstDayOfMonth = displayMonth;
    final lastDayOfMonth = DateTime(displayMonth.year, displayMonth.month + 1, 0);
    
    // Check if end date is in a different month
    final isEndDateInDifferentMonth = endDate.year != displayMonth.year || 
        endDate.month != displayMonth.month;
    
    // Get the first day of the week for the calendar (Monday = 1, Sunday = 7)
    int firstDayWeekday = firstDayOfMonth.weekday;
    // Convert to Sunday = 0 format
    int firstDayOffset = firstDayWeekday % 7;
    
    // Calculate days in month
    final daysInMonth = lastDayOfMonth.day;
    
    // Month names
    final monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'];
    final weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey.shade50,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Column(
        children: [
          // Month header
          Container(
            padding: const EdgeInsets.symmetric(vertical: 12),
            decoration: BoxDecoration(
              color: _tealColor.withOpacity(0.1),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Column(
              children: [
                Text(
                  '${monthNames[displayMonth.month - 1]} ${displayMonth.year}',
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey.shade900,
                  ),
                ),
                if (isEndDateInDifferentMonth)
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      'End date: ${monthNames[endDate.month - 1]} ${endDate.day}, ${endDate.year}',
                      style: GoogleFonts.poppins(
                        fontSize: 11,
                        color: Colors.blue.shade700,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
              ],
            ),
          ),
          // Week day headers
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 8),
            child: Row(
              children: weekDays.map((day) {
                return Expanded(
                  child: Center(
                    child: Text(
                      day,
                      style: GoogleFonts.poppins(
                        fontSize: 11,
                        fontWeight: FontWeight.w600,
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          ),
          // Calendar grid
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
            child: Column(
              children: [
                // First row (may have empty cells)
                Row(
                  children: List.generate(7, (index) {
                    if (index < firstDayOffset) {
                      return const Expanded(child: SizedBox());
                    }
                    final day = index - firstDayOffset + 1;
                    return _buildCalendarDay(day, startDate, endDate, displayMonth, selectedFromDate: selectedFromDate, selectedToDate: selectedToDate);
                  }),
                ),
                // Remaining rows
                ...List.generate((daysInMonth - (7 - firstDayOffset) + 6) ~/ 7, (rowIndex) {
                  return Row(
                    children: List.generate(7, (colIndex) {
                      final day = (7 - firstDayOffset) + (rowIndex * 7) + colIndex + 1;
                      if (day > daysInMonth) {
                        return const Expanded(child: SizedBox());
                      }
                      return _buildCalendarDay(day, startDate, endDate, displayMonth, selectedFromDate: selectedFromDate, selectedToDate: selectedToDate);
                    }),
                  );
                }),
              ],
            ),
          ),
          // Legend
          Padding(
            padding: const EdgeInsets.all(8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                _buildCalendarLegendItem(Colors.green, 'Start'),
                const SizedBox(width: 16),
                _buildCalendarLegendItem(Colors.blue.shade600, 'End'),
                const SizedBox(width: 16),
                _buildCalendarLegendItem(_tealColor.withOpacity(0.2), 'Active'),
                if (selectedFromDate != null || selectedToDate != null) ...[
                  const SizedBox(width: 16),
                  _buildCalendarLegendItem(Colors.red, 'Selected'),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCalendarLegendItem(Color color, String label) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 16,
          height: 16,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
            border: color == Colors.green || color == Colors.blue.shade600
                ? Border.all(color: Colors.white, width: 1)
                : null,
          ),
        ),
        const SizedBox(width: 6),
        Text(
          label,
          style: GoogleFonts.poppins(
            fontSize: 11,
            color: Colors.grey.shade700,
          ),
        ),
      ],
    );
  }

  Widget _buildCalendarDay(int day, DateTime startDate, DateTime endDate, DateTime displayMonth, {DateTime? selectedFromDate, DateTime? selectedToDate}) {
    final currentDate = DateTime(displayMonth.year, displayMonth.month, day);
    final isStartDate = currentDate.year == startDate.year &&
        currentDate.month == startDate.month &&
        currentDate.day == startDate.day;
    final isEndDate = currentDate.year == endDate.year &&
        currentDate.month == endDate.month &&
        currentDate.day == endDate.day;
    final isInRange = currentDate.isAfter(startDate.subtract(const Duration(days: 1))) &&
        currentDate.isBefore(endDate.add(const Duration(days: 1)));
    final isToday = currentDate.year == DateTime.now().year &&
        currentDate.month == DateTime.now().month &&
        currentDate.day == DateTime.now().day;
    
    // Check if this date matches selected from date or to date
    final isSelectedFromDate = selectedFromDate != null &&
        currentDate.year == selectedFromDate.year &&
        currentDate.month == selectedFromDate.month &&
        currentDate.day == selectedFromDate.day;
    final isSelectedToDate = selectedToDate != null &&
        currentDate.year == selectedToDate.year &&
        currentDate.month == selectedToDate.month &&
        currentDate.day == selectedToDate.day;
    
    // Check if this date is in the selected range (from date to to date, inclusive)
    final isInSelectedRange = selectedFromDate != null && selectedToDate != null &&
        currentDate.isAfter(selectedFromDate.subtract(const Duration(days: 1))) &&
        currentDate.isBefore(selectedToDate.add(const Duration(days: 1)));
    
    Color backgroundColor = Colors.transparent;
    Color textColor = Colors.grey.shade800;
    Widget? indicator;
    Border? border;
    
    if (isStartDate) {
      backgroundColor = Colors.green;
      textColor = Colors.white;
      indicator = const Icon(Icons.play_arrow, size: 12, color: Colors.white);
    } else if (isEndDate) {
      backgroundColor = Colors.blue.shade600;
      textColor = Colors.white;
      indicator = const Icon(Icons.flag, size: 12, color: Colors.white);
    } else if (isInRange) {
      backgroundColor = _tealColor.withOpacity(0.2);
      textColor = Colors.grey.shade800;
    } else if (isToday) {
      backgroundColor = Colors.grey.shade200;
      textColor = Colors.grey.shade800;
    }
    
    // Add red border for selected from/to dates and all dates in the selected range
    if (isSelectedFromDate || isSelectedToDate || isInSelectedRange) {
      border = Border.all(color: Colors.red, width: 3);
    }
    
    return Expanded(
      child: Container(
        margin: const EdgeInsets.all(2),
        height: 40,
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(8),
          border: border ?? (isToday && !isStartDate && !isEndDate && !isSelectedFromDate && !isSelectedToDate && !isInSelectedRange
              ? Border.all(color: _tealColor, width: 1.5)
              : null),
        ),
        child: Stack(
          alignment: Alignment.center,
          children: [
            Text(
              day.toString(),
              style: GoogleFonts.poppins(
                fontSize: 13,
                fontWeight: isStartDate || isEndDate ? FontWeight.w700 : FontWeight.w500,
                color: textColor,
              ),
            ),
            if (indicator != null)
              Positioned(
                bottom: 2,
                child: indicator,
              ),
            // Red mark for selected dates and all dates in the selected range (always visible, even if there's another indicator)
            if (isSelectedFromDate || isSelectedToDate || isInSelectedRange)
              Positioned(
                top: 2,
                right: 2,
                child: Container(
                  width: 10,
                  height: 10,
                  decoration: const BoxDecoration(
                    color: Colors.red,
                    shape: BoxShape.circle,
                    boxShadow: [
                      BoxShadow(
                        color: Colors.red,
                        blurRadius: 4,
                        spreadRadius: 1,
                      ),
                    ],
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildTimelineDots({int totalSlots = 18, required int highlightedSlots}) {
    return Wrap(
      spacing: 6,
      runSpacing: 6,
      children: List.generate(totalSlots, (index) {
        late Color color;
        if (index == 0) {
          color = Colors.green;
        } else if (index == totalSlots - 1) {
          color = Colors.blue.shade600;
        } else if (index <= highlightedSlots) {
          color = _tealColor.withOpacity(0.9);
        } else {
          color = Colors.grey.shade300;
        }
        return Container(
          width: 18,
          height: 18,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
          ),
        );
      }),
    );
  }

  Widget _buildEditableMonthlyWindowSection(Map<String, dynamic> booking, DateTime? from, DateTime? to) {
    return _EditableMonthlyWindowSection(
      booking: booking,
      initialFromDate: from,
      initialToDate: to,
      initialReason: booking['delay_reason']?.toString() ?? '',
    );
  }

  Widget _buildReadOnlyField({
    required String label,
    required String value,
    IconData? icon,
    bool alignTop = false,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: Colors.grey.shade600,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 6),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey.shade300),
          ),
          child: Row(
            crossAxisAlignment: alignTop ? CrossAxisAlignment.start : CrossAxisAlignment.center,
            children: [
              Icon(icon ?? Icons.notes, size: 18, color: Colors.grey.shade600),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  value,
                  style: GoogleFonts.poppins(
                    fontSize: 13,
                    color: Colors.grey.shade800,
                  ),
                  maxLines: alignTop ? 3 : 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  List<String> _extractServiceDays(Map<String, dynamic>? details) {
    if (details == null || details['service_days'] == null) return [];
    final value = details['service_days'];
    if (value is List) {
      return value.map((e) => e.toString()).toList();
    }
    if (value is String && value.isNotEmpty) {
      try {
        final decoded = jsonDecode(value);
        if (decoded is List) {
          return decoded.map((e) => e.toString()).toList();
        }
      } catch (_) {
        return value.split(',').map((e) => e.trim()).toList();
      }
    }
    return [];
  }

  Widget _buildImagePlaceholder({double? height, double? width}) {
    return Container(
      width: width ?? 90,
      height: height ?? 90,
      decoration: BoxDecoration(
        color: Colors.grey.shade200,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Icon(
        Icons.cleaning_services,
        size: 32,
        color: Colors.grey.shade500,
      ),
    );
  }

  Widget _buildBookingDetailRow(IconData icon, String text) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, size: 16, color: Colors.grey.shade600),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            text,
            style: GoogleFonts.poppins(
              fontSize: 13,
              color: Colors.grey.shade800,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildServicesTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Our Services',
            style: GoogleFonts.poppins(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Colors.grey.shade800,
            ),
          ),
          const SizedBox(height: 16),
          _buildServiceCard('Consultation Service', 'Expert consultation for your needs', Icons.chat),
          const SizedBox(height: 12),
          _buildServiceCard('Technical Support', '24/7 technical assistance', Icons.support),
          const SizedBox(height: 12),
          _buildServiceCard('Maintenance', 'Regular maintenance services', Icons.build),
          const SizedBox(height: 12),
          _buildServiceCard('Installation', 'Professional installation services', Icons.settings),
          const SizedBox(height: 12),
          _buildServiceCard('Training', 'Comprehensive training programs', Icons.school),
          const SizedBox(height: 12),
          _buildServiceCard('Custom Development', 'Tailored solutions for you', Icons.code),
        ],
      ),
    );
  }

  // Helper method to get profile image URL
  String? _getProfileImageUrl() {
    final profileImage = _userData?['profile_image'];
    if (profileImage == null) return null;
    
    final profileImageStr = profileImage.toString().trim();
    if (profileImageStr.isEmpty || 
        profileImageStr == 'null' || 
        profileImageStr == 'NULL') {
      return null;
    }
    
    // Use optimized resolver
    return _resolveProfileImageValue(profileImage);
  }

  // Helper method to get proxy URL for profile images
  String _getProfileProxyUrl(String url) {
    final encodedUrl = Uri.encodeComponent(url);
    return 'https://superdailys.com/superdailyapp/proxy_image.php?url=$encodedUrl';
  }

  // Widget to build profile picture with size parameter
  Widget _buildProfilePicture({double radius = 50, Color? backgroundColor, Color? iconColor}) {
    final profileImageUrl = _getProfileImageUrl();
    final bgColor = backgroundColor ?? Colors.white;
    final icColor = iconColor ?? _tealColor;
    
    return CircleAvatar(
      radius: radius,
      backgroundColor: bgColor,
      child: profileImageUrl != null
          ? _ProfileImageWidget(
              imageUrl: profileImageUrl,
              radius: radius,
              backgroundColor: bgColor,
              iconColor: icColor,
              userId: _userData?['id'],
              cacheBuster: _profileImageCacheBuster,
            )
          : Icon(
              Icons.person,
              size: radius,
              color: icColor,
            ),
    );
  }

  Widget _buildProfileTab() {
    final bool isLoggedIn = _userData != null;
    final String displayName = (_userData?['name']?.toString().trim().isNotEmpty ?? false)
        ? _userData!['name'].toString()
        : 'Guest Explorer';
    final String displayPhone = (_userData?['phone']?.toString().trim().isNotEmpty ?? false)
        ? _userData!['phone'].toString()
        : 'Tap login to personalize your experience';
    final String? displayEmail = _userData?['email']?.toString();
    final int totalFavorites = _favoriteProductCount + _favoriteServiceCount;
    final int totalBookings = _myBookings.length;
    final int totalOrders = _myOrders.length;
    final double completionScore = _calculateProfileCompletionScore();

    return Container(
      color: _profileSectionBg,
      child: SingleChildScrollView(
        padding: const EdgeInsets.only(bottom: 32),
        child: Column(
          children: [
            Container(
              width: double.infinity,
              padding: const EdgeInsets.fromLTRB(16, 48, 16, 140),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    _tealColor,
                    const Color(0xFF00A692),
                  ],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
                borderRadius: const BorderRadius.only(
                  bottomLeft: Radius.circular(32),
                  bottomRight: Radius.circular(32),
                ),
              ),
              child: Stack(
                children: [
                  Positioned(
                    right: -20,
                    top: -30,
                    child: Container(
                      width: 180,
                      height: 180,
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.08),
                        shape: BoxShape.circle,
                      ),
                    ),
                  ),
                  Positioned(
                    left: -30,
                    bottom: 20,
                    child: Container(
                      width: 120,
                      height: 120,
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.05),
                        shape: BoxShape.circle,
                      ),
                    ),
                  ),
                  Column(
                    children: [
                      _buildProfileHeroCard(
                        name: displayName,
                        phone: displayPhone,
                        email: displayEmail,
                        isLoggedIn: isLoggedIn,
                        completionScore: completionScore,
                      ),
                    ],
                  ),
                ],
              ),
            ),
            Transform.translate(
              offset: const Offset(0, -110),
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Column(
                  children: [
                    _buildProfileStatsRow(
                      bookingsCount: totalBookings,
                      favoriteCount: totalFavorites,
                      ordersCount: totalOrders,
                      completionScore: completionScore,
                    ),
                    const SizedBox(height: 24),
                    _buildProfileSection(
                      title: 'Account',
                      children: [
                        _buildProfileMenuItem(Icons.edit_outlined, 'Edit Profile', () {
                          if (isLoggedIn) {
                            _showEditProfileDialog();
                          } else {
                            _showAuthRequiredSnack('Please login to edit profile');
                          }
                        }),
                        _buildProfileMenuItem(Icons.shopping_cart_outlined, 'My Orders', () {
                          if (isLoggedIn) {
                            Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder: (context) => MyOrdersScreen(userData: _userData!),
                              ),
                            );
                          } else {
                            _showAuthRequiredSnack('Please login to view your orders');
                          }
                        }),
                        _buildProfileMenuItem(Icons.favorite_border, 'Favorites', () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => FavoritesScreen(userData: _userData),
                            ),
                          );
                        }),
                      ],
                    ),
                    _buildProfileSection(
                      title: 'Support & Settings',
                      children: [
                        _buildProfileMenuItem(Icons.settings, 'Settings', () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => const SettingsScreen(),
                            ),
                          );
                        }),
                        _buildProfileMenuItem(Icons.help_outline, 'Help & Support', () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => const HelpSupportScreen(),
                            ),
                          );
                        }),
                        if (_userData != null)
                          _buildProfileMenuItem(Icons.logout, 'Logout', () async {
                            final prefs = await SharedPreferences.getInstance();
                            await prefs.setBool('isLoggedIn', false);
                            await prefs.remove('userData');
                            await prefs.remove('pendingServiceId');
                            await prefs.remove('pendingProductId');
                            await prefs.remove('favorite_products');
                            await prefs.remove('favorite_services');

                            if (mounted) {
                              setState(() {
                                _favoriteProductCount = 0;
                                _favoriteServiceCount = 0;
                              });
                              Navigator.pushReplacement(
                                context,
                                MaterialPageRoute(builder: (context) => const AuthWrapper()),
                              );
                            }
                          })
                        else
                          _buildProfileMenuItem(Icons.login, 'Login', () {
                            if (mounted) {
                              Navigator.pushReplacement(
                                context,
                                MaterialPageRoute(builder: (context) => const LoginPage()),
                              );
                            }
                          }),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  double _calculateProfileCompletionScore() {
    if (_userData == null) {
      return 0.35;
    }
    double score = 0.55;
    if ((_userData?['email']?.toString().trim().isNotEmpty ?? false)) {
      score += 0.15;
    }
    if ((_userData?['address']?.toString().trim().isNotEmpty ?? false)) {
      score += 0.15;
    }
    if ((_userData?['phone']?.toString().trim().isNotEmpty ?? false)) {
      score += 0.15;
    }
    return score.clamp(0.4, 1.0);
  }

  Widget _buildProfileHeroCard({
    required String name,
    required String phone,
    String? email,
    required bool isLoggedIn,
    required double completionScore,
  }) {
    final String badgeLabel = isLoggedIn ? 'Loyal member' : 'Guest mode';
    final Color badgeColor =
        isLoggedIn ? const Color(0xFFFFF3B0) : Colors.white.withOpacity(0.55);

    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(28),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 40,
            offset: const Offset(0, 18),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Stack(
                clipBehavior: Clip.none,
                children: [
                  Container(
                    padding: const EdgeInsets.all(4),
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: [
                          Colors.white,
                          _tealLight,
                        ],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                      shape: BoxShape.circle,
                    ),
                    child: SizedBox(
                      width: 80,
                      height: 80,
                      child: _buildProfilePicture(
                        radius: 34,
                        backgroundColor: Colors.white,
                        iconColor: _tealColor,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      name,
                      style: GoogleFonts.poppins(
                        fontSize: 20,
                        fontWeight: FontWeight.w700,
                        color: Colors.grey.shade900,
                      ),
                    ),
                    const SizedBox(height: 6),
                    Text(
                      phone,
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        color: Colors.grey.shade600,
                      ),
                    ),
                    if (email != null && email.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        email,
                        style: GoogleFonts.poppins(
                          fontSize: 13,
                          color: Colors.grey.shade500,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              IconButton(
                onPressed: () {
                  if (isLoggedIn) {
                    _showEditProfileDialog();
                  } else {
                    _showAuthRequiredSnack('Login to personalize your account');
                  }
                },
                icon: Icon(
                  isLoggedIn ? Icons.edit_outlined : Icons.login,
                  color: Colors.grey.shade500,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildProfileBadge({
    required String label,
    required Color background,
    required Color textColor,
    required IconData icon,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(20),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: textColor),
          const SizedBox(width: 6),
          Text(
            label,
            style: GoogleFonts.poppins(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: textColor,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildProfileStatsRow({
    required int bookingsCount,
    required int favoriteCount,
    required int ordersCount,
    required double completionScore,
  }) {
    final int completionPercent = (completionScore * 100).round();
    return Row(
      children: [
        Expanded(
          child: _buildProfileStatCard(
            icon: Icons.event_note,
            label: 'Bookings',
            value: bookingsCount.toString(),
            color: const Color(0xFF7ED1D4),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: _buildProfileStatCard(
            icon: Icons.favorite,
            label: 'Favorites',
            value: favoriteCount.toString(),
            color: const Color(0xFFFFC4D6),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: _buildProfileStatCard(
            icon: Icons.shopping_bag,
            label: 'Your Orders',
            value: ordersCount.toString(),
            color: const Color(0xFFFFE0B2),
          ),
        ),
      ],
    );
  }

  Widget _buildProfileStatCard({
    required IconData icon,
    required String label,
    required String value,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 20,
            offset: const Offset(0, 10),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: color.withOpacity(0.3),
              borderRadius: BorderRadius.circular(14),
            ),
            child: Icon(icon, color: color.withOpacity(0.85), size: 20),
          ),
          const SizedBox(height: 12),
          Text(
            value,
            style: GoogleFonts.poppins(
              fontSize: 20,
              fontWeight: FontWeight.w700,
              color: Colors.grey.shade900,
            ),
          ),
          Text(
            label,
            style: GoogleFonts.poppins(
              fontSize: 13,
              color: Colors.grey.shade500,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildProfileQuickActions(bool isLoggedIn) {
    final List<List<Color>> gradients = [
      _buildThemeGradient(darker: 0.08, lighter: 0.04),
      _buildThemeGradient(darker: 0.04, lighter: 0.12),
      _buildThemeGradient(darker: 0.12, lighter: 0.06),
    ];

    return Wrap(
      spacing: 12,
      runSpacing: 12,
      children: [
        _buildQuickActionChip(
          icon: Icons.edit_outlined,
          label: 'Edit profile',
          gradientColors: gradients[0],
          onTap: () {
            if (isLoggedIn) {
              _showEditProfileDialog();
            } else {
              _showAuthRequiredSnack('Login to edit your profile');
            }
          },
        ),
        _buildQuickActionChip(
          icon: Icons.support_agent,
          label: 'Need help',
          gradientColors: gradients[1],
          onTap: () {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => const HelpSupportScreen(),
              ),
            );
          },
        ),
        _buildQuickActionChip(
          icon: Icons.settings_outlined,
          label: 'Settings',
          gradientColors: gradients[2],
          onTap: () {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => const SettingsScreen(),
              ),
            );
          },
        ),
      ],
    );
  }

  Widget _buildQuickActionChip({
    required IconData icon,
    required String label,
    required List<Color> gradientColors,
    required VoidCallback onTap,
  }) {
    final Color startColor = gradientColors.first;
    final Color endColor = gradientColors.length > 1
        ? gradientColors.last
        : Color.lerp(startColor, Colors.white, 0.12) ?? startColor;

    return GestureDetector(
      onTap: onTap,
      child: Container(
        constraints: const BoxConstraints(minWidth: 150),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [
              startColor,
              endColor,
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(
              color: startColor.withOpacity(0.3),
              blurRadius: 18,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.25),
                shape: BoxShape.circle,
              ),
              child: Icon(icon, color: Colors.white, size: 18),
            ),
            const SizedBox(width: 10),
            Flexible(
              child: Text(
                label,
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                  color: Colors.white,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<Color> _buildThemeGradient({double darker = 0.0, double lighter = 0.12}) {
    final Color startColor = darker > 0
        ? Color.lerp(_tealColor, Colors.black, darker) ?? _tealColor
        : _tealColor;
    final Color endColor = lighter > 0
        ? Color.lerp(_tealColor, Colors.white, lighter) ?? _tealColor
        : _tealColor;

    return [startColor, endColor];
  }

  Widget _buildProfileSection({
    required String title,
    required List<Widget> children,
  }) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(bottom: 18),
      padding: const EdgeInsets.fromLTRB(18, 20, 18, 12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(26),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 40,
            offset: const Offset(0, 18),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 16,
              fontWeight: FontWeight.w700,
              color: Colors.grey.shade900,
            ),
          ),
          const SizedBox(height: 16),
          for (int i = 0; i < children.length; i++)
            Padding(
              padding: EdgeInsets.only(bottom: i == children.length - 1 ? 0 : 12),
              child: children[i],
            ),
        ],
      ),
    );
  }

  void _showAuthRequiredSnack(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.orange,
      ),
    );
  }

  Widget _buildCategoryCard(IconData icon, String title, Color color) {
    return Container(
      width: 100,
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 40, color: color),
          const SizedBox(height: 8),
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  // Helper function to convert icon string to IconData
  IconData _getIconFromString(String iconName) {
    // Map common icon names to Flutter icons
    switch (iconName.toLowerCase()) {
      case 'shopping_cart':
      case 'cart':
        return Icons.shopping_cart;
      case 'room_service':
      case 'service':
        return Icons.room_service;
      case 'support_agent':
      case 'support':
        return Icons.support_agent;
      case 'local_offer':
      case 'offer':
        return Icons.local_offer;
      case 'category':
        return Icons.category;
      case 'inventory':
        return Icons.inventory;
      case 'phone':
        return Icons.phone;
      case 'email':
        return Icons.email;
      case 'location':
        return Icons.location_on;
      case 'home':
        return Icons.home;
      case 'store':
        return Icons.store;
      default:
        return Icons.category; // Default icon
    }
  }

  // Helper function to parse hex color string to Color
  Color _parseColorFromString(String colorString) {
    try {
      // Remove # if present
      String hex = colorString.replaceAll('#', '');
      // Handle both 6 and 8 character hex codes
      if (hex.length == 6) {
        hex = 'FF$hex'; // Add alpha if missing
      }
      return Color(int.parse(hex, radix: 16));
    } catch (e) {
      // Default to teal color if parsing fails
      return _tealColor;
    }
  }

  Widget _buildCategoryCardFromData(Map<String, dynamic> category) {
    final iconName = category['icon'] ?? 'category';
    final icon = _getIconFromString(iconName);
    final colorString = category['color'] ?? '#00BFA5';
    final color = _parseColorFromString(colorString);
    final name = category['name'] ?? 'Category';
    final image = category['image'] ?? '';

    return Container(
      width: 100,
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Show image if available, otherwise show icon
          if (image != null && image.toString().isNotEmpty)
            ClipRRect(
              borderRadius: BorderRadius.circular(12),
              child: CachedNetworkImage(
                imageUrl: Uri.encodeFull(_resolveImageUrl(image.toString())),
                width: 50,
                height: 50,
                fit: BoxFit.cover,
                placeholder: (context, url) => SizedBox(
                  width: 40,
                  height: 40,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(color),
                  ),
                ),
                errorWidget: (context, url, error) => Icon(icon, size: 40, color: color),
              ),
            )
          else
            Icon(icon, size: 40, color: color),
          const SizedBox(height: 8),
          Text(
            name,
            style: GoogleFonts.poppins(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: color,
            ),
            textAlign: TextAlign.center,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

  // Helper function to parse price value
  double? _parsePrice(dynamic priceValue) {
    if (priceValue == null || priceValue == '' || priceValue == 'null') return null;
    if (priceValue is String) {
      String s = priceValue.trim();
      // Remove currency symbols, commas, and any non-numeric (keep first dot and minus)
      s = s.replaceAll(RegExp(r'[â‚¹$,]'), '');
      s = s.replaceAll(RegExp(r'[^0-9\.-]'), '');
      // If multiple dots, keep first
      final firstDot = s.indexOf('.');
      if (firstDot != -1) {
        final before = s.substring(0, firstDot + 1);
        final after = s.substring(firstDot + 1).replaceAll('.', '');
        s = before + after;
      }
      if (s.isEmpty || s == '-' || s == '.') return null;
      return double.tryParse(s);
    } else if (priceValue is num) {
      return priceValue.toDouble();
    }
    return null;
  }

  // Helper function to get the appropriate price based on service type
  double? _getServicePrice(Map<String, dynamic> service) {
    final name = (service['name'] ?? '').toString().toLowerCase();
    final subcategory = (service['subcategory'] ?? '').toString().toLowerCase();
    final mainCategory = (service['main_category'] ?? '').toString().toLowerCase();
    final propertyType = (service['property_type'] ?? '').toString().toLowerCase();
    final personsCount = service['persons_count'];

    // Check if this is a monthly subscription service
    final isMonthlySubscription = mainCategory.contains('monthly') || mainCategory.contains('subscription');

    // Determine service type from name or subcategory
    final isWashroomCleaning = name.contains('washroom') || subcategory.contains('washroom');
    final isHouseCleaning = name.contains('house cleaning') || name.contains('home cleaning') || 
                           subcategory.contains('house') || subcategory.contains('home') ||
                           (!isWashroomCleaning && (name.contains('cleaning') || subcategory.contains('cleaning')));
    final isSuperCleaning = name.contains('super cleaning') || subcategory.contains('super cleaning');
    final isCooking = name.contains('chef') || name.contains('cooking') || 
                     subcategory.contains('chef') || subcategory.contains('cooking');

    // 1. WASHROOM CLEANING - Use washroom prices (priority order)
    if (isWashroomCleaning) {
      final washroom2Price = _parsePrice(service['price_2_washroom']);
      final washroom3Price = _parsePrice(service['price_3_washroom']);
      final washroom4Price = _parsePrice(service['price_4_washroom']);
      final washroom4PlusPrice = _parsePrice(service['price_4_plus_washroom']);
      
      // Return first available washroom price
      if (washroom2Price != null && washroom2Price > 0) return washroom2Price;
      if (washroom3Price != null && washroom3Price > 0) return washroom3Price;
      if (washroom4Price != null && washroom4Price > 0) return washroom4Price;
      if (washroom4PlusPrice != null && washroom4PlusPrice > 0) return washroom4PlusPrice;
    }

    // 2. HOUSE CLEANING / SUPER CLEANING - Use BHK prices
    if (isHouseCleaning || isSuperCleaning) {
      // Check property_type first
      if (propertyType.isNotEmpty) {
        if (propertyType.contains('1') || propertyType.contains('1bhk')) {
          final bhk1Price = _parsePrice(service['price_1_bhk']);
          if (bhk1Price != null && bhk1Price > 0) return bhk1Price;
        }
        if (propertyType.contains('2') || propertyType.contains('2bhk')) {
          final bhk2Price = _parsePrice(service['price_2_bhk']);
          if (bhk2Price != null && bhk2Price > 0) return bhk2Price;
        }
        if (propertyType.contains('3') || propertyType.contains('3bhk')) {
          final bhk3Price = _parsePrice(service['price_3_bhk']);
          if (bhk3Price != null && bhk3Price > 0) return bhk3Price;
        }
        if (propertyType.contains('4') || propertyType.contains('4bhk')) {
          final bhk4Price = _parsePrice(service['price_4_bhk']);
          if (bhk4Price != null && bhk4Price > 0) return bhk4Price;
        }
      }
      
      // If property_type not available, return first available BHK price
      final bhk1Price = _parsePrice(service['price_1_bhk']);
      final bhk2Price = _parsePrice(service['price_2_bhk']);
      final bhk3Price = _parsePrice(service['price_3_bhk']);
      final bhk4Price = _parsePrice(service['price_4_bhk']);
      
      if (bhk1Price != null && bhk1Price > 0) return bhk1Price;
      if (bhk2Price != null && bhk2Price > 0) return bhk2Price;
      if (bhk3Price != null && bhk3Price > 0) return bhk3Price;
      if (bhk4Price != null && bhk4Price > 0) return bhk4Price;
    }

    // 3. COOKING / CHEF SERVICES - Use person-based prices or cooking_price
    if (isCooking) {
      // First check cooking_price
      final cookingPrice = _parsePrice(service['cooking_price']);
      if (cookingPrice != null && cookingPrice > 0) return cookingPrice;

      // Then check person count prices
      if (personsCount != null) {
        final count = personsCount is String ? int.tryParse(personsCount) : (personsCount is num ? personsCount.toInt() : null);
        if (count != null) {
          if (count == 1) {
            final price1 = _parsePrice(service['price_1_person']);
            if (price1 != null && price1 > 0) return price1;
          } else if (count == 2) {
            final price2 = _parsePrice(service['price_2_persons']);
            if (price2 != null && price2 > 0) return price2;
          } else if (count >= 1 && count <= 2) {
            final price12 = _parsePrice(service['price_1_2_persons']);
            if (price12 != null && price12 > 0) return price12;
          } else if (count >= 2 && count <= 5) {
            final price25 = _parsePrice(service['price_2_5_persons']);
            if (price25 != null && price25 > 0) return price25;
          } else if (count >= 5 && count <= 10) {
            final price510 = _parsePrice(service['price_5_10_persons']);
            if (price510 != null && price510 > 0) return price510;
          } else if (count > 10) {
            final price10Plus = _parsePrice(service['price_10_plus_persons']);
            if (price10Plus != null && price10Plus > 0) return price10Plus;
          }
        }
      }
      
      // Return first available person-based price
      final price1 = _parsePrice(service['price_1_person']);
      final price2 = _parsePrice(service['price_2_persons']);
      final price12 = _parsePrice(service['price_1_2_persons']);
      if (price1 != null && price1 > 0) return price1;
      if (price2 != null && price2 > 0) return price2;
      if (price12 != null && price12 > 0) return price12;
    }

    // 4. MONTHLY SUBSCRIPTION - Check ALL price columns and return first valid price
    if (isMonthlySubscription) {
      // FIRST: Check monthly_plan_price (specific to monthly subscriptions)
      final monthlyPlanPrice = _parsePrice(service['monthly_plan_price']);
      if (monthlyPlanPrice != null && monthlyPlanPrice > 0) {
        print('Monthly Subscription $name: Using monthly_plan_price = $monthlyPlanPrice');
        return monthlyPlanPrice;
      }
      
      // Create a list of all price columns to check
      List<Map<String, dynamic>> priceChecks = [];
      
      // Add property-specific prices if property_type matches
      if (propertyType.isNotEmpty) {
        if (propertyType.contains('1') || propertyType.contains('1bhk')) {
          priceChecks.add({'key': 'price_1_bhk', 'priority': 1});
        }
        if (propertyType.contains('2') || propertyType.contains('2bhk')) {
          priceChecks.add({'key': 'price_2_bhk', 'priority': 1});
        }
        if (propertyType.contains('3') || propertyType.contains('3bhk')) {
          priceChecks.add({'key': 'price_3_bhk', 'priority': 1});
        }
        if (propertyType.contains('4') || propertyType.contains('4bhk')) {
          priceChecks.add({'key': 'price_4_bhk', 'priority': 1});
        }
      }
      
      // Add person count specific prices
      if (personsCount != null) {
        final count = personsCount is String ? int.tryParse(personsCount) : (personsCount is num ? personsCount.toInt() : null);
        if (count != null) {
          if (count == 1) priceChecks.add({'key': 'price_1_person', 'priority': 2});
          if (count == 2) priceChecks.add({'key': 'price_2_persons', 'priority': 2});
          if (count >= 1 && count <= 2) priceChecks.add({'key': 'price_1_2_persons', 'priority': 2});
          if (count >= 2 && count <= 5) priceChecks.add({'key': 'price_2_5_persons', 'priority': 2});
          if (count >= 5 && count <= 10) priceChecks.add({'key': 'price_5_10_persons', 'priority': 2});
          if (count > 10) priceChecks.add({'key': 'price_10_plus_persons', 'priority': 2});
        }
      }
      
      // Check service-specific prices
      if (isWashroomCleaning || name.contains('washroom')) {
        priceChecks.addAll([
          {'key': 'price_2_washroom', 'priority': 3},
          {'key': 'price_3_washroom', 'priority': 3},
          {'key': 'price_4_washroom', 'priority': 3},
          {'key': 'price_4_plus_washroom', 'priority': 3},
        ]);
      }
      
      if (isCooking || name.contains('chef') || name.contains('cooking')) {
        priceChecks.add({'key': 'cooking_price', 'priority': 4});
      }
      
      if (isHouseCleaning || isSuperCleaning || name.contains('cleaning')) {
        priceChecks.add({'key': 'cleaning_price', 'priority': 4});
      }
      
      // Sort by priority and check
      priceChecks.sort((a, b) => a['priority'].compareTo(b['priority']));
      for (var check in priceChecks) {
        final price = _parsePrice(service[check['key']]);
        if (price != null && price > 0) {
          print('Monthly Subscription $name: Using ${check['key']} = $price');
          return price;
        }
      }
      
      // Check ALL price columns systematically (fallback)
      final allPriceColumns = [
        'cleaning_price',
        'cooking_price',
        'price_1_bhk', 'price_2_bhk', 'price_3_bhk', 'price_4_bhk',
        'price_1_person', 'price_2_persons', 'price_1_2_persons',
        'price_2_5_persons', 'price_5_10_persons', 'price_10_plus_persons',
        'price_2_washroom', 'price_3_washroom', 'price_4_washroom', 'price_4_plus_washroom',
        'price', // Base price last
      ];
      
      for (var column in allPriceColumns) {
        final price = _parsePrice(service[column]);
        if (price != null && price > 0) {
          print('Monthly Subscription $name: Using $column = $price (fallback)');
          return price;
        }
      }
      
      // If all checks fail, return base price even if 0
      final basePrice = _parsePrice(service['price']);
      if (basePrice != null) {
        print('Monthly Subscription $name: Using base price = $basePrice');
        return basePrice;
      }
    }

    // 5. GENERIC CLEANING - Use cleaning_price or BHK prices
    final cleaningPrice = _parsePrice(service['cleaning_price']);
    if (cleaningPrice != null && cleaningPrice > 0) return cleaningPrice;

    // 6. FALLBACK - Check all person-based prices for any service
    if (personsCount != null) {
      final count = personsCount is String ? int.tryParse(personsCount) : (personsCount is num ? personsCount.toInt() : null);
      if (count != null) {
        if (count == 1) {
          final price1 = _parsePrice(service['price_1_person']);
          if (price1 != null && price1 > 0) return price1;
        } else if (count == 2) {
          final price2 = _parsePrice(service['price_2_persons']);
          if (price2 != null && price2 > 0) return price2;
        } else if (count >= 1 && count <= 2) {
          final price12 = _parsePrice(service['price_1_2_persons']);
          if (price12 != null && price12 > 0) return price12;
        } else if (count >= 2 && count <= 5) {
          final price25 = _parsePrice(service['price_2_5_persons']);
          if (price25 != null && price25 > 0) return price25;
        } else if (count >= 5 && count <= 10) {
          final price510 = _parsePrice(service['price_5_10_persons']);
          if (price510 != null && price510 > 0) return price510;
        } else if (count > 10) {
          final price10Plus = _parsePrice(service['price_10_plus_persons']);
          if (price10Plus != null && price10Plus > 0) return price10Plus;
        }
      }
    }

    // 7. FINAL FALLBACK - Use base price (ALWAYS show this)
    final basePrice = _parsePrice(service['price']);
    if (basePrice != null) return basePrice; // Return even if 0, to show it's from database

    return null;
  }

  String _resolveServiceImageUrl(String raw) {
    if (raw.isEmpty) return raw;
    String p = raw.trim();
    // Normalize slashes
    p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
    
    // Already absolute URL starting with https://superdailys.com/storage/services/
    if (p.startsWith('https://superdailys.com/storage/services/')) {
      return p;
    }
    
    // Handle URLs with superdailyapp/storage/services/ and convert to storage/services/
    if (p.contains('/superdailyapp/storage/services/')) {
      final filename = p.split('/').last.split('?').first.split('#').first;
      if (filename.isNotEmpty && filename.contains('.')) {
        return 'https://superdailys.com/storage/services/' + filename;
      }
    }
    
    // Handle Hostinger file server URLs - convert to regular domain (since those are failing)
    if (p.contains('srv1881-files.hstgr.io')) {
      final filename = p.split('/').last.split('?').first.split('#').first;
      if (filename.isNotEmpty && filename.contains('.')) {
        return 'https://superdailys.com/storage/services/' + filename;
      }
    }
    
    // Already absolute URL (any other URL)
    if (p.startsWith('http://') || p.startsWith('https://')) {
      // If it's a full URL but not from the storage/services path, try to extract filename
      if (!p.contains('/storage/services/')) {
        final filename = p.split('/').last.split('?').first.split('#').first;
        if (filename.isNotEmpty && filename.contains('.')) {
          return 'https://superdailys.com/storage/services/' + filename;
        }
      }
      return p;
    }
    
    // Extract just the filename from the path
    String filename = p.split('/').last.split('\\').last;
    // Remove query parameters and hash
    filename = filename.split('?').first.split('#').first;
    
    // If filename is empty or doesn't have extension, try to find it
    if (filename.isEmpty || !filename.contains('.')) {
      // Try to find filename in the path
      final parts = p.split('/');
      for (var part in parts.reversed) {
        if (part.contains('.') && part.length > 3) {
          filename = part.split('?').first.split('#').first;
          break;
        }
      }
    }
    
    // Build full URL - use same as monthly subscription (which works)
    if (filename.isNotEmpty && filename.contains('.')) {
      final url = 'https://superdailys.com/storage/services/' + filename;
      debugPrint('Resolved service image URL: $url');
      return url;
    }
    
    return '';
  }

  Widget _buildOneTimeServiceCard(Map<String, dynamic> service) {
    final name = service['name'] ?? 'Service';
    final description = service['description'] ?? '';
    
    // Collect all available service images (image, image_2, image_3, image_4)
    final List<String> serviceImages = [];
    debugPrint('ðŸ” Service "$name" - Checking for images...');
    debugPrint('   Raw service data - image: ${service['image']}, image_2: ${service['image_2']}, image_3: ${service['image_3']}, image_4: ${service['image_4']}');
    
    for (var imgKey in ['image', 'image_2', 'image_3', 'image_4']) {
      final imgValue = service[imgKey];
      debugPrint('   Checking $imgKey: ${imgValue != null ? imgValue.toString() : "null"}');
      
      if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
        final rawUrl = imgValue.toString().trim();
        debugPrint('   Raw URL from $imgKey: $rawUrl');
        
        // If it's already a valid HTTPS URL starting with superdailys.com/storage/services/, use it directly
        if (rawUrl.startsWith('https://superdailys.com/storage/services/')) {
          serviceImages.add(rawUrl);
          debugPrint('âœ… Service "$name" - Added direct URL from $imgKey: $rawUrl');
        } 
        // If it's any other HTTP/HTTPS URL, use it directly too
        else if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
          serviceImages.add(rawUrl);
          debugPrint('âœ… Service "$name" - Added direct URL from $imgKey: $rawUrl');
        } 
        // If it's just a filename or relative path, build the full URL
        else {
          // Extract filename from the path
          String filename = rawUrl.split('/').last.split('\\').last;
          filename = filename.split('?').first.split('#').first;
          
          // Build full URL
          if (filename.isNotEmpty && filename.contains('.')) {
            final fullUrl = 'https://superdailys.com/storage/services/' + filename;
            serviceImages.add(fullUrl);
            debugPrint('âœ… Service "$name" - Built full URL from $imgKey: $fullUrl (from: $rawUrl)');
          } else {
            debugPrint('âŒ Service "$name" - Invalid filename from $imgKey: $rawUrl');
          }
        }
      } else {
        debugPrint('   $imgKey is empty or null');
      }
    }
    
    debugPrint('ðŸ“Š Service "$name" - Total images collected: ${serviceImages.length}');
    if (serviceImages.isEmpty) {
      debugPrint('âš ï¸ Service "$name" - NO IMAGES FOUND! Service keys: ${service.keys.toList()}');
    }
    
    final priceNumNullable = _getServicePrice(service);
    double finalPriceNum = (priceNumNullable ?? _parsePrice(service['price']) ?? 0.0);
    // Ensure finalPriceNum is always a valid double
    finalPriceNum = finalPriceNum.isNaN || finalPriceNum.isInfinite ? 0.0 : finalPriceNum;
    final priceNum = finalPriceNum;
    final discountPriceNum = _parsePrice(service['discount_price']);
    final finalDiscountPrice = (discountPriceNum != null && discountPriceNum > 0 && !discountPriceNum.isNaN && !discountPriceNum.isInfinite && finalPriceNum > 0 && discountPriceNum < finalPriceNum) ? discountPriceNum : null;
    final displayPrice = (finalDiscountPrice ?? finalPriceNum);
    // Ensure displayPrice is always a valid double
    final double safeDisplayPrice = displayPrice.isNaN || displayPrice.isInfinite ? 0.0 : displayPrice;
    final hasDiscount = finalDiscountPrice != null;

    final card = Container(
      width: 160,
      constraints: const BoxConstraints(maxWidth: 160),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [BoxShadow(color: Colors.grey.withOpacity(0.1), blurRadius: 10, offset: const Offset(0, 4))],
      ),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.min, children: [
        Stack(
          children: [
            Container(
              width: 160,
              height: 130,
              decoration: BoxDecoration(
                gradient: LinearGradient(colors: [_tealLight, _tealLighter]),
                borderRadius: const BorderRadius.only(topLeft: Radius.circular(16), topRight: Radius.circular(16)),
              ),
              child: serviceImages.isNotEmpty
                  ? ClipRRect(
                      borderRadius: const BorderRadius.only(topLeft: Radius.circular(16), topRight: Radius.circular(16)),
                      child: _ServiceImageWidget(
                        key: ValueKey('service_${service['id']}_${serviceImages.join('_')}'), // Unique key to force rebuild
                        imageUrls: serviceImages,
                        serviceName: name,
                      ),
                    )
                  : Container(
                      // Show debug info if no images
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.room_service, size: 40, color: Colors.grey.shade400),
                          if (service['image'] == null && service['image_2'] == null)
                            Padding(
                              padding: const EdgeInsets.all(4.0),
                              child: Text(
                                'No images',
                                style: GoogleFonts.poppins(fontSize: 9, color: Colors.grey.shade500),
                              ),
                            ),
                        ],
                      ),
                    ),
            ),
            Positioned(
              top: 6,
              right: 6,
              child: FutureBuilder<bool>(
                future: _isFavorite('service', service['id'].toString()),
                builder: (context, snapshot) {
                  final isFav = snapshot.data ?? false;
                  return GestureDetector(
                    onTap: () => _toggleFavorite('service', service['id'].toString()),
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.9),
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.1),
                            blurRadius: 4,
                            offset: const Offset(0, 2),
                          ),
                        ],
                      ),
                      child: Icon(
                        isFav ? Icons.favorite : Icons.favorite_border,
                        size: 16,
                        color: isFav ? Colors.red : Colors.grey.shade600,
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 6.0),
          child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.min, children: [
            Text(name, style: GoogleFonts.poppins(fontSize: 11, fontWeight: FontWeight.bold, color: Colors.grey.shade800), maxLines: 1, overflow: TextOverflow.ellipsis),
            const SizedBox(height: 3),
            if (description.isNotEmpty)
              Text(description, style: GoogleFonts.poppins(fontSize: 8, color: Colors.grey.shade600), maxLines: 1, overflow: TextOverflow.ellipsis),
            const SizedBox(height: 4),
            Row(mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.center, children: [
              Flexible(
                flex: 3,
                child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.min, children: [
                  Text('â‚¹' + safeDisplayPrice.toStringAsFixed(2), style: GoogleFonts.poppins(fontSize: 11, fontWeight: FontWeight.bold, color: _priceDarkBlue), maxLines: 1, overflow: TextOverflow.ellipsis),
                  if (hasDiscount && priceNum > safeDisplayPrice)
                    Text('â‚¹' + priceNum.toStringAsFixed(2), style: GoogleFonts.poppins(fontSize: 7, decoration: TextDecoration.lineThrough, color: Colors.grey.shade500), maxLines: 1, overflow: TextOverflow.ellipsis),
                ]),
              ),
              const SizedBox(width: 4),
              Container(padding: const EdgeInsets.all(4), decoration: BoxDecoration(color: _tealColor, borderRadius: BorderRadius.circular(6)), child: const Icon(Icons.add, color: Colors.white, size: 12)),
            ]),
          ]),
        ),
      ]),
    );

    return GestureDetector(
      onTap: () {
        final dynamic rawId = service['id'];
        final int intId = rawId is int ? rawId : int.tryParse(rawId?.toString() ?? '0') ?? 0;
        if (intId > 0) {
          Navigator.push(context, MaterialPageRoute(builder: (context) => ServiceDetailsScreen(serviceId: intId)));
        }
      },
      child: card,
    );
  }

  Widget _buildProductCard(String name, String price, IconData icon, bool isFeatured) {
    return Container(
      width: 200,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
            border: isFeatured
            ? Border.all(color: _tealColor, width: 2)
            : null,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            height: 140,
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [
                  _tealLight,
                  _tealLighter,
                ],
              ),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(16),
                topRight: Radius.circular(16),
              ),
            ),
            child: Center(
              child: Icon(icon, size: 60, color: _tealColor),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (isFeatured)
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: _tealColor,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      'FEATURED',
                      style: GoogleFonts.poppins(
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ),
                if (isFeatured) const SizedBox(height: 8),
                Text(
                  name,
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey.shade800,
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      price,
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: _tealColor,
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.all(6),
                      decoration: BoxDecoration(
                        color: _tealColor,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Icon(Icons.add, color: Colors.white, size: 20),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildProductCardFromData(Map<String, dynamic> product) {
    final sellingPrice = (product['selling_price'] ?? product['price'] ?? 0);
    final mrpPrice = (product['mrp_price'] ?? sellingPrice);
    
    // Get the first available image
    String? imageUrl;
    final images = [
      product['image'],
      product['image_2'],
      product['image_3'],
      product['image_4'],
    ];
    for (var img in images) {
      if (img != null && img.toString().trim().isNotEmpty) {
        imageUrl = _resolveImageUrl(img.toString());
        break;
      }
    }
    
    // Convert to numbers safely - handle null, string, and number types
    double sellingPriceNum = 0.0;
    if (sellingPrice != null) {
      if (sellingPrice is String) {
        sellingPriceNum = double.tryParse(sellingPrice) ?? 0.0;
      } else if (sellingPrice is num) {
        sellingPriceNum = sellingPrice.toDouble();
      }
    }
    
    double mrpPriceNum = sellingPriceNum;
    if (mrpPrice != null) {
      if (mrpPrice is String) {
        mrpPriceNum = double.tryParse(mrpPrice) ?? sellingPriceNum;
      } else if (mrpPrice is num) {
        mrpPriceNum = mrpPrice.toDouble();
      } else {
        mrpPriceNum = sellingPriceNum;
      }
    }
    
    final hasDiscount = mrpPriceNum > sellingPriceNum;
    final productName = product['name'] ?? 'Product';
    
    return GestureDetector(
      onTap: () {
        final productId = product['id'];
        if (productId != null) {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => ProductDetailsScreen(
                productId: productId is int ? productId : int.tryParse(productId.toString()) ?? 0,
                onAddToCart: _addToCart,
                onUpdateCartQuantity: _updateCartQuantity,
                onRemoveFromCart: _removeFromCart,
                onCartUpdated: () {
                  setState(() {}); // Refresh to update cart count
                },
                getCartItemQuantity: _getCartItemQuantity,
                getCartItemCount: _getCartItemCount,
                cartItems: _cartItems,
              ),
            ),
          );
        }
      },
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.1),
              blurRadius: 5,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Product Image with Heart Icon
            Stack(
              children: [
                ClipRRect(
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                  child: Container(
                    height: 150,
                    width: double.infinity,
                    color: _tealLight,
                    child: imageUrl != null && imageUrl.isNotEmpty
                        ? CachedNetworkImage(
                            imageUrl: imageUrl,
                            fit: BoxFit.cover,
                            placeholder: (context, url) => Center(
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation<Color>(_tealColor),
                              ),
                            ),
                            errorWidget: (context, url, error) => Center(
                              child: Icon(Icons.shopping_bag, size: 40, color: _tealColor),
                            ),
                          )
                        : Center(
                            child: Icon(Icons.shopping_bag, size: 40, color: _tealColor),
                          ),
                  ),
                ),
                Positioned(
                  top: 8,
                  right: 8,
                  child: FutureBuilder<bool>(
                    future: _isFavorite('product', product['id'].toString()),
                    builder: (context, snapshot) {
                      final isFav = snapshot.data ?? false;
                      return GestureDetector(
                        onTap: () => _toggleFavorite('product', product['id'].toString()),
                        child: Container(
                          padding: const EdgeInsets.all(6),
                          decoration: BoxDecoration(
                            color: Colors.white.withOpacity(0.9),
                            shape: BoxShape.circle,
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.1),
                                blurRadius: 4,
                                offset: const Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Icon(
                            isFav ? Icons.favorite : Icons.favorite_border,
                            size: 18,
                            color: isFav ? Colors.red : Colors.grey.shade600,
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
            // Product Details
            Padding(
              padding: const EdgeInsets.all(12.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    productName,
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.bold,
                      color: Colors.grey.shade800,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'â‚¹${sellingPriceNum.toStringAsFixed(2)}',
                              style: GoogleFonts.poppins(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                                color: _priceDarkBlue,
                              ),
                            ),
                            if (hasDiscount)
                              Text(
                                'â‚¹${mrpPriceNum.toStringAsFixed(2)}',
                                style: GoogleFonts.poppins(
                                  fontSize: 11,
                                  decoration: TextDecoration.lineThrough,
                                  color: Colors.grey.shade500,
                                ),
                              ),
                          ],
                        ),
                      ),
                      Container(
                        padding: const EdgeInsets.all(6),
                        decoration: BoxDecoration(
                          color: _tealColor,
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Icon(Icons.add, color: Colors.white, size: 18),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildProductGridCard(String name, String price, IconData icon) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    Colors.green.shade100,
                    Colors.green.shade50,
                  ],
                ),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
              child: Center(
                child: Icon(icon, size: 50, color: _tealColor),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: GoogleFonts.poppins(
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey.shade800,
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      price,
                      style: GoogleFonts.poppins(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: _tealColor,
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.all(6),
                      decoration: BoxDecoration(
                        color: _tealColor,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Icon(Icons.add, color: Colors.white, size: 18),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildServiceCard(String title, String description, IconData icon) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: _tealLight,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Icon(icon, size: 32, color: Colors.green.shade700),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey.shade800,
                  ),
                ),
                const SizedBox(height: 4),
            Text(
                  description,
                  style: GoogleFonts.poppins(
                    fontSize: 12,
                    color: Colors.grey.shade600,
                  ),
            ),
          ],
        ),
      ),
          Icon(Icons.arrow_forward_ios, size: 20, color: _tealColor),
        ],
      ),
    );
  }

  Widget _buildProfileMenuItem(IconData icon, String title, VoidCallback onTap) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(18),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(18),
          border: Border.all(color: Colors.grey.withOpacity(0.05)),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.04),
              blurRadius: 16,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(10),
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: LinearGradient(
                  colors: [
                    _tealColor.withOpacity(0.9),
                    _tealColor.withOpacity(0.6),
                  ],
                ),
              ),
              child: Icon(icon, color: Colors.white, size: 20),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 15,
                  color: Colors.grey.shade800,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            Icon(Icons.arrow_forward_ios, size: 18, color: Colors.grey.shade400),
          ],
        ),
      ),
    );
  }


  // Validation functions for edit profile
  String? _validateEditFullName(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your full name';
    }
    if (value.trim().length < 2) {
      return 'Name must be at least 2 characters';
    }
    return null;
  }

  String? _validateEditEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your email address';
    }
    final email = value.trim().toLowerCase();
    final emailRegex = RegExp(
      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
      caseSensitive: false,
    );
    if (!emailRegex.hasMatch(email)) {
      return 'Please enter a valid email address';
    }
    return null;
  }

  String? _validateEditPhone(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your phone number';
    }
    final cleanPhone = value.replaceAll(RegExp(r'[\s\-\(\)]'), '');
    if (!RegExp(r'^\d+$').hasMatch(cleanPhone)) {
      return 'Phone number must contain only digits';
    }
    if (cleanPhone.length != 10) {
      return 'Phone number must be exactly 10 digits';
    }
    if (cleanPhone.startsWith('0')) {
      return 'Phone number cannot start with 0';
    }
    return null;
  }

  String? _validateEditPassword(String? value) {
    if (value != null && value.isNotEmpty) {
      if (value.length < 6) {
        return 'Password must be at least 6 characters';
      }
    }
    return null;
  }

  String? _validateEditConfirmPassword(String? value) {
    if (_editPasswordController.text.isNotEmpty) {
      if (value == null || value.isEmpty) {
        return 'Please confirm your password';
      }
      if (value != _editPasswordController.text) {
        return 'Passwords do not match';
      }
    }
    return null;
  }

  String? _validateEditAddress(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your address';
    }
    if (value.trim().length < 5) {
      return 'Address must be at least 5 characters';
    }
    return null;
  }

  Future<void> _showEditProfileDialog() async {
    // Pre-fill controllers with current user data
    if (_userData != null) {
      _editFullNameController.text = _userData!['name'] ?? '';
      _editEmailController.text = _userData!['email'] ?? '';
      _editPhoneController.text = _userData!['phone'] ?? '';
      _editAddressController.text = _userData!['address'] ?? '';
      _editPasswordController.clear();
      _editConfirmPasswordController.clear();
    }
    // Reset selected image when opening dialog
    _selectedProfileImage = null;
    _selectedProfileImageBytes = null;

    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => StatefulBuilder(
        builder: (context, setModalState) {
          final selectedImageProvider = _getSelectedProfileImageProvider();
          final profileImageUrl = _getProfileImageUrl();
          return Container(
        height: MediaQuery.of(context).size.height * 0.9,
        decoration: const BoxDecoration(
          color: Color(0xFFE0F2F1),
          borderRadius: BorderRadius.vertical(top: Radius.circular(30)),
        ),
        child: Column(
          children: [
            // Handle bar
            Container(
              margin: const EdgeInsets.only(top: 12),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey.shade400,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            // Title
            Padding(
              padding: const EdgeInsets.all(20),
              child: Text(
                'Edit Profile',
                style: GoogleFonts.poppins(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey.shade900,
                ),
              ),
            ),
            // Form
            Expanded(
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                child: Form(
                  key: _editProfileFormKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      // Profile Photo at Top Middle
                      GestureDetector(
                        onTap: () async {
                          try {
                            // Show options to pick from gallery or camera
                            final ImageSource? source = await showModalBottomSheet<ImageSource>(
                              context: context,
                              builder: (context) => SafeArea(
                                child: Column(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    ListTile(
                                      leading: const Icon(Icons.photo_library),
                                      title: const Text('Choose from Gallery'),
                                      onTap: () => Navigator.pop(context, ImageSource.gallery),
                                    ),
                                    ListTile(
                                      leading: const Icon(Icons.camera_alt),
                                      title: const Text('Take a Photo'),
                                      onTap: () => Navigator.pop(context, ImageSource.camera),
                                    ),
                                    ListTile(
                                      leading: const Icon(Icons.cancel),
                                      title: const Text('Cancel'),
                                      onTap: () => Navigator.pop(context),
                                    ),
                                  ],
                                ),
                              ),
                            );

                            if (source != null) {
                              final XFile? image = await _imagePicker.pickImage(
                                source: source,
                                imageQuality: 85,
                                maxWidth: 800,
                                maxHeight: 800,
                              );

                              if (image != null) {
                                final bytes = await image.readAsBytes();
                                setModalState(() {
                                  _selectedProfileImage = image;
                                  _selectedProfileImageBytes = bytes;
                                });
                              }
                            }
                          } catch (e) {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error picking image: ${e.toString()}'),
                                  backgroundColor: Colors.red,
                                  duration: const Duration(seconds: 2),
                                ),
                              );
                            }
                          }
                        },
                        child: Stack(
                          children: [
                            CircleAvatar(
                              radius: 60,
                              backgroundColor: Colors.white,
                              backgroundImage: selectedImageProvider ??
                                  (profileImageUrl != null ? NetworkImage(profileImageUrl) : null),
                              child: selectedImageProvider == null && profileImageUrl == null
                                  ? Icon(
                                      Icons.person,
                                      size: 60,
                                      color: _tealColor,
                                    )
                                  : null,
                            ),
                            Positioned(
                              bottom: 0,
                              right: 0,
                              child: Container(
                                padding: const EdgeInsets.all(8),
                                decoration: BoxDecoration(
                                  color: _tealColor,
                                  shape: BoxShape.circle,
                                  border: Border.all(color: Colors.white, width: 2),
                                ),
                                child: const Icon(
                                  Icons.camera_alt,
                                  color: Colors.white,
                                  size: 20,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 32),
                      // Full Name Field
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Text(
                            'Full Name:',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                              color: Colors.black,
                            ),
                          ),
                        ),
                      ),
                      Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(15),
                        ),
                        child: TextFormField(
                          controller: _editFullNameController,
                          keyboardType: TextInputType.name,
                          decoration: const InputDecoration(
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                          ),
                          validator: _validateEditFullName,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Email Field
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Text(
                            'Email:',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                              color: Colors.black,
                            ),
                          ),
                        ),
                      ),
                      Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(15),
                        ),
                        child: TextFormField(
                          controller: _editEmailController,
                          keyboardType: TextInputType.emailAddress,
                          inputFormatters: [
                            FilteringTextInputFormatter.deny(RegExp(r'\s')),
                            LengthLimitingTextInputFormatter(254),
                          ],
                          decoration: const InputDecoration(
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                          ),
                          validator: _validateEditEmail,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Phone Number Field
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Text(
                            'Phone no:',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                              color: Colors.black,
                            ),
                          ),
                        ),
                      ),
                      Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(15),
                        ),
                        child: TextFormField(
                          controller: _editPhoneController,
                          keyboardType: TextInputType.number,
                          inputFormatters: [
                            FilteringTextInputFormatter.digitsOnly,
                            LengthLimitingTextInputFormatter(10),
                          ],
                          decoration: const InputDecoration(
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                          ),
                          validator: _validateEditPhone,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Password Field
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Text(
                            'Password:',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                              color: Colors.black,
                            ),
                          ),
                        ),
                      ),
                      Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(15),
                        ),
                        child: TextFormField(
                          controller: _editPasswordController,
                          obscureText: _obscureEditPassword,
                          decoration: InputDecoration(
                            border: InputBorder.none,
                            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                            suffixIcon: IconButton(
                              icon: Icon(
                                _obscureEditPassword ? Icons.visibility_outlined : Icons.visibility_off_outlined,
                                color: Colors.grey,
                              ),
                              onPressed: () {
                                setModalState(() {
                                  _obscureEditPassword = !_obscureEditPassword;
                                });
                              },
                            ),
                          ),
                          validator: _validateEditPassword,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Confirm Password Field
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Text(
                            'Confirm Password:',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                              color: Colors.black,
                            ),
                          ),
                        ),
                      ),
                      Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(15),
                        ),
                        child: TextFormField(
                          controller: _editConfirmPasswordController,
                          obscureText: _obscureEditConfirmPassword,
                          decoration: InputDecoration(
                            border: InputBorder.none,
                            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                            suffixIcon: IconButton(
                              icon: Icon(
                                _obscureEditConfirmPassword ? Icons.visibility_outlined : Icons.visibility_off_outlined,
                                color: Colors.grey,
                              ),
                              onPressed: () {
                                setModalState(() {
                                  _obscureEditConfirmPassword = !_obscureEditConfirmPassword;
                                });
                              },
                            ),
                          ),
                          validator: _validateEditConfirmPassword,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Address Field
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Text(
                            'Address:',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                              color: Colors.black,
                            ),
                          ),
                        ),
                      ),
                      Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(15),
                        ),
                        child: TextFormField(
                          controller: _editAddressController,
                          keyboardType: TextInputType.streetAddress,
                          maxLines: 2,
                          decoration: const InputDecoration(
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                          ),
                          validator: _validateEditAddress,
                        ),
                      ),
                      const SizedBox(height: 32),
                      // Save Button
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          onPressed: _isEditingProfile
                              ? null
                              : () => _handleUpdateProfile(dismissContext: context),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: const Color(0xFF0D47A1),
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(15),
                            ),
                            elevation: 0,
                          ),
                          child: _isEditingProfile
                              ? const SizedBox(
                                  height: 20,
                                  width: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                  ),
                                )
                              : Text(
                                  'Save Changes',
                                  style: GoogleFonts.poppins(
                                    fontSize: 16,
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                        ),
                      ),
                      const SizedBox(height: 24),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
        );
        },
      ),
    );
  }

  Future<void> _handleUpdateProfile({BuildContext? dismissContext}) async {
    if (_editProfileFormKey.currentState!.validate()) {
      setState(() {
        _isEditingProfile = true;
      });

      try {
        if (_userData == null || _userData!['id'] == null) {
          throw Exception('User not logged in');
        }

        // Upload profile image first if one is selected
        if (_selectedProfileImage != null) {
          try {
            final request = http.MultipartRequest(
              'POST',
              Uri.parse('${_backendBaseUrl}upload_profile_image.php'),
            );
            
            request.fields['user_id'] = _userData!['id'].toString();
            final multipartFile = await _prepareProfileImageMultipartFile();
            request.files.add(multipartFile);

            final streamedResponse = await request.send();
            final response = await http.Response.fromStream(streamedResponse);

            // PRINT THE RESPONSE (VERY IMPORTANT) - as requested by user
            final respStr = response.body;
            debugPrint('ðŸ“¤ Upload Response Status: ${response.statusCode}');
            debugPrint('ðŸ“¤ Upload Response Body: $respStr');

            // Check if response is JSON before parsing
            final contentType = response.headers['content-type'] ?? '';
            final isJson = contentType.contains('application/json') || 
                          (response.body.trim().startsWith('{') || response.body.trim().startsWith('['));
            
            if (!isJson) {
              // Server returned HTML or other non-JSON response
              debugPrint('âŒ Server returned non-JSON response: ${response.body.substring(0, response.body.length > 200 ? 200 : response.body.length)}');
              throw Exception('Server error: Please check if the upload endpoint is working correctly');
            }

            if (response.statusCode == 200) {
              try {
                final uploadData = jsonDecode(response.body);
                if (uploadData['success'] == true || uploadData['status'] == 'success') {
                  // Get old image URL to clear cache
                  final oldImageUrl = _getProfileImageUrl();
                  
                  // Update user data with new profile image (use image_url or profile_image, whichever is available)
                  if (_userData != null) {
                    final imageUrl = uploadData['image_url'] ?? uploadData['profile_image'];
                    if (imageUrl != null) {
                      // Clear cache for old image URL if it exists
                      if (oldImageUrl != null) {
                        try {
                          await CachedNetworkImage.evictFromCache(oldImageUrl);
                          // Also clear fallback and proxy URLs
                          final fallbackUrl = oldImageUrl.contains('superdailys.com/public/storage/profiles/') 
                              ? oldImageUrl.replaceAll('superdailys.com/public/storage/profiles/', 'srv1881-files.hstgr.io/4663f5e73332121d/files/public_html/public/storage/profiles/')
                              : oldImageUrl.replaceAll('srv1881-files.hstgr.io/4663f5e73332121d/files/public_html/public/storage/profiles/', 'superdailys.com/public/storage/profiles/');
                          await CachedNetworkImage.evictFromCache(fallbackUrl);
                          final proxyUrl = 'https://superdailys.com/superdailyapp/proxy_image.php?url=${Uri.encodeComponent(oldImageUrl)}';
                          await CachedNetworkImage.evictFromCache(proxyUrl);
                          debugPrint('ðŸ—‘ï¸ Cleared cache for old profile image URLs');
                        } catch (e) {
                          debugPrint('âš ï¸ Error clearing cache: $e');
                        }
                      }
                      
                      _userData!['profile_image'] = imageUrl;
                      // Set new cache buster timestamp to force refresh
                      _profileImageCacheBuster = DateTime.now().millisecondsSinceEpoch.toString();
                      
                      // Also update user data if returned from server
                      if (uploadData['user'] != null) {
                        _userData!.addAll(uploadData['user']);
                      }
                      
                      // Trigger rebuild to show new image immediately
                      if (mounted) {
                        setState(() {});
                      }
                    }
                  }
                  debugPrint('âœ… Profile image uploaded successfully: ${uploadData['image_url'] ?? uploadData['profile_image']}');
                  debugPrint('ðŸ”„ Cache buster updated: $_profileImageCacheBuster');
                } else {
                  throw Exception(uploadData['message'] ?? 'Failed to upload image');
                }
              } catch (jsonError) {
                debugPrint('âŒ JSON decode error: $jsonError');
                throw Exception('Invalid response from server. Please try again.');
              }
            } else {
              try {
                final errorData = jsonDecode(response.body);
                throw Exception(errorData['message'] ?? 'Failed to upload image (Status: ${response.statusCode})');
              } catch (jsonError) {
                debugPrint('âŒ Error response JSON decode error: $jsonError');
                throw Exception('Server error (Status: ${response.statusCode}). Please try again.');
              }
            }
          } catch (e) {
            debugPrint('âŒ Profile image upload error: $e');
            if (mounted) {
              String errorMessage = 'Error uploading image';
              if (e.toString().contains('Server error')) {
                errorMessage = e.toString().replaceAll('Exception: ', '');
              } else if (e.toString().contains('Failed to upload')) {
                errorMessage = e.toString().replaceAll('Exception: ', '');
              } else {
                errorMessage = 'Failed to upload image. Please check your connection and try again.';
              }
              
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(errorMessage),
                  backgroundColor: Colors.red,
                  duration: const Duration(seconds: 4),
                ),
              );
            }
            // Don't return here - allow profile update to continue even if image upload fails
            // setState(() {
            //   _isEditingProfile = false;
            // });
            // return;
          }
        }

        // Prepare update payload
        final Map<String, dynamic> payload = {
          'user_id': _userData!['id'],
          'name': _editFullNameController.text.trim(),
          'email': _editEmailController.text.trim(),
          'phone': _editPhoneController.text.trim(),
          'address': _editAddressController.text.trim(),
        };

        // Add password only if it's provided
        if (_editPasswordController.text.isNotEmpty) {
          payload['password'] = _editPasswordController.text;
        }

        // Make API call to update profile
        final response = await http.post(
          Uri.parse('${_backendBaseUrl}update_profile.php'),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(payload),
        );

        if (mounted) {
          if (response.statusCode == 200) {
            // Parse JSON response with error handling
            Map<String, dynamic> data;
            try {
              data = jsonDecode(response.body) as Map<String, dynamic>;
            } catch (jsonError) {
              debugPrint('âŒ JSON decode error: $jsonError');
              debugPrint('Response body: ${response.body}');
              throw Exception('Invalid response from server. Please try again.');
            }
            if (data['success'] == true) {
              // Check if user data exists in response
              if (data['user'] == null) {
                throw Exception('User data not found in response');
              }
              
              // Ensure all required fields are present and not null
              final userData = Map<String, dynamic>.from(data['user']);
              
              // Set default values for null fields to prevent encoding errors
              userData['id'] = userData['id'] ?? _userData?['id'];
              
              // Validate that ID is not null
              if (userData['id'] == null) {
                throw Exception('User ID is missing from response');
              }
              
              userData['name'] = userData['name'] ?? '';
              userData['email'] = userData['email'] ?? '';
              userData['phone'] = userData['phone'] ?? '';
              userData['address'] = userData['address'] ?? '';
              userData['role'] = userData['role'] ?? '';
              
              // Merge profile_image if it was uploaded but not in response
              if (_userData != null && _userData!.containsKey('profile_image') && 
                  (userData['profile_image'] == null || userData['profile_image'].toString().isEmpty)) {
                userData['profile_image'] = _userData!['profile_image'];
              }
              
              // Ensure profile_image is present (can be null, but must be a key)
              if (!userData.containsKey('profile_image')) {
                userData['profile_image'] = null;
              }
              
              // Update local user data - use try-catch to handle any encoding errors
              try {
                final prefs = await SharedPreferences.getInstance();
                await prefs.setString('userData', jsonEncode(userData));
              } catch (encodeError) {
                debugPrint('âŒ Error encoding user data: $encodeError');
                debugPrint('User data: $userData');
                throw Exception('Failed to save user data: ${encodeError.toString()}');
              }
              
              // Update _userData state with new data
              setState(() {
                _userData = userData;
                _selectedProfileImage = null; // Clear selected image after successful update
                _selectedProfileImageBytes = null;
              });
              
              if (dismissContext != null && Navigator.canPop(dismissContext)) {
                Navigator.of(dismissContext).pop();
              } else if (Navigator.canPop(context)) {
              Navigator.pop(context);
              }
              
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Profile updated successfully'),
                  backgroundColor: Colors.green,
                  duration: Duration(seconds: 2),
                ),
              );
            } else {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(data['message'] ?? 'Failed to update profile'),
                  backgroundColor: Colors.red,
                  duration: const Duration(seconds: 3),
                ),
              );
            }
          } else {
            // Handle non-200 status codes
            Map<String, dynamic>? errorData;
            try {
              errorData = jsonDecode(response.body) as Map<String, dynamic>?;
            } catch (e) {
              debugPrint('âŒ Error parsing error response: $e');
            }
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(errorData?['message'] ?? 'Server error occurred (Status: ${response.statusCode})'),
                backgroundColor: Colors.red,
                duration: const Duration(seconds: 3),
              ),
            );
          }
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error updating profile: ${e.toString()}'),
              backgroundColor: Colors.red,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      } finally {
        if (mounted) {
          setState(() {
            _isEditingProfile = false;
          });
        }
      }
    }
  }

  Widget _buildFeaturedProductCardHorizontal(Map<String, dynamic> product) {
    final sellingPrice = (product['selling_price'] ?? product['price'] ?? 0);
    final mrpPrice = (product['mrp_price'] ?? sellingPrice);
    final discountPercentage = (product['discount_percentage'] ?? 0);
    
    // Collect all available images for the product
    final List<String> images = [
      product['image'],
      product['image_2'],
      product['image_3'],
      product['image_4'],
    ]
        .where((img) => img != null && img.toString().trim().isNotEmpty)
        .map((img) => _resolveImageUrl(img.toString()))
        .toList();
    
    // Convert to numbers safely - handle null, string, and number types
    double sellingPriceNum = 0.0;
    if (sellingPrice != null) {
      if (sellingPrice is String) {
        sellingPriceNum = double.tryParse(sellingPrice) ?? 0.0;
      } else if (sellingPrice is num) {
        sellingPriceNum = sellingPrice.toDouble();
      }
    }
    
    double mrpPriceNum = sellingPriceNum;
    if (mrpPrice != null) {
      if (mrpPrice is String) {
        mrpPriceNum = double.tryParse(mrpPrice) ?? sellingPriceNum;
      } else if (mrpPrice is num) {
        mrpPriceNum = mrpPrice.toDouble();
      } else {
        mrpPriceNum = sellingPriceNum;
      }
    }
    
    double discountPercentageNum = 0.0;
    if (discountPercentage != null) {
      if (discountPercentage is String) {
        discountPercentageNum = double.tryParse(discountPercentage) ?? 0.0;
      } else if (discountPercentage is num) {
        discountPercentageNum = discountPercentage.toDouble();
      }
    }
    
    final hasDiscount = discountPercentageNum > 0 && mrpPriceNum > sellingPriceNum;
    
    return GestureDetector(
      onTap: () {
        final productId = product['id'];
        if (productId != null) {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => ProductDetailsScreen(
                productId: productId is int ? productId : int.tryParse(productId.toString()) ?? 0,
                onAddToCart: _addToCart,
                onUpdateCartQuantity: _updateCartQuantity,
                onRemoveFromCart: _removeFromCart,
                onCartUpdated: () {
                  setState(() {}); // Refresh to update cart count
                },
                getCartItemQuantity: _getCartItemQuantity,
                getCartItemCount: _getCartItemCount,
                cartItems: _cartItems,
              ),
            ),
          );
        }
      },
      child: Container(
        width: 220,
        height: 280,
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            // Product Images (swipeable if multiple)
            Container(
              width: 220,
              height: 140,
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    _tealLight,
                    _tealLighter,
                  ],
                ),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
              child: images.isNotEmpty
                  ? ClipRRect(
                      borderRadius: const BorderRadius.only(
                        topLeft: Radius.circular(16),
                        topRight: Radius.circular(16),
                      ),
                      child: Stack(
                        children: [
                          PageView.builder(
                            itemCount: images.length,
                            itemBuilder: (context, index) {
                              final raw = images[index];
                              final base = _basename(raw);
                              final candidates = <String>[
                                raw,
                                'products/' + base,
                                'uploads/' + base,
                                'uploads/products/' + base,
                              ];
                              return FallbackImage(
                                urls: candidates,
                                fit: BoxFit.cover,
                                placeholder: Center(
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(_tealColor),
                                  ),
                                ),
                                error: Center(
                                  child: Icon(
                                    Icons.image_not_supported,
                                    size: 40,
                                    color: _tealColor,
                                  ),
                                ),
                              );
                            },
                          ),
                          // Small image count badge
                          if (images.length > 1)
                            Positioned(
                              right: 8,
                              bottom: 8,
                              child: Container(
                                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
                                decoration: BoxDecoration(
                                  color: Colors.black.withOpacity(0.45),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: Text(
                                  '${images.length} images',
                                  style: GoogleFonts.poppins(
                                    fontSize: 10,
                                    color: Colors.white,
                                  ),
                                ),
                              ),
                            ),
                        ],
                      ),
                    )
                  : Center(
                      child: Icon(
                        Icons.inventory_2,
                        size: 50,
                        color: _tealColor,
                      ),
                    ),
            ),
            // Product Details - Flexible layout
            Expanded(
              child: Padding(
                padding: const EdgeInsets.all(10.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                  // Brand Name
                  if (product['brand_name'] != null && product['brand_name'].toString().isNotEmpty)
                    Text(
                      product['brand_name'].toString().toUpperCase(),
                      style: GoogleFonts.poppins(
                        fontSize: 9,
                        fontWeight: FontWeight.w600,
                        color: _tealColor,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  if (product['brand_name'] != null && product['brand_name'].toString().isNotEmpty)
                    const SizedBox(height: 3),
                  // Product Name
                  Flexible(
                    child: Text(
                      product['name'] ?? 'Product',
                      style: GoogleFonts.poppins(
                        fontSize: 13,
                        fontWeight: FontWeight.bold,
                        color: Colors.grey.shade800,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(height: 6),
                  // Price Row
                  Wrap(
                    crossAxisAlignment: WrapCrossAlignment.center,
                    spacing: 4,
                    runSpacing: 2,
                    children: [
                      Text(
                        'â‚¹${sellingPriceNum.toStringAsFixed(2)}',
                        style: GoogleFonts.poppins(
                          fontSize: 15,
                          fontWeight: FontWeight.bold,
                          color: _priceDarkBlue,
                        ),
                      ),
                      if (hasDiscount)
            Text(
                          'â‚¹${mrpPriceNum.toStringAsFixed(2)}',
                          style: GoogleFonts.poppins(
                            fontSize: 11,
                            decoration: TextDecoration.lineThrough,
                            color: Colors.grey.shade500,
                          ),
                        ),
                    ],
                  ),
                  if (hasDiscount) ...[
                    const SizedBox(height: 3),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 2),
                      decoration: BoxDecoration(
                        color: Colors.red.shade100,
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        '${discountPercentageNum.toStringAsFixed(0)}% OFF',
                        style: GoogleFonts.poppins(
                          fontSize: 8,
                          fontWeight: FontWeight.bold,
                          color: Colors.red.shade700,
                        ),
                      ),
                    ),
                  ],
                  const Spacer(),
                  // Stock and Add Button Row
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // Stock Info
                      Flexible(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 3),
                          decoration: BoxDecoration(
                            color: (product['stock_quantity'] ?? 0) > 0
                                ? _tealLight
                                : Colors.red.shade100,
                            borderRadius: BorderRadius.circular(6),
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                (product['stock_quantity'] ?? 0) > 0
                                    ? Icons.check_circle
                                    : Icons.cancel,
                                size: 11,
                                color: (product['stock_quantity'] ?? 0) > 0
                                    ? _tealColor
                                    : Colors.red.shade700,
                              ),
                              const SizedBox(width: 3),
                              Flexible(
                                child: Text(
                                  (product['stock_quantity'] ?? 0) > 0
                                      ? 'In Stock'
                                      : 'Out',
                                  style: GoogleFonts.poppins(
                                    fontSize: 8,
                                    fontWeight: FontWeight.w600,
                                    color: (product['stock_quantity'] ?? 0) > 0
                                        ? _tealColor
                                        : Colors.red.shade700,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                      // Add to Cart Button
                      Container(
                        padding: const EdgeInsets.all(7),
                        decoration: BoxDecoration(
                          color: _tealColor,
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Icon(
                          Icons.shopping_cart,
                          color: Colors.white,
                          size: 16,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
          ],
        ),
      ),
    );
  }

  Widget _buildProductListItem(Map<String, dynamic> product) {
    try {
      // Collect all available images (image, image_2, image_3, image_4)
      final List<String> productImages = [];
      for (var imgKey in ['image', 'image_2', 'image_3', 'image_4']) {
        final imgValue = product[imgKey];
        if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
          final resolvedUrl = _resolveImageUrl(imgValue.toString());
          if (resolvedUrl.isNotEmpty && resolvedUrl.startsWith('http')) {
            productImages.add(resolvedUrl);
            debugPrint('ðŸ–¼ï¸ Product "${product['name'] ?? 'Unknown'}" - Found image from $imgKey: $resolvedUrl');
          } else {
            debugPrint('âš ï¸ Product "${product['name'] ?? 'Unknown'}" - Invalid image URL from $imgKey: $imgValue -> resolved: $resolvedUrl');
          }
        }
      }
      
      // Use first available image, or null if none
      final productImage = productImages.isNotEmpty ? productImages[0] : null;
      
      if (productImage == null) {
        debugPrint('âŒ Product "${product['name'] ?? 'Unknown'}" - No valid images found. Available keys: image=${product['image']}, image_2=${product['image_2']}, image_3=${product['image_3']}, image_4=${product['image_4']}');
      }
      
      // Helper function to safely parse numbers
      double parseNumber(dynamic value, [double defaultValue = 0.0]) {
        if (value == null) return defaultValue;
        if (value is double) return value.isNaN || value.isInfinite ? defaultValue : value;
        if (value is int) return value.toDouble();
        if (value is String) {
          final parsed = double.tryParse(value.trim());
          if (parsed != null && !parsed.isNaN && !parsed.isInfinite) return parsed;
        }
        return defaultValue;
      }
      
      // Helper function to safely parse integers (for stock_quantity)
      int parseInteger(dynamic value, [int defaultValue = 0]) {
        if (value == null) return defaultValue;
        if (value is int) return value;
        if (value is double) return value.toInt();
        if (value is String) {
          final parsed = int.tryParse(value.trim());
          if (parsed != null) return parsed;
        }
        return defaultValue;
      }
      
      // Parse prices with safe parsing
      final sellingPriceRaw = product['selling_price'] ?? product['price'] ?? 0;
      final mrpPriceRaw = product['mrp_price'] ?? sellingPriceRaw;
      final discountPercentageRaw = product['discount_percentage'] ?? 0;
      final stockQuantityRaw = product['stock_quantity'] ?? 0;
      
      double sellingPriceNum = parseNumber(sellingPriceRaw, 0.0);
      double mrpPriceNum = parseNumber(mrpPriceRaw, sellingPriceNum);
      double discountPercentageNum = parseNumber(discountPercentageRaw, 0.0);
      
      // Ensure values are valid
      sellingPriceNum = sellingPriceNum.isNaN || sellingPriceNum.isInfinite ? 0.0 : sellingPriceNum;
      mrpPriceNum = mrpPriceNum.isNaN || mrpPriceNum.isInfinite ? sellingPriceNum : mrpPriceNum;
      discountPercentageNum = discountPercentageNum.isNaN || discountPercentageNum.isInfinite ? 0.0 : discountPercentageNum;
      
      final hasDiscount = mrpPriceNum > sellingPriceNum && sellingPriceNum > 0;
      
      return GestureDetector(
      onTap: () {
        final productId = product['id'];
        if (productId != null) {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => ProductDetailsScreen(
                productId: productId is int ? productId : int.tryParse(productId.toString()) ?? 0,
                onAddToCart: _addToCart,
                onUpdateCartQuantity: _updateCartQuantity,
                onRemoveFromCart: _removeFromCart,
                onCartUpdated: () {
                  setState(() {}); // Refresh to update cart count
                },
                getCartItemQuantity: _getCartItemQuantity,
                getCartItemCount: _getCartItemCount,
                cartItems: _cartItems,
              ),
            ),
          );
        }
      },
      child: Container(
        width: 160,
        constraints: const BoxConstraints(maxWidth: 160),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            // Product Image
            Container(
              width: 160,
              height: 130,
              decoration: BoxDecoration(
                gradient: LinearGradient(colors: [_tealLight, _tealLighter]),
                borderRadius: const BorderRadius.only(topLeft: Radius.circular(16), topRight: Radius.circular(16)),
              ),
              child: Stack(
                children: [
                  if (productImages.isNotEmpty)
                    ClipRRect(
                      borderRadius: const BorderRadius.only(topLeft: Radius.circular(16), topRight: Radius.circular(16)),
                      child: SizedBox(
                        width: double.infinity,
                        height: double.infinity,
                        child: _ProductImageWidget(
                          imageUrls: productImages,
                          productName: product['name'] ?? 'Unknown',
                        ),
                      ),
                    )
                  else
                    Container(
                      width: double.infinity,
                      height: double.infinity,
                      child: Center(
                        child: Icon(Icons.inventory_2, color: _tealColor, size: 32),
                      ),
                    ),
                  // Show indicator if there are multiple images
                  if (productImages.length > 1)
                    Positioned(
                      top: 4,
                      right: 4,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
                        decoration: BoxDecoration(
                          color: Colors.black.withOpacity(0.6),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.photo_library, size: 10, color: Colors.white),
                            const SizedBox(width: 2),
                            Text(
                              '${productImages.length}',
                              style: GoogleFonts.poppins(
                                fontSize: 9,
                                fontWeight: FontWeight.bold,
                                color: Colors.white,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  // Heart Icon for Favorites
                  Positioned(
                    top: 4,
                    right: productImages.length > 1 ? 50 : 4,
                    child: FutureBuilder<bool>(
                      future: _isFavorite('product', product['id'].toString()),
                      builder: (context, snapshot) {
                        final isFav = snapshot.data ?? false;
                        return GestureDetector(
                          onTap: () => _toggleFavorite('product', product['id'].toString()),
                          child: Container(
                            padding: const EdgeInsets.all(4),
                            decoration: BoxDecoration(
                              color: Colors.white.withOpacity(0.9),
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.1),
                                  blurRadius: 4,
                                  offset: const Offset(0, 2),
                                ),
                              ],
                            ),
                            child: Icon(
                              isFav ? Icons.favorite : Icons.favorite_border,
                              size: 14,
                              color: isFav ? Colors.red : Colors.grey.shade600,
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
            // Product Details
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 6.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  // Product Name
                  Text(
                    product['name'] ?? 'Product',
                    style: GoogleFonts.poppins(
                      fontSize: 11,
                      fontWeight: FontWeight.bold,
                      color: Colors.grey.shade800,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 3),
                  // Brand Name (smaller)
                  if (product['brand_name'] != null && product['brand_name'].toString().isNotEmpty)
                    Text(
                      product['brand_name'].toString(),
                      style: GoogleFonts.poppins(
                        fontSize: 8,
                        color: _tealColor,
                        fontWeight: FontWeight.w600,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  if (product['brand_name'] != null && product['brand_name'].toString().isNotEmpty)
                    const SizedBox(height: 2),
                  // Price Row
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      Flexible(
                        flex: 3,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              'â‚¹${sellingPriceNum.toStringAsFixed(2)}',
                              style: GoogleFonts.poppins(
                                fontSize: 11,
                                fontWeight: FontWeight.bold,
                                color: _priceDarkBlue,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            if (hasDiscount)
                              Text(
                                'â‚¹${mrpPriceNum.toStringAsFixed(2)}',
                                style: GoogleFonts.poppins(
                                  fontSize: 7,
                                  decoration: TextDecoration.lineThrough,
                                  color: Colors.grey.shade500,
                                ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 4),
                      // Quantity Controls
                      Builder(
                        builder: (context) {
                          final productId = product['id'];
                          final cartQuantity = productId != null ? _getCartItemQuantity(productId) : 0;
                          final stockQuantity = parseInteger(product['stock_quantity'] ?? 0);
                          
                          if (cartQuantity > 0) {
                            // Show increment/decrement buttons
                            return Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                // Decrement button
                                GestureDetector(
                                  onTap: () {
                                    final normalizedProductId = _normalizeProductId(productId);
                                    if (cartQuantity > 1) {
                                      _updateCartQuantity(normalizedProductId, cartQuantity - 1);
                                    } else {
                                      _removeFromCart(normalizedProductId);
                                    }
                                  },
                                  child: Container(
                                    width: 20,
                                    height: 20,
                                    decoration: BoxDecoration(
                                      color: _tealColor,
                                      borderRadius: BorderRadius.circular(4),
                                    ),
                                    child: const Icon(Icons.remove, color: Colors.white, size: 12),
                                  ),
                                ),
                                const SizedBox(width: 6),
                                Text(
                                  '$cartQuantity',
                                  style: GoogleFonts.poppins(
                                    fontSize: 12,
                                    fontWeight: FontWeight.bold,
                                    color: Colors.grey.shade800,
                                  ),
                                ),
                                const SizedBox(width: 6),
                                // Increment button
                                GestureDetector(
                                  onTap: () {
                                    if (cartQuantity < stockQuantity) {
                                      _addToCart(product);
                                    } else {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        const SnackBar(
                                          content: Text('Cannot add more. Stock limit reached.'),
                                          backgroundColor: Colors.orange,
                                          duration: Duration(seconds: 2),
                                        ),
                                      );
                                    }
                                  },
                                  child: Container(
                                    width: 20,
                                    height: 20,
                                    decoration: BoxDecoration(
                                      color: _tealColor,
                                      borderRadius: BorderRadius.circular(4),
                                    ),
                                    child: const Icon(Icons.add, color: Colors.white, size: 12),
                                  ),
                                ),
                              ],
                            );
                          } else {
                            // Show add button
                            return GestureDetector(
                              onTap: () {
                                if (stockQuantity > 0) {
                                  _addToCart(product);
                                } else {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                      content: Text('Product out of stock'),
                                      backgroundColor: Colors.red,
                                      duration: Duration(seconds: 2),
                                    ),
                                  );
                                }
                              },
                              child: Container(
                        padding: const EdgeInsets.all(4),
                        decoration: BoxDecoration(
                          color: _tealColor,
                          borderRadius: BorderRadius.circular(6),
                        ),
                        child: const Icon(Icons.add, color: Colors.white, size: 12),
                              ),
                            );
                          }
                        },
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
    } catch (e, stackTrace) {
      print('âŒ Error in _buildProductListItem: $e');
      print('ðŸ“‹ Stack trace: $stackTrace');
      print('ðŸ“¦ Product data: $product');
      // Return error widget instead of crashing
      return Container(
        padding: const EdgeInsets.all(12),
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
        decoration: BoxDecoration(
          color: Colors.red.shade50,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.red.shade200),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.error_outline, color: Colors.red.shade700, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Error loading product: ${product['name'] ?? 'Unknown'}',
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.bold,
                      color: Colors.red.shade700,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 4),
            Text(
              'Error: ${e.toString()}',
              style: GoogleFonts.poppins(
                fontSize: 11,
                color: Colors.red.shade600,
              ),
            ),
          ],
        ),
      );
    }
  }
}

// Profile Image Widget with retry and fallback logic
class _ProfileImageWidget extends StatefulWidget {
  final String imageUrl;
  final double radius;
  final Color backgroundColor;
  final Color iconColor;
  final dynamic userId;
  final String? cacheBuster;

  const _ProfileImageWidget({
    required this.imageUrl,
    required this.radius,
    required this.backgroundColor,
    required this.iconColor,
    this.userId,
    this.cacheBuster,
  });

  @override
  State<_ProfileImageWidget> createState() => _ProfileImageWidgetState();
}

class _ProfileImageWidgetState extends State<_ProfileImageWidget> {
  // For web, use proxy first (CORS blocks direct URLs). For mobile, try primary first.
  int _currentUrlIndex = kIsWeb ? 2 : 0; // 0 = primary URL, 1 = fallback URL, 2 = proxy
  bool _hasError = false;
  static final Set<String> _failedProfileImageUrls = {};

  @override
  void initState() {
    super.initState();
    // Clear failed URLs for this specific image URL to allow retry
    _failedProfileImageUrls.remove(widget.imageUrl);
  }

  String _getFallbackUrl(String originalUrl) {
    // Extract filename from URL (handle cache busters and query params)
    final filename = originalUrl.split('/').last.split('?').first.split('#').first;
    
    // Convert Hostinger file server URLs to regular domain
    if (originalUrl.contains('srv1881-files.hstgr.io')) {
      return kProfileImageBaseUrl + filename;
    }
    // If using /storage/profiles/ (legacy), try with /public/
    if (originalUrl.contains('superdailys.com/storage/profiles/') && 
        !originalUrl.contains('/public/')) {
      return kProfileImageBaseUrl + filename;
    }
    // Already using correct path, return as is
    return originalUrl;
  }

  String _getProxiedUrl(String url) {
    // Apply cache buster to the original URL before encoding for proxy
    final urlWithCacheBuster = _applyCacheBuster(url);
    final encodedUrl = Uri.encodeComponent(urlWithCacheBuster);
    return 'https://superdailys.com/superdailyapp/proxy_image.php?url=$encodedUrl';
  }

  String _applyCacheBuster(String url) {
    final cacheBuster = widget.cacheBuster?.trim();
    if (cacheBuster == null || cacheBuster.isEmpty) {
      return url;
    }
    final separator = url.contains('?') ? '&' : '?';
    return '$url${separator}cb=$cacheBuster';
  }

  String _getCurrentImageUrl() {
    // 0 = primary URL (from API) - try first
    if (_currentUrlIndex == 0) {
      return _applyCacheBuster(widget.imageUrl);
    }
    // 1 = fallback URL (alternative server)
    if (_currentUrlIndex == 1) {
      return _applyCacheBuster(_getFallbackUrl(widget.imageUrl));
    }
    // 2 = proxy (fallback if direct URLs fail)
    // Cache buster is applied inside _getProxiedUrl to the original URL
    if (_currentUrlIndex == 2) {
      return _getProxiedUrl(widget.imageUrl);
    }
    return _applyCacheBuster(widget.imageUrl);
  }

  @override
  Widget build(BuildContext context) {
    if (_hasError && _currentUrlIndex >= 2) {
      // All URLs failed, show fallback icon
      return Icon(
        Icons.person,
        size: widget.radius,
        color: widget.iconColor,
      );
    }

    final imageUrl = _getCurrentImageUrl();
    if (imageUrl.isEmpty) {
      return Icon(
        Icons.person,
        size: widget.radius,
        color: widget.iconColor,
      );
    }

    final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
    // Only log if not a network error to reduce console spam
    if (!_failedProfileImageUrls.contains(imageUrl)) {
      debugPrint('ðŸ–¼ï¸ Profile - Trying to load image ($urlType) for user ${widget.userId}: $imageUrl');
    }

    return ClipOval(
      child: Builder(
        builder: (context) {
          // Wrap in error boundary to catch and suppress Flutter framework errors
          return CachedNetworkImage(
            key: ValueKey('${imageUrl}_${_currentUrlIndex}'), // Force rebuild on URL change
            imageUrl: imageUrl,
        width: widget.radius * 2,
        height: widget.radius * 2,
        fit: BoxFit.cover,
        httpHeaders: {
          'Accept': 'image/*',
        },
        maxWidthDiskCache: (widget.radius * 2).toInt(),
        maxHeightDiskCache: (widget.radius * 2).toInt(),
        memCacheWidth: (widget.radius * 2).toInt(),
        memCacheHeight: (widget.radius * 2).toInt(),
        cacheKey: 'profile_${widget.userId}_${widget.cacheBuster ?? '0'}_${_currentUrlIndex}_${widget.imageUrl.hashCode}', // Unique cache key per URL/fallback + cache busting
        placeholder: (context, url) => Container(
          width: widget.radius * 2,
          height: widget.radius * 2,
          color: widget.backgroundColor,
          child: Center(
            child: SizedBox(
              width: widget.radius * 0.6,
              height: widget.radius * 0.6,
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(widget.iconColor),
                strokeWidth: 2,
              ),
            ),
          ),
        ),
        fadeInDuration: const Duration(milliseconds: 200),
        fadeOutDuration: const Duration(milliseconds: 100),
        errorWidget: (context, url, error) {
          final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
          
          // Suppress logging for common network errors (statusCode: 0 usually means network/CORS issue)
          final errorString = error.toString();
          final isNetworkError = errorString.contains('statusCode: 0') || 
                                 errorString.contains('HTTP request failed') ||
                                 errorString.contains('SocketException') ||
                                 errorString.contains('Failed host lookup');
          
          // Only log error once per URL to prevent spam, and skip network errors
          if (!_failedProfileImageUrls.contains(url) && !isNetworkError) {
            _failedProfileImageUrls.add(url);
            debugPrint('âŒ Profile image failed to load ($urlType) for user ${widget.userId}: $url');
            debugPrint('   Error type: ${error.runtimeType}');
            debugPrint('   Error: $error');
          } else if (isNetworkError && !_failedProfileImageUrls.contains(url)) {
            // Silently mark network errors as failed to prevent retry spam
            _failedProfileImageUrls.add(url);
          }

          // Try fallback URL (alternative server)
          if (_currentUrlIndex == 0) {
            Future.microtask(() {
              if (mounted) {
                setState(() {
                  _currentUrlIndex = 1; // Try fallback URL
                  _hasError = false; // Reset error state for retry
                });
              }
            });
            return Container(
              width: widget.radius * 2,
              height: widget.radius * 2,
              color: widget.backgroundColor,
              child: Center(
                child: SizedBox(
                  width: widget.radius * 0.6,
                  height: widget.radius * 0.6,
                  child: CircularProgressIndicator(
                    valueColor: AlwaysStoppedAnimation<Color>(widget.iconColor),
                    strokeWidth: 2,
                  ),
                ),
              ),
            );
          }
          
          // Try proxy if fallback URL also failed
          if (_currentUrlIndex == 1) {
            Future.microtask(() {
              if (mounted) {
                setState(() {
                  _currentUrlIndex = 2; // Try proxy
                  _hasError = false; // Reset error state for retry
                });
              }
            });
            return Container(
              width: widget.radius * 2,
              height: widget.radius * 2,
              color: widget.backgroundColor,
              child: Center(
                child: SizedBox(
                  width: widget.radius * 0.6,
                  height: widget.radius * 0.6,
                  child: CircularProgressIndicator(
                    valueColor: AlwaysStoppedAnimation<Color>(widget.iconColor),
                    strokeWidth: 2,
                  ),
                ),
              ),
            );
          }
          
          // All URLs failed
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _hasError = true;
              });
            }
          });
          return Icon(
            Icons.person,
            size: widget.radius,
            color: widget.iconColor,
          );
        },
          );
        },
      ),
    );
  }
}

// Widget for service details image with proxy fallback
class _ServiceDetailsImageWidget extends StatefulWidget {
  final String imageUrl;
  final String serviceName;

  const _ServiceDetailsImageWidget({
    required this.imageUrl,
    required this.serviceName,
  });

  @override
  State<_ServiceDetailsImageWidget> createState() => _ServiceDetailsImageWidgetState();
}

class _ServiceDetailsImageWidgetState extends State<_ServiceDetailsImageWidget> {
  int _currentUrlIndex = 0; // 0 = primary URL, 1 = fallback URL, 2 = proxy
  bool _hasError = false;

  String _getFallbackUrl(String originalUrl) {
    // Try to convert to fallback URL format
    // If it's from Hostinger file server, try superdailys.com
    if (originalUrl.contains('srv1881-files.hstgr.io')) {
      final filename = originalUrl.split('/').last.split('?').first.split('#').first;
      return 'https://superdailys.com/storage/services/' + filename;
    }
    // If it's from superdailys.com, try Hostinger file server
    if (originalUrl.contains('superdailys.com/storage/services/')) {
      final filename = originalUrl.split('/').last.split('?').first.split('#').first;
      return 'https://srv1881-files.hstgr.io/4663f5e73332121d/files/public_html/public/storage/services/' + filename;
    }
    return originalUrl;
  }

  String _getProxiedUrl(String url) {
    final encodedUrl = Uri.encodeComponent(url);
    return 'https://superdailys.com/superdailyapp/proxy_image.php?url=$encodedUrl';
  }

  String _getCurrentImageUrl() {
    // 0 = primary URL (from API)
    if (_currentUrlIndex == 0) {
      return widget.imageUrl;
    }
    // 1 = fallback URL (alternative server)
    if (_currentUrlIndex == 1) {
      return _getFallbackUrl(widget.imageUrl);
    }
    // 2 = proxy
    if (_currentUrlIndex == 2) {
      return _getProxiedUrl(widget.imageUrl);
    }
    return widget.imageUrl;
  }

  @override
  Widget build(BuildContext context) {
    if (_hasError) {
      return Container(
        color: Colors.grey.shade100,
        child: Center(
          child: Icon(
            Icons.image_not_supported,
            size: 64,
            color: Colors.grey.shade400,
          ),
        ),
      );
    }

    final imageUrl = _getCurrentImageUrl();
    final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
    debugPrint('ðŸ–¼ï¸ Service Details - Trying to load image ($urlType) for "${widget.serviceName}": $imageUrl');

    return CachedNetworkImage(
      imageUrl: imageUrl,
      fit: BoxFit.cover,
      httpHeaders: {
        'Accept': 'image/*',
      },
      placeholder: (context, url) => Container(
        color: Colors.grey.shade100,
        child: Center(
          child: CircularProgressIndicator(
            valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
          ),
        ),
      ),
      errorWidget: (context, url, error) {
        final urlType = ['primary', 'fallback', 'proxy'][_currentUrlIndex];
        debugPrint('âŒ Service Details - Image failed to load ($urlType) for "${widget.serviceName}": $url');
        debugPrint('   Error type: ${error.runtimeType}');
        debugPrint('   Error: $error');
        
        // Try fallback URL (alternative server)
        if (_currentUrlIndex == 0) {
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _currentUrlIndex = 1; // Try fallback URL
              });
            }
          });
          return Container(
            color: Colors.grey.shade100,
            child: Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            ),
          );
        }
        
        // Try proxy if fallback URL also failed
        if (_currentUrlIndex == 1) {
          Future.microtask(() {
            if (mounted) {
              setState(() {
                _currentUrlIndex = 2; // Try proxy
              });
            }
          });
          return Container(
            color: Colors.grey.shade100,
            child: Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            ),
          );
        }
        
        // All URLs failed
        Future.microtask(() {
          if (mounted) {
            setState(() {
              _hasError = true;
            });
          }
        });
        return Container(
          color: Colors.grey.shade100,
          child: Center(
            child: Icon(
              Icons.image_not_supported,
              size: 64,
              color: Colors.grey.shade400,
            ),
          ),
        );
      },
    );
  }
}

class AllServicesScreen extends StatefulWidget {
  const AllServicesScreen({super.key});

  @override
  State<AllServicesScreen> createState() => _AllServicesScreenState();
}

class _AllServicesScreenState extends State<AllServicesScreen> {
  List<dynamic> _services = [];
  bool _isLoading = true;
  static const Color _tealColor = Color(0xFF00BFA5);
  static const Color _priceDarkBlue = Color(0xFF0D47A1);
  
  // Favorite management functions
  Future<bool> _isFavorite(String type, String id) async {
    // Only show favorites if user is logged in
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    if (!isLoggedIn) return false;
    
    final key = type == 'product' ? 'favorite_products' : 'favorite_services';
    final favorites = prefs.getStringList(key) ?? [];
    return favorites.contains(id);
  }
  
  Future<void> _toggleFavorite(String type, String id) async {
    // Only allow favoriting if user is logged in
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    
    if (!isLoggedIn) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please login to add favorites'),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 2),
        ),
      );
      return;
    }
    
    final key = type == 'product' ? 'favorite_products' : 'favorite_services';
    final favorites = prefs.getStringList(key) ?? [];
    
    if (favorites.contains(id)) {
      favorites.remove(id);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Removed from favorites'),
          duration: Duration(seconds: 1),
        ),
      );
    } else {
      favorites.add(id);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Added to favorites'),
          duration: Duration(seconds: 1),
        ),
      );
    }
    await prefs.setStringList(key, favorites);
    setState(() {}); // Refresh UI
  }

  @override
  void initState() {
    super.initState();
    _fetchNonFeaturedServices();
  }

  Future<void> _fetchNonFeaturedServices() async {
    try {
      const String apiUrl = 'https://superdailys.com/superdailyapp/get_non_featured_services.php';
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            final services = data['services'] ?? [];
            setState(() {
              _services = services;
              _isLoading = false;
            });
          } else {
            setState(() {
              _services = [];
              _isLoading = false;
            });
          }
        } else {
          setState(() {
            _services = [];
            _isLoading = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        debugPrint('Error fetching non-featured services: $e');
        setState(() {
          _services = [];
          _isLoading = false;
        });
      }
    }
  }

  Widget _buildServiceCard(Map<String, dynamic> service) {
    final name = service['name'] ?? 'Service';
    final description = service['description'] ?? '';
    final List<String> serviceImages = [];
    
    for (var imgKey in ['image', 'image_2', 'image_3', 'image_4']) {
      final imgValue = service[imgKey];
      if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
        final rawUrl = imgValue.toString().trim();
        if (rawUrl.startsWith('https://superdailys.com/storage/services/')) {
          serviceImages.add(rawUrl);
        } else if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
          serviceImages.add(rawUrl);
        } else {
          String filename = rawUrl.split('/').last.split('\\').last;
          filename = filename.split('?').first.split('#').first;
          if (filename.isNotEmpty && filename.contains('.')) {
            serviceImages.add('https://superdailys.com/storage/services/' + filename);
          }
        }
      }
    }
    
    final priceNum = _parsePrice(service['price']) ?? 0.0;
    final discountPriceNum = _parsePrice(service['discount_price']);
    final displayPrice = discountPriceNum ?? priceNum;
    final hasDiscount = discountPriceNum != null && discountPriceNum > 0 && discountPriceNum < priceNum;

    return GestureDetector(
      onTap: () {
        final dynamic rawId = service['id'];
        final int intId = rawId is int ? rawId : int.tryParse(rawId?.toString() ?? '0') ?? 0;
        if (intId > 0) {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => ServiceDetailsScreen(serviceId: intId),
            ),
          );
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Image with Heart Icon
            Stack(
              children: [
                Container(
                  width: 120,
                  height: 120,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade100,
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(16),
                      bottomLeft: Radius.circular(16),
                    ),
                  ),
                  child: serviceImages.isNotEmpty
                      ? ClipRRect(
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            bottomLeft: Radius.circular(16),
                          ),
                          child: CachedNetworkImage(
                            imageUrl: serviceImages.first,
                            fit: BoxFit.cover,
                            placeholder: (context, url) => Center(
                              child: CircularProgressIndicator(
                                valueColor: AlwaysStoppedAnimation<Color>(_tealColor),
                              ),
                            ),
                        errorWidget: (context, url, error) => Icon(
                          Icons.room_service,
                          size: 40,
                          color: Colors.grey.shade400,
                        ),
                      ),
                    )
                  : Icon(
                      Icons.room_service,
                      size: 40,
                      color: Colors.grey.shade400,
                    ),
                ),
                Positioned(
                  top: 6,
                  right: 6,
                  child: FutureBuilder<bool>(
                    future: _isFavorite('service', service['id'].toString()),
                    builder: (context, snapshot) {
                      final isFav = snapshot.data ?? false;
                      return GestureDetector(
                        onTap: () => _toggleFavorite('service', service['id'].toString()),
                        child: Container(
                          padding: const EdgeInsets.all(4),
                          decoration: BoxDecoration(
                            color: Colors.white.withOpacity(0.9),
                            shape: BoxShape.circle,
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.1),
                                blurRadius: 4,
                                offset: const Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Icon(
                            isFav ? Icons.favorite : Icons.favorite_border,
                            size: 16,
                            color: isFav ? Colors.red : Colors.grey.shade600,
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
            // Content
            Expanded(
              child: Padding(
                padding: const EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      name,
                      style: GoogleFonts.poppins(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: Colors.grey.shade800,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    if (description.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        description,
                        style: GoogleFonts.poppins(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                    const SizedBox(height: 8),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'â‚¹${displayPrice.toStringAsFixed(2)}',
                              style: GoogleFonts.poppins(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                                color: _priceDarkBlue,
                              ),
                            ),
                            if (hasDiscount)
                              Text(
                                'â‚¹${priceNum.toStringAsFixed(2)}',
                                style: GoogleFonts.poppins(
                                  fontSize: 12,
                                  decoration: TextDecoration.lineThrough,
                                  color: Colors.grey.shade500,
                                ),
                              ),
                          ],
                        ),
                        Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: _tealColor,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: const Icon(
                            Icons.arrow_forward,
                            color: Colors.white,
                            size: 16,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  double? _parsePrice(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) {
      final cleaned = value.replaceAll(RegExp(r'[^\d.]'), '');
      final parsed = double.tryParse(cleaned);
      return parsed;
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        title: Text(
          'All Services',
          style: GoogleFonts.poppins(
            fontWeight: FontWeight.bold,
          ),
        ),
        backgroundColor: _tealColor,
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: _isLoading
          ? const Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            )
          : _services.isEmpty
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.room_service_outlined,
                        size: 64,
                        color: Colors.grey.shade400,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'No services available',
                        style: GoogleFonts.poppins(
                          fontSize: 16,
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                  ),
                )
              : RefreshIndicator(
                  onRefresh: _fetchNonFeaturedServices,
                  color: _tealColor,
                  child: ListView(
                    padding: const EdgeInsets.all(16),
                    children: _services.map((service) => _buildServiceCard(service)).toList(),
                  ),
                ),
    );
  }
}

class ForgotPasswordDialog extends StatefulWidget {
  const ForgotPasswordDialog({super.key});

  @override
  State<ForgotPasswordDialog> createState() => _ForgotPasswordDialogState();
}

class _ForgotPasswordDialogState extends State<ForgotPasswordDialog> {
  final _formKey = GlobalKey<FormState>();
  final _phoneController = TextEditingController();
  final _otpController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  
  String _step = 'phone'; // 'phone', 'otp', 'reset'
  bool _isLoading = false;
  String? _otpSentPhone;
  bool _obscureNewPassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void dispose() {
    _phoneController.dispose();
    _otpController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _sendOTP() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        _isLoading = true;
      });

      try {
        final response = await http.post(
          Uri.parse('${kBackendBaseUrl}generate_otp.php'),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode({
            'phone': _phoneController.text.trim(),
          }),
        );

        if (mounted) {
          setState(() {
            _isLoading = false;
          });

          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            setState(() {
              _step = 'otp';
              _otpSentPhone = _phoneController.text.trim();
            });
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'OTP sent successfully'),
                backgroundColor: Colors.green,
              ),
            );
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Failed to send OTP'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      } catch (e) {
        if (mounted) {
          setState(() {
            _isLoading = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  Future<void> _verifyOTP() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        _isLoading = true;
      });

      try {
        final response = await http.post(
          Uri.parse('${kBackendBaseUrl}verify_otp.php'),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode({
            'phone': _otpSentPhone,
            'otp': _otpController.text.trim(),
          }),
        );

        if (mounted) {
          setState(() {
            _isLoading = false;
          });

          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            setState(() {
              _step = 'reset';
            });
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Invalid OTP'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      } catch (e) {
        if (mounted) {
          setState(() {
            _isLoading = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  Future<void> _verifyOTPAndReset() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        _isLoading = true;
      });

      try {
        final response = await http.post(
          Uri.parse('${kBackendBaseUrl}reset_password.php'),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode({
            'phone': _otpSentPhone,
            'otp': _otpController.text.trim(),
            'new_password': _newPasswordController.text,
            'confirm_password': _confirmPasswordController.text,
          }),
        );

        if (mounted) {
          setState(() {
            _isLoading = false;
          });

          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Password reset successfully'),
                backgroundColor: Colors.green,
              ),
            );
            Navigator.of(context).pop();
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Failed to reset password'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      } catch (e) {
        if (mounted) {
          setState(() {
            _isLoading = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  String? _validatePhone(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter your phone number';
    }
    if (value.length < 10) {
      return 'Please enter a valid phone number';
    }
    return null;
  }

  String? _validateOTP(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter OTP';
    }
    if (value.length != 6) {
      return 'OTP must be 6 digits';
    }
    return null;
  }

  String? _validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter new password';
    }
    if (value.length < 6) {
      return 'Password must be at least 6 characters';
    }
    return null;
  }

  String? _validateConfirmPassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please confirm password';
    }
    if (value != _newPasswordController.text) {
      return 'Passwords do not match';
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Container(
        padding: const EdgeInsets.all(24),
        constraints: const BoxConstraints(maxWidth: 400),
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      _step == 'phone' 
                          ? 'Forgot Password'
                          : _step == 'otp'
                              ? 'Verify OTP'
                              : 'Reset Password',
                      style: GoogleFonts.poppins(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: Colors.grey.shade800,
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () => Navigator.of(context).pop(),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                
                if (_step == 'phone') ...[
                  Text(
                    'Enter your phone number to receive OTP',
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      color: Colors.grey.shade600,
                    ),
                  ),
                  const SizedBox(height: 20),
                  TextFormField(
                    controller: _phoneController,
                    keyboardType: TextInputType.number,
                    inputFormatters: [
                      FilteringTextInputFormatter.digitsOnly,
                      LengthLimitingTextInputFormatter(10),
                    ],
                    decoration: InputDecoration(
                      labelText: 'Phone Number',
                      hintText: 'Enter 10 digits (e.g., 9876543210)',
                      helperText: 'Must be exactly 10 digits',
                      prefixIcon: const Icon(Icons.phone_outlined),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      filled: true,
                      fillColor: Colors.grey.shade50,
                    ),
                    validator: _validatePhone,
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: _isLoading ? null : _sendOTP,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF00BFA5),
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : Text(
                            'Send OTP',
                            style: GoogleFonts.poppins(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                  ),
                ] else if (_step == 'otp') ...[
                  Text(
                    'Enter the OTP sent to ${_otpSentPhone}',
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      color: Colors.grey.shade600,
                    ),
                  ),
                  const SizedBox(height: 20),
                  TextFormField(
                    controller: _otpController,
                    keyboardType: TextInputType.number,
                    maxLength: 6,
                    decoration: InputDecoration(
                      labelText: 'OTP',
                      prefixIcon: const Icon(Icons.lock_outline),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      filled: true,
                      fillColor: Colors.grey.shade50,
                    ),
                    validator: _validateOTP,
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      TextButton(
                        onPressed: () => setState(() => _step = 'phone'),
                        child: Text(
                          'Change Phone',
                          style: GoogleFonts.poppins(color: const Color(0xFF00BFA5)),
                        ),
                      ),
                      const Spacer(),
                      TextButton(
                        onPressed: _isLoading ? null : _sendOTP,
                        child: Text(
                          'Resend OTP',
                          style: GoogleFonts.poppins(color: const Color(0xFF00BFA5)),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  ElevatedButton(
                    onPressed: _isLoading ? null : _verifyOTP,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF00BFA5),
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : Text(
                            'Verify OTP',
                            style: GoogleFonts.poppins(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                  ),
                ] else if (_step == 'reset') ...[
                  Text(
                    'Enter your new password',
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      color: Colors.grey.shade600,
                    ),
                  ),
                  const SizedBox(height: 20),
                  TextFormField(
                    controller: _newPasswordController,
                    obscureText: _obscureNewPassword,
                    decoration: InputDecoration(
                      labelText: 'New Password',
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscureNewPassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscureNewPassword = !_obscureNewPassword);
                        },
                      ),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      filled: true,
                      fillColor: Colors.grey.shade50,
                    ),
                    validator: _validatePassword,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _confirmPasswordController,
                    obscureText: _obscureConfirmPassword,
                    decoration: InputDecoration(
                      labelText: 'Confirm Password',
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscureConfirmPassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscureConfirmPassword = !_obscureConfirmPassword);
                        },
                      ),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      filled: true,
                      fillColor: Colors.grey.shade50,
                    ),
                    validator: _validateConfirmPassword,
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: _isLoading ? null : _verifyOTPAndReset,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF00BFA5),
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : Text(
                            'Reset Password',
                            style: GoogleFonts.poppins(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class BookingDetailsScreen extends StatefulWidget {
  final Map<String, dynamic> booking;

  const BookingDetailsScreen({super.key, required this.booking});

  @override
  State<BookingDetailsScreen> createState() => _BookingDetailsScreenState();
}

class _BookingDetailsScreenState extends State<BookingDetailsScreen> {
  DateTime? _delayFromDate;
  DateTime? _delayToDate;
  String _delayReason = '';
  bool _isSaving = false;
  final TextEditingController _reasonController = TextEditingController();
  String? _dateRangeError;
  String? _weekMonthError;
  final ValueNotifier<DateTime?> _selectedFromDateNotifier = ValueNotifier<DateTime?>(null);
  final ValueNotifier<DateTime?> _selectedToDateNotifier = ValueNotifier<DateTime?>(null);

  @override
  void initState() {
    super.initState();
    // Initialize from booking data
    _delayFromDate = _tryParseDate(widget.booking['delay_from_month']?.toString());
    _delayToDate = _tryParseDate(widget.booking['delay_to_month']?.toString());
    _delayReason = widget.booking['delay_reason']?.toString() ?? '';
    _reasonController.text = _delayReason;
    _selectedFromDateNotifier.value = _delayFromDate;
    _selectedToDateNotifier.value = _delayToDate;
  }

  @override
  void dispose() {
    _reasonController.dispose();
    _selectedFromDateNotifier.dispose();
    _selectedToDateNotifier.dispose();
    super.dispose();
  }

  DateTime? _tryParseDate(String? dateStr) {
    if (dateStr == null || dateStr.isEmpty) return null;
    try {
      return DateTime.parse(dateStr);
    } catch (e) {
      return null;
    }
  }

  String _formatDisplayDateFromDateTime(DateTime? date, {bool useEmptyPlaceholder = false}) {
    if (date == null) {
      return useEmptyPlaceholder ? 'Not set' : '';
    }
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }

  // Get the week number of the month for a given date (1-4 or 5)
  int _getWeekOfMonth(DateTime date) {
    final firstDayOfMonth = DateTime(date.year, date.month, 1);
    final firstDayWeekday = firstDayOfMonth.weekday; // 1 = Monday, 7 = Sunday
    final dayOfMonth = date.day;
    // Calculate which week of the month this day falls into
    return ((dayOfMonth + firstDayWeekday - 2) ~/ 7) + 1;
  }

  // Check if two date ranges are in the same week and month
  bool _isInSameWeekAndMonth(DateTime from1, DateTime to1, DateTime from2, DateTime to2) {
    // Check if they're in the same month and year
    if (from1.year != from2.year || from1.month != from2.month) {
      return false;
    }
    
    // Get week numbers for both ranges
    final week1 = _getWeekOfMonth(from1);
    final week2 = _getWeekOfMonth(from2);
    
    // Check if they're in the same week
    return week1 == week2;
  }

  // Check if user has already applied for dates in the same week/month
  Future<bool> _hasExistingApplicationInSameWeekMonth(DateTime fromDate, DateTime toDate) async {
    try {
      final userId = widget.booking['user_id'];
      if (userId == null) return false;

      final apiUrl = '${kBackendBaseUrl}get_my_bookings.php?user_id=$userId';
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true && data['bookings'] != null) {
          final bookings = data['bookings'] as List;
          
          for (var booking in bookings) {
            // Skip the current booking
            if (booking['id'] == widget.booking['id']) {
              continue;
            }
            
            final existingFromStr = booking['delay_from_month']?.toString();
            final existingToStr = booking['delay_to_month']?.toString();
            
            if (existingFromStr != null && existingToStr != null && 
                existingFromStr.isNotEmpty && existingToStr.isNotEmpty) {
              try {
                final existingFrom = DateTime.parse(existingFromStr);
                final existingTo = DateTime.parse(existingToStr);
                
                // Check if the existing application is in the same week and month
                if (_isInSameWeekAndMonth(fromDate, toDate, existingFrom, existingTo)) {
                  return true;
                }
              } catch (e) {
                debugPrint('Error parsing existing dates: $e');
              }
            }
          }
        }
      }
    } catch (e) {
      debugPrint('Error checking existing applications: $e');
      // If we can't check, allow the submission (fail open)
    }
    return false;
  }

  bool _isMonthlySubscriptionBooking(Map<String, dynamic> booking) {
    // PRIMARY CHECK: subscription_plan field - most reliable indicator
    final plan = booking['subscription_plan']?.toString().trim().toLowerCase() ?? '';
    if (plan.isNotEmpty && (plan == 'monthly' || plan.contains('month'))) {
      return true;
    }
    
    // SECONDARY CHECK: selected_price_option field
    final selectedPriceOption = booking['selected_price_option']?.toString().trim().toLowerCase() ?? '';
    if (selectedPriceOption.isNotEmpty) {
      if (selectedPriceOption.contains('monthly') || 
          selectedPriceOption.contains('subscription') ||
          selectedPriceOption == 'monthly subscription' ||
          selectedPriceOption.startsWith('monthly')) {
        return true;
      }
    }
    
    // TERTIARY CHECK: subscription_plan_details field
    if (booking.containsKey('subscription_plan_details') && booking['subscription_plan_details'] != null) {
      final details = _parseSubscriptionPlanDetails(booking['subscription_plan_details']);
      if (details != null) {
        final planType = details['plan_type']?.toString().toLowerCase() ?? '';
        final billingCycle = details['billing_cycle']?.toString().toLowerCase() ?? '';
        if ((planType.isNotEmpty && (planType == 'monthly' || planType.contains('month'))) ||
            (billingCycle.isNotEmpty && (billingCycle == 'monthly' || billingCycle.contains('month')))) {
          return true;
        }
        
        if (details['start_date'] != null && details['end_date'] != null) {
          return true;
        }
      }
    }
    
    // FALLBACK CHECK: service name
    final serviceName = (booking['service_name'] ?? '').toString().toLowerCase();
    if (serviceName.contains('monthly') || serviceName.contains('subscription')) {
      return true;
    }
    
    return false;
  }

  Map<String, dynamic>? _parseSubscriptionPlanDetails(dynamic rawDetails) {
    if (rawDetails == null) return null;
    if (rawDetails is Map<String, dynamic>) return rawDetails;
    if (rawDetails is String && rawDetails.trim().isNotEmpty) {
      try {
        final decoded = jsonDecode(rawDetails);
        if (decoded is Map<String, dynamic>) {
          return decoded.cast<String, dynamic>();
        }
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  List<String> _extractServiceDays(Map<String, dynamic>? details) {
    if (details == null || details['service_days'] == null) return [];
    final value = details['service_days'];
    if (value is List) {
      return value.map((e) => e.toString()).toList();
    }
    if (value is String && value.isNotEmpty) {
      try {
        final decoded = jsonDecode(value);
        if (decoded is List) {
          return decoded.map((e) => e.toString()).toList();
        }
      } catch (_) {
        return [];
      }
    }
    return [];
  }

  // Validate dates immediately and update error states
  Future<void> _validateDatesImmediately() async {
    setState(() {
      _dateRangeError = null;
      _weekMonthError = null;
    });

    if (_delayFromDate == null || _delayToDate == null) {
      return;
    }

    // Check date range
    final daysDifference = _delayToDate!.difference(_delayFromDate!).inDays;
    if (daysDifference > 7) {
      setState(() {
        _dateRangeError = 'The date range cannot exceed 7 days';
      });
      return;
    }

    // Check for existing application in same week/month
    final hasExisting = await _hasExistingApplicationInSameWeekMonth(_delayFromDate!, _delayToDate!);
    if (hasExisting) {
      setState(() {
        _weekMonthError = 'You have already applied for dates in this week of this month';
      });
    }
  }

  Future<void> _saveDelayInfo() async {
    if (_isSaving) return;

    setState(() {
      _isSaving = true;
    });

    try {
      final bookingId = widget.booking['id'];
      if (bookingId == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Booking ID not found')),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      // Validation: Check if both dates are selected
      if (_delayFromDate == null || _delayToDate == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please select both From Date and To Date'),
            backgroundColor: Colors.orange,
          ),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      // Validation: Check that date range does not exceed 7 days
      final daysDifference = _delayToDate!.difference(_delayFromDate!).inDays;
      if (daysDifference > 7) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('The date range cannot exceed 7 days. Please select dates within 7 days.'),
            backgroundColor: Colors.orange,
          ),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      // Validation: Check if user has already applied for dates in the same week/month
      final hasExisting = await _hasExistingApplicationInSameWeekMonth(_delayFromDate!, _delayToDate!);
      if (hasExisting) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('You have already applied for dates in this week of this month. You can only apply once per week per month.'),
            backgroundColor: Colors.orange,
          ),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      final payload = {
        'booking_id': bookingId,
        'delay_from_month': _delayFromDate?.toIso8601String(),
        'delay_to_month': _delayToDate?.toIso8601String(),
        'delay_reason': _reasonController.text.trim(),
      };

      final response = await http.post(
        Uri.parse('${kBackendBaseUrl}update_booking_delay.php'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(payload),
      ).timeout(const Duration(seconds: 30));

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Service window updated successfully'),
              backgroundColor: Colors.green,
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(data['message'] ?? 'Failed to update service window'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to update service window'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      debugPrint('Error updating booking delay: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('An error occurred. Please try again.'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSaving = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Debug: Print booking data to see what we're receiving
    print('ðŸ” Booking Details - maid_id: ${widget.booking['maid_id']}');
    print('ðŸ” Booking Details - maid_info: ${widget.booking['maid_info']}');
    
    final maidInfo = widget.booking['maid_info'];
    final bookingDate = widget.booking['booking_date'] ?? '';
    final bookingTime = widget.booking['booking_time'] ?? '';
    final status = widget.booking['status'] ?? 'pending';
    final paymentStatus = widget.booking['payment_status'] ?? 'pending';
    final finalAmount = double.tryParse(widget.booking['final_amount']?.toString() ?? '0') ?? 0.0;
    final address = widget.booking['address'] ?? 'No address';
    final phone = widget.booking['phone'] ?? '';
    final serviceId = widget.booking['service_id'];
    final bookingRef = widget.booking['booking_reference'] ?? 'N/A';
    final assignedAt = widget.booking['assigned_at'];
    final assignedBy = widget.booking['assigned_by'];
    final assignmentNotes = widget.booking['assignment_notes'];
    final specialInstructions = widget.booking['special_instructions'] ?? '';
    final durationHours = widget.booking['duration_hours'];
    final totalAmount = double.tryParse(widget.booking['total_amount']?.toString() ?? '0') ?? 0.0;
    final discountAmount = double.tryParse(widget.booking['discount_amount']?.toString() ?? '0') ?? 0.0;
    final paymentMethod = widget.booking['payment_method'];
    final paymentId = widget.booking['payment_id'];
    final transactionId = widget.booking['transaction_id'];
    final paymentCompletedAt = widget.booking['payment_completed_at'];
    final customerNotes = widget.booking['customer_notes'];
    final maidNotes = widget.booking['maid_notes'];
    final confirmedAt = widget.booking['confirmed_at'];
    final startedAt = widget.booking['started_at'];
    final completedAt = widget.booking['completed_at'];
    final cancelledAt = widget.booking['cancelled_at'];
    final createdAt = widget.booking['created_at'];
    final serviceRequirements = widget.booking['service_requirements'] ?? '';
    final bookingDateTime = _resolveBookingDate(bookingDate, createdAt);
    final hasAccurateBookingDate = bookingDateTime != null;
    int daysSinceBooking = 0;
    bool cancellationUnlocked = false;
    int daysRemainingForCancellation = 0;
    DateTime? cancellationUnlockDate;

    if (bookingDateTime != null) {
      daysSinceBooking = DateTime.now().difference(bookingDateTime).inDays;
      cancellationUnlocked = daysSinceBooking >= 4;

      if (!cancellationUnlocked) {
        final remaining = 4 - daysSinceBooking;
        if (remaining > 0) {
          daysRemainingForCancellation = remaining;
        }
      }

      cancellationUnlockDate = bookingDateTime.add(const Duration(days: 4));
    }

    // Status colors
    Color statusColor;
    String statusText;
    switch (status.toLowerCase()) {
      case 'confirmed':
        statusColor = Colors.green;
        statusText = 'Confirmed';
        break;
      case 'completed':
        statusColor = Colors.blue;
        statusText = 'Completed';
        break;
      case 'cancelled':
        statusColor = Colors.red;
        statusText = 'Cancelled';
        break;
      case 'in_progress':
      case 'started':
        statusColor = Colors.orange;
        statusText = 'In Progress';
        break;
      default:
        statusColor = Colors.grey;
        statusText = 'Pending';
    }

    // Payment status colors
    Color paymentColor;
    String paymentText;
    switch (paymentStatus.toLowerCase()) {
      case 'paid':
      case 'completed':
        paymentColor = Colors.green;
        paymentText = 'Paid';
        break;
      case 'failed':
        paymentColor = Colors.red;
        paymentText = 'Failed';
        break;
      case 'pending':
      default:
        paymentColor = Colors.orange;
        paymentText = 'Pending';
    }

    return Scaffold(
      backgroundColor: const Color(0xFFF5F7FA),
      appBar: AppBar(
        title: Text(
          'Booking Details',
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold, fontSize: 20),
        ),
        backgroundColor: const Color(0xFF00BFA5),
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                const Color(0xFF00BFA5),
                const Color(0xFF00ACC1),
              ],
            ),
          ),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Booking Reference and Status Card - Enhanced Design
            Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: [
                    Colors.white,
                    Colors.grey.shade50,
                  ],
                ),
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.08),
                    blurRadius: 20,
                    offset: const Offset(0, 8),
                    spreadRadius: 0,
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Container(
                          padding: const EdgeInsets.all(10),
                          decoration: BoxDecoration(
                            color: const Color(0xFF00BFA5).withOpacity(0.1),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: const Icon(
                            Icons.receipt_long,
                            color: Color(0xFF00BFA5),
                            size: 24,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Booking Reference',
                                style: GoogleFonts.poppins(
                                  fontSize: 11,
                                  color: Colors.grey.shade600,
                                  letterSpacing: 0.5,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                bookingRef,
                                style: GoogleFonts.poppins(
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.grey.shade900,
                                  letterSpacing: 0.5,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    Row(
                      children: [
                        Expanded(
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                            decoration: BoxDecoration(
                              gradient: LinearGradient(
                                colors: [
                                  statusColor.withOpacity(0.15),
                                  statusColor.withOpacity(0.08),
                                ],
                              ),
                              borderRadius: BorderRadius.circular(12),
                              border: Border.all(
                                color: statusColor.withOpacity(0.3),
                                width: 1.5,
                              ),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Container(
                                  width: 8,
                                  height: 8,
                                  decoration: BoxDecoration(
                                    color: statusColor,
                                    shape: BoxShape.circle,
                                  ),
                                ),
                                const SizedBox(width: 8),
                                Text(
                                  statusText,
                                  style: GoogleFonts.poppins(
                                    fontSize: 13,
                                    fontWeight: FontWeight.w600,
                                    color: statusColor,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                        const SizedBox(width: 10),
                        Expanded(
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                            decoration: BoxDecoration(
                              gradient: LinearGradient(
                                colors: [
                                  paymentColor.withOpacity(0.15),
                                  paymentColor.withOpacity(0.08),
                                ],
                              ),
                              borderRadius: BorderRadius.circular(12),
                              border: Border.all(
                                color: paymentColor.withOpacity(0.3),
                                width: 1.5,
                              ),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Container(
                                  width: 8,
                                  height: 8,
                                  decoration: BoxDecoration(
                                    color: paymentColor,
                                    shape: BoxShape.circle,
                                  ),
                                ),
                                const SizedBox(width: 8),
                                Text(
                                  paymentText,
                                  style: GoogleFonts.poppins(
                                    fontSize: 13,
                                    fontWeight: FontWeight.w600,
                                    color: paymentColor,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 20),

            // Booking Information - Enhanced Design
            _buildSectionTitle('Booking Information', Icons.calendar_today),
            Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.06),
                    blurRadius: 15,
                    offset: const Offset(0, 5),
                    spreadRadius: 0,
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    if (serviceId != null) _buildEnhancedDetailRow(Icons.tag, 'Service ID', serviceId.toString()),
                    if (bookingDate.isNotEmpty) ...[
                      if (serviceId != null) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.event, 'Date', bookingDate),
                    ],
                    if (bookingTime.isNotEmpty) ...[
                      if (bookingDate.isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.access_time, 'Time', bookingTime),
                    ],
                    if (durationHours != null) ...[
                      if (bookingTime.isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.timer, 'Duration', '${durationHours} hours'),
                    ],
                    if (address.isNotEmpty) ...[
                      if (durationHours != null || bookingTime.isNotEmpty || bookingDate.isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.location_on, 'Address', address, isMultiline: true),
                    ],
                    if (phone.isNotEmpty) ...[
                      if (address.isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.phone, 'Phone', phone),
                    ],
                    if (specialInstructions.isNotEmpty) ...[
                      const SizedBox(height: 20),
                      Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Colors.amber.shade50,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(
                            color: Colors.amber.shade200,
                            width: 1,
                          ),
                        ),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Icon(Icons.info_outline, color: Colors.amber.shade700, size: 20),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    'Special Instructions',
                                    style: GoogleFonts.poppins(
                                      fontSize: 12,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.amber.shade900,
                                    ),
                                  ),
                                  const SizedBox(height: 6),
                                  Text(
                                    _cleanText(specialInstructions),
                                    style: GoogleFonts.poppins(
                                      fontSize: 13,
                                      color: Colors.grey.shade800,
                                      height: 1.5,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 20),

            // Payment Information - Enhanced Design
            _buildSectionTitle('Payment Information', Icons.payment),
            Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: [
                    Colors.white,
                    const Color(0xFF00BFA5).withOpacity(0.02),
                  ],
                ),
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.06),
                    blurRadius: 15,
                    offset: const Offset(0, 5),
                    spreadRadius: 0,
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    if (totalAmount > 0)
                      _buildEnhancedDetailRow(Icons.receipt, 'Total Amount', 'â‚¹${totalAmount.toStringAsFixed(2)}'),
                    if (discountAmount > 0) ...[
                      if (totalAmount > 0) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.local_offer, 'Discount', 'â‚¹${discountAmount.toStringAsFixed(2)}', textColor: Colors.green),
                    ],
                    const SizedBox(height: 20),
                    Container(
                      padding: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          colors: [
                            const Color(0xFF00BFA5).withOpacity(0.1),
                            const Color(0xFF00ACC1).withOpacity(0.05),
                          ],
                        ),
                        borderRadius: BorderRadius.circular(16),
                        border: Border.all(
                          color: const Color(0xFF00BFA5).withOpacity(0.3),
                          width: 2,
                        ),
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Row(
                            children: [
                              Container(
                                padding: const EdgeInsets.all(8),
                                decoration: BoxDecoration(
                                  color: const Color(0xFF00BFA5).withOpacity(0.2),
                                  borderRadius: BorderRadius.circular(10),
                                ),
                                child: const Icon(
                                  Icons.account_balance_wallet,
                                  color: Color(0xFF00BFA5),
                                  size: 24,
                                ),
                              ),
                              const SizedBox(width: 12),
                              Text(
                                'Final Amount',
                                style: GoogleFonts.poppins(
                                  fontSize: 14,
                                  fontWeight: FontWeight.w600,
                                  color: Colors.grey.shade700,
                                ),
                              ),
                            ],
                          ),
                          Text(
                            'â‚¹${finalAmount.toStringAsFixed(2)}',
                            style: GoogleFonts.poppins(
                              fontSize: 22,
                              fontWeight: FontWeight.bold,
                              color: const Color(0xFF00BFA5),
                            ),
                          ),
                        ],
                      ),
                    ),
                    if (paymentMethod != null && paymentMethod.toString().isNotEmpty) ...[
                      const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.credit_card, 'Payment Method', paymentMethod.toString()),
                    ],
                    if (paymentId != null && paymentId.toString().isNotEmpty) ...[
                      const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.fingerprint, 'Payment ID', paymentId.toString()),
                    ],
                    if (transactionId != null && transactionId.toString().isNotEmpty) ...[
                      const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.receipt_long, 'Transaction ID', transactionId.toString()),
                    ],
                    if (paymentCompletedAt != null && paymentCompletedAt.toString().isNotEmpty) ...[
                      const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.check_circle, 'Paid At', paymentCompletedAt.toString()),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 20),

            // Maid Assignment Information - Enhanced Design
            _buildSectionTitle('Maid Assignment', Icons.person),
            Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.06),
                    blurRadius: 15,
                    offset: const Offset(0, 5),
                    spreadRadius: 0,
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    if (maidInfo != null && maidInfo is Map) ...[
                      _buildEnhancedDetailRow(Icons.badge, 'Maid ID', widget.booking['maid_id']?.toString() ?? 'N/A'),
                      const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.person_outline, 'Maid Name', maidInfo['name'] ?? 'N/A'),
                      if (maidInfo['phone'] != null && maidInfo['phone'].toString().isNotEmpty) ...[
                        const SizedBox(height: 16),
                        _buildEnhancedDetailRow(Icons.phone, 'Maid Phone', maidInfo['phone'].toString()),
                      ],
                      if (maidInfo['email'] != null && maidInfo['email'].toString().isNotEmpty) ...[
                        const SizedBox(height: 16),
                        _buildEnhancedDetailRow(Icons.email, 'Maid Email', maidInfo['email'].toString()),
                      ],
                    ] else if (widget.booking['maid_id'] != null && widget.booking['maid_id'].toString().isNotEmpty) ...[
                      _buildEnhancedDetailRow(Icons.badge, 'Maid ID', widget.booking['maid_id'].toString()),
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Colors.orange.shade50,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(
                            color: Colors.orange.shade200,
                            width: 1,
                          ),
                        ),
                        child: Row(
                          children: [
                            Icon(Icons.info_outline, color: Colors.orange.shade700, size: 20),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                'Maid information not available',
                                style: GoogleFonts.poppins(
                                  fontSize: 14,
                                  color: Colors.orange.shade900,
                                  fontStyle: FontStyle.italic,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ] else ...[
                      Container(
                        padding: const EdgeInsets.all(20),
                        decoration: BoxDecoration(
                          color: Colors.grey.shade100,
                          borderRadius: BorderRadius.circular(16),
                          border: Border.all(
                            color: Colors.grey.shade300,
                            width: 1.5,
                            style: BorderStyle.solid,
                          ),
                        ),
                        child: Row(
                          children: [
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: Colors.grey.shade300,
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: const Icon(
                                Icons.person_off,
                                color: Colors.grey,
                                size: 24,
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: Text(
                                'Maid not yet assigned',
                                style: GoogleFonts.poppins(
                                  fontSize: 15,
                                  color: Colors.grey.shade700,
                                  fontWeight: FontWeight.w500,
                                  fontStyle: FontStyle.italic,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                    if (assignedAt != null && assignedAt.toString().isNotEmpty) ...[
                      if (maidInfo != null || (widget.booking['maid_id'] != null && widget.booking['maid_id'].toString().isNotEmpty))
                        const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.schedule, 'Assigned At', assignedAt.toString()),
                    ],
                    if (assignedBy != null && assignedBy.toString().isNotEmpty) ...[
                      if (assignedAt != null && assignedAt.toString().isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.admin_panel_settings, 'Assigned By', assignedBy.toString()),
                    ],
                    if (assignmentNotes != null && assignmentNotes.toString().isNotEmpty) ...[
                      if (assignedAt != null || assignedBy != null) const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Colors.blue.shade50,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(
                            color: Colors.blue.shade200,
                            width: 1,
                          ),
                        ),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                Icon(Icons.note, color: Colors.blue.shade700, size: 20),
                                const SizedBox(width: 8),
                                Text(
                                  'Assignment Notes',
                                  style: GoogleFonts.poppins(
                                    fontSize: 12,
                                    fontWeight: FontWeight.w600,
                                    color: Colors.blue.shade900,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 8),
                            Text(
                              _cleanText(assignmentNotes.toString()),
                              style: GoogleFonts.poppins(
                                fontSize: 13,
                                color: Colors.grey.shade800,
                                height: 1.5,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Booking Timeline - Enhanced Design
            _buildSectionTitle('Booking Timeline', Icons.timeline),
            Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.06),
                    blurRadius: 15,
                    offset: const Offset(0, 5),
                    spreadRadius: 0,
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    if (createdAt != null && createdAt.toString().isNotEmpty)
                      _buildEnhancedDetailRow(Icons.add_circle_outline, 'Created At', createdAt.toString()),
                    if (confirmedAt != null && confirmedAt.toString().isNotEmpty) ...[
                      if (createdAt != null && createdAt.toString().isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.check_circle_outline, 'Confirmed At', confirmedAt.toString(), textColor: Colors.green),
                    ],
                    if (startedAt != null && startedAt.toString().isNotEmpty) ...[
                      if (confirmedAt != null && confirmedAt.toString().isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.play_circle_outline, 'Started At', startedAt.toString(), textColor: Colors.blue),
                    ],
                    if (completedAt != null && completedAt.toString().isNotEmpty) ...[
                      if (startedAt != null && startedAt.toString().isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.done_all, 'Completed At', completedAt.toString(), textColor: Colors.green.shade700),
                    ],
                    if (cancelledAt != null && cancelledAt.toString().isNotEmpty) ...[
                      if (completedAt != null && completedAt.toString().isNotEmpty) const SizedBox(height: 16),
                      _buildEnhancedDetailRow(Icons.cancel_outlined, 'Cancelled At', cancelledAt.toString(), textColor: Colors.red),
                    ],
                  ],
                ),
              ),
            ),
            // Monthly Subscription Sections (Service Timeline with dates)
            if (_isMonthlySubscriptionBooking(widget.booking)) ...[
              // Parse subscription details
              Builder(
                builder: (context) {
                  final subscriptionDetails = _parseSubscriptionPlanDetails(widget.booking['subscription_plan_details']);
                  final startDate = _tryParseDate(subscriptionDetails?['start_date']?.toString());
                  final endDate = _tryParseDate(subscriptionDetails?['end_date']?.toString());
                  final serviceDays = _extractServiceDays(subscriptionDetails);
                  
                  // If dates are missing, calculate them from booking_date or created_at
                  DateTime? calculatedStartDate = startDate;
                  DateTime? calculatedEndDate = endDate;
                  
                  if (calculatedStartDate == null) {
                    DateTime? bookingDateParsed;
                    if (bookingDate.isNotEmpty) {
                      bookingDateParsed = _tryParseDate(bookingDate);
                    }
                    // Fallback to created_at if booking_date is not available
                    if (bookingDateParsed == null && createdAt != null) {
                      bookingDateParsed = _tryParseDate(createdAt.toString());
                    }
                    if (bookingDateParsed != null) {
                      // Service starts the next day after booking date
                      calculatedStartDate = bookingDateParsed.add(const Duration(days: 1));
                    }
                  }
                  
                  // If end date is missing but we have start date, calculate it (1 month after start)
                  if (calculatedEndDate == null && calculatedStartDate != null) {
                    // Add 1 month to start date
                    calculatedEndDate = DateTime(calculatedStartDate.year, calculatedStartDate.month + 1, calculatedStartDate.day);
                  }
                  
                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Service Timeline Section with dates (reacts instantly to selected range changes)
                      ValueListenableBuilder<DateTime?>(
                        valueListenable: _selectedFromDateNotifier,
                        builder: (_, selectedFromDate, __) {
                          return ValueListenableBuilder<DateTime?>(
                            valueListenable: _selectedToDateNotifier,
                            builder: (_, selectedToDate, ___) {
                              return _buildMonthlyTimelineSectionForDetails(
                                calculatedStartDate,
                                calculatedEndDate,
                                serviceDays,
                                selectedFromDate: selectedFromDate,
                                selectedToDate: selectedToDate,
                              );
                            },
                          );
                        },
                      ),
                      const SizedBox(height: 16),
                      _buildMonthlyWindowSectionForDetails(
                        canCancelNow: cancellationUnlocked,
                        daysRemaining: daysRemainingForCancellation,
                        unlockDate: cancellationUnlockDate,
                        hasAccurateDate: hasAccurateBookingDate,
                      ),
                      const SizedBox(height: 16),
                    ],
                  );
                },
              ),
            ],

            // Additional Notes - Enhanced Design
            if (customerNotes != null || maidNotes != null || serviceRequirements.isNotEmpty) ...[
              _buildSectionTitle('Additional Information', Icons.note_alt),
              Container(
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(20),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.06),
                      blurRadius: 15,
                      offset: const Offset(0, 5),
                      spreadRadius: 0,
                    ),
                  ],
                ),
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (serviceRequirements.isNotEmpty) ...[
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: Colors.purple.shade50,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: Colors.purple.shade200,
                              width: 1,
                            ),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Icon(Icons.assignment, color: Colors.purple.shade700, size: 20),
                                  const SizedBox(width: 8),
                                  Text(
                                    'Service Requirements',
                                    style: GoogleFonts.poppins(
                                      fontSize: 14,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.purple.shade900,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 10),
                              Text(
                                _cleanText(serviceRequirements),
                                style: GoogleFonts.poppins(
                                  fontSize: 13,
                                  color: Colors.grey.shade800,
                                  height: 1.5,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                      if (customerNotes != null && customerNotes.toString().isNotEmpty) ...[
                        if (serviceRequirements.isNotEmpty) const SizedBox(height: 16),
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: Colors.indigo.shade50,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: Colors.indigo.shade200,
                              width: 1,
                            ),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Icon(Icons.comment, color: Colors.indigo.shade700, size: 20),
                                  const SizedBox(width: 8),
                                  Text(
                                    'Customer Notes',
                                    style: GoogleFonts.poppins(
                                      fontSize: 14,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.indigo.shade900,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 10),
                              Text(
                                _cleanText(customerNotes.toString()),
                                style: GoogleFonts.poppins(
                                  fontSize: 13,
                                  color: Colors.grey.shade800,
                                  height: 1.5,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                      if (maidNotes != null && maidNotes.toString().isNotEmpty) ...[
                        if (customerNotes != null || serviceRequirements.isNotEmpty) const SizedBox(height: 16),
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: Colors.teal.shade50,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: Colors.teal.shade200,
                              width: 1,
                            ),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Icon(Icons.person_pin, color: Colors.teal.shade700, size: 20),
                                  const SizedBox(width: 8),
                                  Text(
                                    'Maid Notes',
                                    style: GoogleFonts.poppins(
                                      fontSize: 14,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.teal.shade900,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 10),
                              Text(
                                _cleanText(maidNotes.toString()),
                                style: GoogleFonts.poppins(
                                  fontSize: 13,
                                  color: Colors.grey.shade800,
                                  height: 1.5,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
            ],
          ],
        ),
      ),
    );
  }

  // Helper function to clean and format text with special characters
  String _cleanText(String text) {
    if (text.isEmpty) return text;
    
    // Convert to string and trim
    String cleaned = text.toString().trim();
    
    // First, remove all escape sequences and special formatting characters
    // Remove common escape sequences
    cleaned = cleaned
        .replaceAll('\\"', '"')  // Escaped double quotes
        .replaceAll("\\'", "'")   // Escaped single quotes
        .replaceAll('\\\\', '')   // Double backslashes
        .replaceAll('\\n', ' ')   // Escaped newlines -> space
        .replaceAll('\\r\\n', ' ') // Escaped CRLF -> space
        .replaceAll('\\r', ' ')   // Escaped carriage return -> space
        .replaceAll('\\t', ' ')   // Escaped tabs -> space
        .replaceAll('\\', '');    // Remove any remaining backslashes
    
    // Remove special formatting patterns like |||-, |||, ||, etc.
    cleaned = cleaned
        .replaceAll(RegExp(r'\|\|\|\-+'), ' ')  // Remove |||- patterns
        .replaceAll(RegExp(r'\|\|\|'), ' ')     // Remove ||| patterns
        .replaceAll(RegExp(r'\|\|'), ' ')       // Remove || patterns
        .replaceAll(RegExp(r'\|'), ' ');         // Remove single | patterns
    
    // Decode Unicode escape sequences (like \u2019)
    try {
      cleaned = cleaned.replaceAllMapped(
        RegExp(r'\\u([0-9a-fA-F]{4})'),
        (match) => String.fromCharCode(int.parse(match.group(1)!, radix: 16)),
      );
    } catch (e) {
      // If parsing fails, continue with other cleaning
    }
    
    // Decode HTML entities if any
    cleaned = cleaned
        .replaceAll('&quot;', '"')
        .replaceAll('&apos;', "'")
        .replaceAll('&amp;', '&')
        .replaceAll('&lt;', '<')
        .replaceAll('&gt;', '>')
        .replaceAll('&nbsp;', ' ')
        .replaceAll('&#39;', "'")
        .replaceAll('&#x27;', "'")
        .replaceAll('&#x2F;', '/');
    
    // Handle actual newlines and line breaks
    cleaned = cleaned
        .replaceAll('\r\n', ' ')
        .replaceAll('\r', ' ')
        .replaceAll('\n', ' ');
    
    // Remove multiple consecutive spaces
    while (cleaned.contains('  ')) {
      cleaned = cleaned.replaceAll('  ', ' ');
    }
    
    // Remove unwanted quotes around individual words/phrases
    // But keep quotes that are part of proper sentences
    cleaned = cleaned.replaceAllMapped(
      RegExp(r'"([^"]+)"'),
      (match) {
        String content = match.group(1)!;
        // Remove quotes around short phrases, keep for longer quoted text
        if (content.length < 50) {
          return content;
        }
        return match.group(0)!;
      },
    );
    
    // Remove any remaining special characters that aren't part of normal text
    // Keep only letters, numbers, spaces, and basic punctuation
    cleaned = cleaned.replaceAll(RegExp(r'[^\w\s.,!?;:()\-]'), ' ');
    
    // Clean up multiple spaces again after removing special chars
    while (cleaned.contains('  ')) {
      cleaned = cleaned.replaceAll('  ', ' ');
    }
    
    // Trim and return clean text
    cleaned = cleaned.trim();
    
    // Capitalize first letter if needed
    if (cleaned.isNotEmpty && cleaned.length > 1) {
      cleaned = cleaned[0].toUpperCase() + cleaned.substring(1);
    }
    
    return cleaned;
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12, left: 4),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [
                  const Color(0xFF00BFA5).withOpacity(0.2),
                  const Color(0xFF00ACC1).withOpacity(0.15),
                ],
              ),
              borderRadius: BorderRadius.circular(10),
            ),
            child: Icon(
              icon,
              color: const Color(0xFF00BFA5),
              size: 20,
            ),
          ),
          const SizedBox(width: 12),
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: Colors.grey.shade800,
              letterSpacing: 0.3,
            ),
          ),
        ],
      ),
    );
  }

  DateTime? _resolveBookingDate(String bookingDate, dynamic createdAt) {
    DateTime? parsed;
    if (bookingDate.isNotEmpty) {
      parsed = _tryParseDate(bookingDate);
    }
    if (parsed == null && createdAt != null) {
      final createdAtString = createdAt.toString();
      if (createdAtString.isNotEmpty) {
        parsed = _tryParseDate(createdAtString);
      }
    }
    return parsed;
  }

  String _formatFriendlyDate(DateTime? date) {
    if (date == null) return '';
    const months = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }

  Widget _buildCancellationNotice({
    required bool canCancelNow,
    required int daysRemaining,
    required DateTime? unlockDate,
    required bool hasAccurateDate,
  }) {
    final accentColor = canCancelNow ? Colors.green : Colors.orange;
    final backgroundColor = canCancelNow
        ? Colors.green.withOpacity(0.08)
        : Colors.orange.withOpacity(0.1);
    final iconData = canCancelNow ? Icons.check_circle : Icons.lock_clock;
    final String subtitle;
    if (hasAccurateDate && unlockDate != null) {
      final remainingText = !canCancelNow && daysRemaining > 0
          ? ' â€¢ ${daysRemaining == 1 ? '1 day' : '$daysRemaining days'} remaining'
          : '';
      subtitle = canCancelNow
          ? 'You can cancel anytime since ${_formatFriendlyDate(unlockDate)}.'
          : 'Cancellation opens on ${_formatFriendlyDate(unlockDate)}$remainingText.';
    } else {
      subtitle =
          'Cancellations are processed only after 4 days from the booking date.';
    }

    return Container(
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: accentColor.withOpacity(0.4)),
      ),
      padding: const EdgeInsets.all(18),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: accentColor,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: accentColor.withOpacity(0.3),
                  blurRadius: 8,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Icon(iconData, color: Colors.white, size: 22),
          ),
          const SizedBox(width: 14),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Cancellation Notice',
                  style: GoogleFonts.poppins(
                    fontSize: 15,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey.shade900,
                  ),
                ),
                const SizedBox(height: 6),
                Text(
                  'Cancellation is available only after 4 days of the booking.',
                  style: GoogleFonts.poppins(
                    fontSize: 13,
                    color: Colors.grey.shade800,
                    height: 1.4,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  subtitle,
                  style: GoogleFonts.poppins(
                    fontSize: 12,
                    color: Colors.grey.shade700,
                    height: 1.4,
                  ),
                ),
                const SizedBox(height: 10),
                Container(
                  padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 10),
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: accentColor.withOpacity(0.3)),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        canCancelNow ? Icons.check : Icons.timer_outlined,
                        size: 16,
                        color: accentColor,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          canCancelNow
                              ? 'You may proceed with cancellation if required.'
                              : 'Please wait until the cooling period is over before cancelling.',
                          style: GoogleFonts.poppins(
                            fontSize: 11,
                            fontWeight: FontWeight.w500,
                            color: accentColor.shade700,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDetailRow(String label, String value, {bool isBold = false, bool isMultiline = false, Color? textColor}) {
    // Clean the value text if it's multiline
    String displayValue = isMultiline ? _cleanText(value) : value;
    
    return Padding(
      padding: EdgeInsets.only(bottom: isMultiline ? 12 : 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label,
            style: GoogleFonts.poppins(
              fontSize: 12,
              color: Colors.grey.shade600,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            displayValue,
            style: GoogleFonts.poppins(
              fontSize: 14,
              fontWeight: isBold ? FontWeight.bold : FontWeight.normal,
              color: textColor ?? Colors.grey.shade900,
              height: isMultiline ? 1.5 : null,
            ),
            maxLines: isMultiline ? null : 2,
            overflow: isMultiline ? null : TextOverflow.ellipsis,
          ),
          if (!isMultiline) const SizedBox(height: 4),
        ],
      ),
    );
  }

  Widget _buildEnhancedDetailRow(IconData icon, String label, String value, {bool isMultiline = false, Color? textColor}) {
    // Clean the value text if it's multiline
    String displayValue = isMultiline ? _cleanText(value) : value;
    
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: (textColor ?? const Color(0xFF00BFA5)).withOpacity(0.1),
            borderRadius: BorderRadius.circular(10),
          ),
          child: Icon(
            icon,
            color: textColor ?? const Color(0xFF00BFA5),
            size: 18,
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: GoogleFonts.poppins(
                  fontSize: 11,
                  color: Colors.grey.shade600,
                  letterSpacing: 0.3,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                displayValue,
                style: GoogleFonts.poppins(
                  fontSize: 15,
                  fontWeight: FontWeight.w600,
                  color: textColor ?? Colors.grey.shade900,
                  height: isMultiline ? 1.5 : null,
                ),
                maxLines: isMultiline ? null : 2,
                overflow: isMultiline ? null : TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ],
    );
  }

Widget _buildMonthlyTimelineSectionForDetails(
  DateTime? start,
  DateTime? end,
  List<String> serviceDays, {
  DateTime? selectedFromDate,
  DateTime? selectedToDate,
}) {
    final startLabel = _formatDisplayDateFromDateTime(start);
    final endLabel = _formatDisplayDateFromDateTime(end);
    
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Colors.white,
            const Color(0xFF00BFA5).withOpacity(0.02),
          ],
        ),
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.06),
            blurRadius: 15,
            offset: const Offset(0, 5),
            spreadRadius: 0,
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        const Color(0xFF00BFA5).withOpacity(0.2),
                        const Color(0xFF00ACC1).withOpacity(0.15),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: const Icon(
                    Icons.timeline,
                    color: Color(0xFF00BFA5),
                    size: 20,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  'Service Timeline',
                  style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey.shade900,
                    letterSpacing: 0.3,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            if (start != null && end != null) ...[
              _buildServiceCalendarForDetails(
                start,
                end,
                selectedFromDate: selectedFromDate,
                selectedToDate: selectedToDate,
              ),
              const SizedBox(height: 12),
            ] else ...[
              Text(
                'Service calendar will be shown once start and end dates are available.',
                style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600),
              ),
              const SizedBox(height: 12),
            ],
            _buildTimelineDotsForDetails(totalSlots: 18, highlightedSlots: serviceDays.length.clamp(1, 16)),
            const SizedBox(height: 12),
            // Service Start - Green Mark
            Row(
              children: [
                Container(
                  width: 20,
                  height: 20,
                  decoration: BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                    border: Border.all(color: Colors.white, width: 2),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.green.withOpacity(0.3),
                        blurRadius: 4,
                        spreadRadius: 1,
                      ),
                    ],
                  ),
                  child: const Icon(Icons.check, size: 12, color: Colors.white),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Service Start: $startLabel',
                    style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade700),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            // Service End - Blue Mark
            Row(
              children: [
                Container(
                  width: 20,
                  height: 20,
                  decoration: BoxDecoration(
                    color: Colors.blue.shade600,
                    shape: BoxShape.circle,
                    border: Border.all(color: Colors.white, width: 2),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.blue.withOpacity(0.3),
                        blurRadius: 4,
                        spreadRadius: 1,
                      ),
                    ],
                  ),
                  child: const Icon(Icons.flag, size: 12, color: Colors.white),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Service End: $endLabel',
                    style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade700),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

Widget _buildServiceCalendarForDetails(
  DateTime startDate,
  DateTime endDate, {
  DateTime? selectedFromDate,
  DateTime? selectedToDate,
}) {
    const tealColor = Color(0xFF00BFA5);
    final displayMonth = DateTime(startDate.year, startDate.month, 1);
    final firstDayOfMonth = displayMonth;
    final lastDayOfMonth = DateTime(displayMonth.year, displayMonth.month + 1, 0);
    final isEndDateInDifferentMonth = endDate.year != displayMonth.year || endDate.month != displayMonth.month;
    final firstDayOffset = firstDayOfMonth.weekday % 7;
    final daysInMonth = lastDayOfMonth.day;
    final monthNames = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December'
    ];
    final weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    return Container(
      decoration: BoxDecoration(
        color: Colors.grey.shade50,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Column(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(vertical: 12),
            decoration: BoxDecoration(
              color: tealColor.withOpacity(0.1),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Column(
              children: [
                Text(
                  '${monthNames[displayMonth.month - 1]} ${displayMonth.year}',
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey.shade900,
                  ),
                ),
                if (isEndDateInDifferentMonth)
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      'End date: ${monthNames[endDate.month - 1]} ${endDate.day}, ${endDate.year}',
                      style: GoogleFonts.poppins(
                        fontSize: 11,
                        color: Colors.blue.shade700,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
              ],
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 8),
            child: Row(
              children: weekDays
                  .map(
                    (day) => Expanded(
                      child: Center(
                        child: Text(
                          day,
                          style: GoogleFonts.poppins(
                            fontSize: 11,
                            fontWeight: FontWeight.w600,
                            color: Colors.grey.shade600,
                          ),
                        ),
                      ),
                    ),
                  )
                  .toList(),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
            child: Column(
              children: [
                Row(
                  children: List.generate(7, (index) {
                    if (index < firstDayOffset) {
                      return const Expanded(child: SizedBox());
                    }
                    final day = index - firstDayOffset + 1;
                    return _buildCalendarDayForDetails(
                      day,
                      startDate,
                      endDate,
                      displayMonth,
                      selectedFromDate: selectedFromDate,
                      selectedToDate: selectedToDate,
                    );
                  }),
                ),
                ...List.generate((daysInMonth - (7 - firstDayOffset) + 6) ~/ 7, (rowIndex) {
                  return Row(
                    children: List.generate(7, (colIndex) {
                      final day = (7 - firstDayOffset) + (rowIndex * 7) + colIndex + 1;
                      if (day > daysInMonth) {
                        return const Expanded(child: SizedBox());
                      }
                      return _buildCalendarDayForDetails(
                        day,
                        startDate,
                        endDate,
                        displayMonth,
                        selectedFromDate: selectedFromDate,
                        selectedToDate: selectedToDate,
                      );
                    }),
                  );
                }),
              ],
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                _buildCalendarLegendItemForDetails(Colors.green, 'Start'),
                const SizedBox(width: 16),
                _buildCalendarLegendItemForDetails(Colors.blue.shade600, 'End'),
                const SizedBox(width: 16),
                _buildCalendarLegendItemForDetails(tealColor.withOpacity(0.2), 'Active'),
                if (selectedFromDate != null || selectedToDate != null) ...[
                  const SizedBox(width: 16),
                  _buildCalendarLegendItemForDetails(Colors.red, 'Selected'),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCalendarLegendItemForDetails(Color color, String label) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 16,
          height: 16,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
            border: color == Colors.green || color == Colors.blue.shade600 ? Border.all(color: Colors.white, width: 1) : null,
          ),
        ),
        const SizedBox(width: 6),
        Text(
          label,
          style: GoogleFonts.poppins(
            fontSize: 11,
            color: Colors.grey.shade700,
          ),
        ),
      ],
    );
  }

Widget _buildCalendarDayForDetails(
  int day,
  DateTime startDate,
  DateTime endDate,
  DateTime displayMonth, {
  DateTime? selectedFromDate,
  DateTime? selectedToDate,
}) {
  final currentDate = DateTime(displayMonth.year, displayMonth.month, day);
  final isStartDate = currentDate.year == startDate.year && currentDate.month == startDate.month && currentDate.day == startDate.day;
  final isEndDate = currentDate.year == endDate.year && currentDate.month == endDate.month && currentDate.day == endDate.day;
  final isInRange = currentDate.isAfter(startDate.subtract(const Duration(days: 1))) &&
      currentDate.isBefore(endDate.add(const Duration(days: 1)));
  final isToday = currentDate.year == DateTime.now().year &&
      currentDate.month == DateTime.now().month &&
      currentDate.day == DateTime.now().day;
  final isSelectedFromDate = selectedFromDate != null &&
      currentDate.year == selectedFromDate.year &&
      currentDate.month == selectedFromDate.month &&
      currentDate.day == selectedFromDate.day;
  final isSelectedToDate = selectedToDate != null &&
      currentDate.year == selectedToDate.year &&
      currentDate.month == selectedToDate.month &&
      currentDate.day == selectedToDate.day;
  final isInSelectedRange = selectedFromDate != null &&
      selectedToDate != null &&
      currentDate.isAfter(selectedFromDate.subtract(const Duration(days: 1))) &&
      currentDate.isBefore(selectedToDate.add(const Duration(days: 1)));

  Color backgroundColor = Colors.transparent;
  Color textColor = Colors.grey.shade800;
  Widget? indicator;
  Border? border;

  if (isStartDate) {
    backgroundColor = Colors.green;
    textColor = Colors.white;
    indicator = const Icon(Icons.play_arrow, size: 12, color: Colors.white);
  } else if (isEndDate) {
    backgroundColor = Colors.blue.shade600;
    textColor = Colors.white;
    indicator = const Icon(Icons.flag, size: 12, color: Colors.white);
  } else if (isInRange) {
    backgroundColor = const Color(0xFF00BFA5).withOpacity(0.2);
  } else if (isToday) {
    backgroundColor = Colors.grey.shade200;
  }

  if (isSelectedFromDate || isSelectedToDate || isInSelectedRange) {
    border = Border.all(color: Colors.red, width: 3);
  }

  return Expanded(
    child: Container(
      margin: const EdgeInsets.all(2),
      height: 40,
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(8),
        border: border ??
            (isToday && !isStartDate && !isEndDate && !isSelectedFromDate && !isSelectedToDate && !isInSelectedRange
                ? Border.all(color: const Color(0xFF00BFA5), width: 1.2)
                : null),
      ),
      child: Stack(
        alignment: Alignment.center,
        children: [
          Text(
            day.toString(),
            style: GoogleFonts.poppins(
              fontSize: 13,
              fontWeight: isStartDate || isEndDate ? FontWeight.w700 : FontWeight.w500,
              color: textColor,
            ),
          ),
          if (indicator != null)
            Positioned(
              bottom: 2,
              child: indicator,
            ),
          if (isSelectedFromDate || isSelectedToDate || isInSelectedRange)
            Positioned(
              top: 2,
              right: 2,
              child: Container(
                width: 10,
                height: 10,
                decoration: const BoxDecoration(
                  color: Colors.red,
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.red,
                      blurRadius: 4,
                      spreadRadius: 1,
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    ),
  );
}

  Widget _buildTimelineDotsForDetails({int totalSlots = 18, required int highlightedSlots}) {
    const tealColor = Color(0xFF00BFA5);
    return Wrap(
      spacing: 6,
      runSpacing: 6,
      children: List.generate(totalSlots, (index) {
        late Color color;
        if (index == 0) {
          color = Colors.green;
        } else if (index == totalSlots - 1) {
          color = Colors.blue.shade600;
        } else if (index <= highlightedSlots) {
          color = tealColor.withOpacity(0.9);
        } else {
          color = Colors.grey.shade300;
        }
        return Container(
          width: 18,
          height: 18,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
          ),
        );
      }),
    );
  }

  Widget _buildMonthlyWindowSectionForDetails({
    required bool canCancelNow,
    required int daysRemaining,
    required DateTime? unlockDate,
    required bool hasAccurateDate,
  }) {
    final editingEnabled = canCancelNow;
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Monthly Service Window',
              style: GoogleFonts.poppins(
                fontSize: 15,
                fontWeight: FontWeight.w600,
                color: Colors.grey.shade900,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 4),
            Text(
              'Update the delivery months for this subscription and share a reason.',
              style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 16),
            _buildCancellationNotice(
              canCancelNow: canCancelNow,
              daysRemaining: daysRemaining,
              unlockDate: unlockDate,
              hasAccurateDate: hasAccurateDate,
            ),
            if (!editingEnabled && unlockDate != null) ...[
              const SizedBox(height: 12),
              Row(
                children: [
                  const Icon(Icons.lock_clock, size: 16, color: Colors.orange),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      'Service window editing unlocks on ${_formatFriendlyDate(unlockDate)}.',
                      style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600),
                    ),
                  ),
                ],
              ),
            ] else if (!editingEnabled) ...[
              const SizedBox(height: 12),
              Row(
                children: [
                  const Icon(Icons.lock_clock, size: 16, color: Colors.orange),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      'Service window editing is temporarily locked until four days after booking.',
                      style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600),
                    ),
                  ),
                ],
              ),
            ],
            const SizedBox(height: 16),
            LayoutBuilder(
              builder: (context, constraints) {
                if (constraints.maxWidth < 400) {
                  // Stack vertically on narrow screens
                  return Column(
                    children: [
                      _buildEditableDateField(
                        label: 'From Date',
                        value: _delayFromDate,
                        icon: Icons.date_range,
                        isEnabled: editingEnabled,
                        onTap: () async {
                          final picked = await showDatePicker(
                            context: context,
                            initialDate: _delayFromDate ?? DateTime.now(),
                            firstDate: DateTime.now(),
                            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
                          );
                          if (picked != null) {
                            setState(() {
                              _delayFromDate = picked;
                            });
                            // Validate immediately after selection
                            await _validateDatesImmediately();
                          }
                        },
                      ),
                      const SizedBox(height: 12),
                      _buildEditableDateField(
                        label: 'To Date',
                        value: _delayToDate,
                        icon: Icons.event,
                        isEnabled: editingEnabled,
                        errorText: _dateRangeError ?? _weekMonthError,
                        onTap: () async {
                          if (_delayFromDate == null) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(
                                content: Text('Please select From Date first'),
                                backgroundColor: Colors.orange,
                              ),
                            );
                            return;
                          }
                          final maxDate = _delayFromDate!.add(const Duration(days: 7));
                          final picked = await showDatePicker(
                            context: context,
                            initialDate: _delayToDate ?? _delayFromDate!,
                            firstDate: _delayFromDate!,
                            lastDate: maxDate.isBefore(DateTime.now().add(const Duration(days: 365 * 2)))
                                ? maxDate
                                : DateTime.now().add(const Duration(days: 365 * 2)),
                          );
                          if (picked != null) {
                            // Validate that the selected date is within 7 days
                            final daysDiff = picked.difference(_delayFromDate!).inDays;
                            if (daysDiff > 7) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('To Date cannot be more than 7 days from From Date'),
                                  backgroundColor: Colors.orange,
                                ),
                              );
                              return;
                            }
                            setState(() {
                              _delayToDate = picked;
                            });
                            // Validate immediately after selection
                            await _validateDatesImmediately();
                          }
                        },
                      ),
                    ],
                  );
                }
                // Side by side on wider screens
                return Row(
                  children: [
                    Expanded(
                      child: _buildEditableDateField(
                        label: 'From Date',
                        value: _delayFromDate,
                        icon: Icons.date_range,
                        isEnabled: editingEnabled,
                        onTap: () async {
                          final picked = await showDatePicker(
                            context: context,
                            initialDate: _delayFromDate ?? DateTime.now(),
                            firstDate: DateTime.now(),
                            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
                          );
                          if (picked != null) {
                            setState(() {
                              _delayFromDate = picked;
                            });
                            // Validate immediately after selection
                            await _validateDatesImmediately();
                          }
                        },
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: _buildEditableDateField(
                        label: 'To Date',
                        value: _delayToDate,
                        icon: Icons.event,
                        isEnabled: editingEnabled,
                        errorText: _dateRangeError ?? _weekMonthError,
                        onTap: () async {
                          if (_delayFromDate == null) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(
                                content: Text('Please select From Date first'),
                                backgroundColor: Colors.orange,
                              ),
                            );
                            return;
                          }
                          final maxDate = _delayFromDate!.add(const Duration(days: 7));
                          final picked = await showDatePicker(
                            context: context,
                            initialDate: _delayToDate ?? _delayFromDate!,
                            firstDate: _delayFromDate!,
                            lastDate: maxDate.isBefore(DateTime.now().add(const Duration(days: 365 * 2)))
                                ? maxDate
                                : DateTime.now().add(const Duration(days: 365 * 2)),
                          );
                          if (picked != null) {
                            // Validate that the selected date is within 7 days
                            final daysDiff = picked.difference(_delayFromDate!).inDays;
                            if (daysDiff > 7) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('To Date cannot be more than 7 days from From Date'),
                                  backgroundColor: Colors.orange,
                                ),
                              );
                              return;
                            }
                            setState(() {
                              _delayToDate = picked;
                            });
                            // Validate immediately after selection
                            await _validateDatesImmediately();
                          }
                        },
                      ),
                    ),
                  ],
                );
              },
            ),
            const SizedBox(height: 12),
            _buildEditableReasonField(isEnabled: editingEnabled),
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: (!editingEnabled || _isSaving) ? null : _saveDelayInfo,
                icon: _isSaving
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      )
                    : const Icon(Icons.save_alt),
                label: Text(_isSaving ? 'Saving...' : 'Save'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF00BFA5),
                  padding: const EdgeInsets.symmetric(vertical: 14),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildEditableDateField({
    required String label,
    required DateTime? value,
    required IconData icon,
    required VoidCallback onTap,
    String? errorText,
    bool isEnabled = true,
  }) {
    final hasError = errorText != null && errorText.isNotEmpty;
    final baseColor = isEnabled ? Colors.white : Colors.grey.shade100;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: Colors.grey.shade600,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 6),
        Opacity(
          opacity: isEnabled ? 1 : 0.6,
          child: IgnorePointer(
            ignoring: !isEnabled,
            child: InkWell(
              onTap: onTap,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                decoration: BoxDecoration(
                  color: baseColor,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: hasError ? Colors.red.shade400 : Colors.grey.shade300,
                    width: hasError ? 2 : 1,
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      icon, 
                      size: 18, 
                      color: hasError ? Colors.red.shade400 : Colors.grey.shade600,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        _formatDisplayDateFromDateTime(value, useEmptyPlaceholder: true),
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          color: hasError 
                              ? Colors.red.shade400 
                              : (value == null ? Colors.grey.shade400 : Colors.grey.shade900),
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    Icon(
                      Icons.arrow_drop_down, 
                      color: hasError ? Colors.red.shade400 : Colors.grey.shade600,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
        if (hasError) ...[
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(Icons.error_outline, size: 14, color: Colors.red.shade400),
              const SizedBox(width: 4),
              Expanded(
                child: Text(
                  errorText!,
                  style: GoogleFonts.poppins(
                    fontSize: 11,
                    color: Colors.red.shade400,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }

  Widget _buildEditableReasonField({bool isEnabled = true}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Reason',
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: Colors.grey.shade600,
          ),
        ),
        const SizedBox(height: 6),
        Opacity(
          opacity: isEnabled ? 1 : 0.6,
          child: Container(
            decoration: BoxDecoration(
              color: isEnabled ? Colors.white : Colors.grey.shade100,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.grey.shade300),
            ),
            child: TextField(
              controller: _reasonController,
              enabled: isEnabled,
              maxLines: 3,
              decoration: InputDecoration(
                hintText: 'Tell us why you are making a change',
                hintStyle: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade400),
                border: InputBorder.none,
                contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                prefixIcon: Icon(Icons.edit_note, size: 18, color: Colors.grey.shade600),
              ),
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade900),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildReadOnlyFieldForDetails({
    required String label,
    required String value,
    IconData? icon,
    bool alignTop = false,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: Colors.grey.shade500,
          ),
        ),
        const SizedBox(height: 4),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          decoration: BoxDecoration(
            color: Colors.grey.shade100,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.grey.shade300),
          ),
          child: Row(
            children: [
              if (icon != null) ...[
                Icon(icon, size: 18, color: Colors.grey.shade600),
                const SizedBox(width: 8),
              ],
              Expanded(
                child: Text(
                  value,
                  style: GoogleFonts.poppins(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                    color: Colors.grey.shade900,
                  ),
                  maxLines: alignTop ? null : 1,
                  overflow: alignTop ? null : TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// Product Cart Page
class ProductCartPage extends StatefulWidget {
  final Map<String, dynamic> product;

  const ProductCartPage({super.key, required this.product});

  @override
  State<ProductCartPage> createState() => _ProductCartPageState();
}

class _ProductCartPageState extends State<ProductCartPage> {
  int _quantity = 1;
  bool _isProcessingPayment = false;
  Razorpay? _razorpay;
  static const Color _tealColor = Color(0xFF00BFA5);
  static const Color _tealLight = Color(0xFFE0F2F1);

  @override
  void initState() {
    super.initState();
    // Initialize Razorpay only for mobile platforms (Android/iOS)
    if (!kIsWeb) {
      _razorpay = Razorpay();
      _razorpay!.on(Razorpay.EVENT_PAYMENT_SUCCESS, _handlePaymentSuccess);
      _razorpay!.on(Razorpay.EVENT_PAYMENT_ERROR, _handlePaymentError);
      _razorpay!.on(Razorpay.EVENT_EXTERNAL_WALLET, _handleExternalWallet);
    }
  }

  @override
  void dispose() {
    if (!kIsWeb && _razorpay != null) {
      _razorpay!.clear();
    }
    super.dispose();
  }

  int get _availableStock {
    final stockQuantity = widget.product['stock_quantity'] ?? 0;
    return stockQuantity is String ? int.tryParse(stockQuantity) ?? 0 : (stockQuantity as num).toInt();
  }

  int get _remainingStock => _availableStock - _quantity;

  double get _unitPrice {
    final sellingPrice = widget.product['selling_price'] ?? widget.product['price'] ?? 0.0;
    return (sellingPrice is String) ? double.tryParse(sellingPrice) ?? 0.0 : (sellingPrice as num).toDouble();
  }

  double get _totalPrice => _unitPrice * _quantity;

  void _incrementQuantity() {
    if (_remainingStock > 0) {
      setState(() {
        _quantity++;
      });
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Cannot add more. Stock limit reached.'),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 2),
        ),
      );
    }
  }

  void _decrementQuantity() {
    if (_quantity > 1) {
      setState(() {
        _quantity--;
      });
    }
  }

  Future<void> _initiatePayment() async {
    // Check if user is logged in
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    if (!isLoggedIn) {
      // Store the product data so we can return to cart page after login
      await prefs.setString('pendingCartProduct', jsonEncode(widget.product));
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please login to proceed with payment'),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 2),
        ),
      );
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const LoginPage()),
      );
      return;
    }

    if (_totalPrice <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Invalid product price'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    if (_remainingStock < 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Insufficient stock available'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    final productName = widget.product['name'] ?? 'Product';
    
    setState(() {
      _isProcessingPayment = true;
    });

    // Get user data from SharedPreferences
    final userDataJson = prefs.getString('userData');
    Map<String, dynamic>? userData;
    if (userDataJson != null) {
      userData = jsonDecode(userDataJson);
    }

    final options = {
      'key': kRazorpayKeyId,
      'amount': (_totalPrice * 100).toInt(), // Amount in paise
      'name': 'Super Daily',
      'description': 'Product Purchase: $productName (Qty: $_quantity)',
      'prefill': {
        'contact': userData?['phone'] ?? '',
        'email': userData?['email'] ?? '',
      },
      'external': {
        'wallets': ['paytm']
      },
    };

    if (kIsWeb) {
      // For web, show payment dialog
      await _initiateRazorpayWeb(options, _totalPrice);
    } else {
      // Use Razorpay Flutter SDK for mobile
      if (_razorpay != null) {
        _razorpay!.open(options);
      } else {
        setState(() {
          _isProcessingPayment = false;
        });
      }
    }
  }

  Future<void> _initiateRazorpayWeb(Map<String, dynamic> options, double amount) async {
    if (mounted) {
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('Payment', style: GoogleFonts.poppins()),
          content: Text(
            'Amount: â‚¹${amount.toStringAsFixed(2)}\n\nThis is a demo. In production, integrate Razorpay web SDK.',
            style: GoogleFonts.poppins(),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text('Cancel', style: GoogleFonts.poppins()),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text('Pay', style: GoogleFonts.poppins()),
            ),
          ],
        ),
      );

      if (confirm == true) {
        // Simulate payment success for web
        _handlePaymentSuccessWeb();
      } else {
        setState(() {
          _isProcessingPayment = false;
        });
      }
    }
  }

  void _handlePaymentSuccessWeb() async {
    final prefs = await SharedPreferences.getInstance();
    final userDataJson = prefs.getString('userData');
    Map<String, dynamic>? userData;
    if (userDataJson != null) {
      userData = jsonDecode(userDataJson);
    }

    final orderPayload = {
      'user_id': userData?['id'],
      'product_id': widget.product['id'],
      'quantity': _quantity,
      'price': _unitPrice,
      'total_amount': _totalPrice,
      'payment_status': 'paid',
      'payment_method': 'razorpay',
      'payment_id': 'web_demo_${DateTime.now().millisecondsSinceEpoch}',
      'transaction_id': 'web_demo_${DateTime.now().millisecondsSinceEpoch}',
      'status': 'pending',
    };

    final orderResult = await _submitProductOrder(orderPayload);
    
    if (orderResult['success'] == true) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(orderResult['message'] ?? 'Payment successful! Order placed successfully.'),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 2),
          ),
        );
        
        Future.delayed(const Duration(seconds: 1), () {
          if (mounted) {
            Navigator.of(context).popUntil((route) => route.isFirst);
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => MyOrdersScreen(userData: userData!),
              ),
            );
          }
        });
      }
    } else {
      if (mounted) {
        setState(() {
          _isProcessingPayment = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Payment successful but order creation failed: ${orderResult['message'] ?? 'Unknown error. Please contact support.'}'),
            backgroundColor: Colors.orange,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    }
  }

  void _handlePaymentSuccess(PaymentSuccessResponse response) async {
    final prefs = await SharedPreferences.getInstance();
    final userDataJson = prefs.getString('userData');
    Map<String, dynamic>? userData;
    if (userDataJson != null) {
      userData = jsonDecode(userDataJson);
    }

    final orderPayload = {
      'user_id': userData?['id'],
      'product_id': widget.product['id'],
      'quantity': _quantity,
      'price': _unitPrice,
      'total_amount': _totalPrice,
      'payment_status': 'paid',
      'payment_method': 'razorpay',
      'payment_id': response.paymentId,
      'transaction_id': response.orderId ?? response.paymentId,
      'status': 'pending',
    };

    final orderResult = await _submitProductOrder(orderPayload);
    
    if (orderResult['success'] == true) {
      if (mounted) {
        setState(() {
          _isProcessingPayment = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Payment successful! Order placed successfully.'),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
        
        Future.delayed(const Duration(seconds: 1), () {
          if (mounted) {
            Navigator.of(context).popUntil((route) => route.isFirst);
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => MyOrdersScreen(userData: userData!),
              ),
            );
          }
        });
      }
    } else {
      if (mounted) {
        setState(() {
          _isProcessingPayment = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Payment successful but order creation failed. Please contact support.'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 4),
          ),
        );
      }
    }
  }

  void _handlePaymentError(PaymentFailureResponse response) {
    setState(() {
      _isProcessingPayment = false;
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Payment failed: ${response.message ?? 'Unknown error'}'),
        backgroundColor: Colors.red,
      ),
    );
  }

  void _handleExternalWallet(ExternalWalletResponse response) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('External wallet selected: ${response.walletName}'),
        backgroundColor: Colors.blue,
      ),
    );
  }

  Future<Map<String, dynamic>> _submitProductOrder(Map<String, dynamic> orderPayload) async {
    try {
      debugPrint('Submitting product order with payload: ${jsonEncode(orderPayload)}');
      final response = await http.post(
        Uri.parse('https://superdailys.com/superdailyapp/orders_create.php'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode(orderPayload),
      );
      debugPrint('Order create response status: ${response.statusCode}');
      debugPrint('Order create response body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data is Map && (data['success'] == true || data['status'] == 'ok')) {
          return {'success': true, 'message': data['message'] ?? 'Order created successfully'};
        }
        final errorMsg = data is Map ? (data['message'] ?? data['error'] ?? 'Order creation failed') : 'Order creation failed';
        return {'success': false, 'message': errorMsg};
      }
      String errorMsg = 'Order creation failed (Status: ${response.statusCode})';
      try {
        final errorData = jsonDecode(response.body);
        if (errorData is Map) {
          errorMsg = errorData['message'] ?? errorData['error'] ?? errorMsg;
        }
      } catch (_) {
        errorMsg = 'Order creation failed (Status: ${response.statusCode})';
      }
      return {'success': false, 'message': errorMsg};
    } catch (e) {
      debugPrint('Error submitting order: $e');
      return {'success': false, 'message': 'Network error: ${e.toString()}'};
    }
  }

  String _resolveImageUrl(String? imagePath) {
    if (imagePath == null || imagePath.isEmpty) return '';
    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
      return imagePath;
    }
    return 'https://superdailys.com/storage/products/$imagePath';
  }

  @override
  Widget build(BuildContext context) {
    final productImage = _resolveImageUrl(widget.product['image']);
    final productName = widget.product['name'] ?? 'Product';
    final discountPrice = widget.product['discount_price'] ?? widget.product['selling_price'];
    final mrpPrice = widget.product['mrp_price'] ?? widget.product['price'];
    
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: _tealColor,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text(
          'Cart',
          style: GoogleFonts.poppins(
            color: Colors.white,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Product Image
            if (productImage.isNotEmpty)
              Container(
                height: 300,
                width: double.infinity,
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                ),
                child: CachedNetworkImage(
                  imageUrl: productImage,
                  fit: BoxFit.contain,
                  placeholder: (context, url) => Center(
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(_tealColor),
                    ),
                  ),
                  errorWidget: (context, url, error) => Icon(
                    Icons.image_not_supported,
                    size: 80,
                    color: Colors.grey.shade400,
                  ),
                ),
              ),
            
            Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Product Name
                  Text(
                    productName,
                    style: GoogleFonts.poppins(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: Colors.grey.shade900,
                    ),
                  ),
                  const SizedBox(height: 16),
                  
                  // Price Section
                  Row(
                    children: [
                      Text(
                        'â‚¹${_unitPrice.toStringAsFixed(2)}',
                        style: GoogleFonts.poppins(
                          fontSize: 28,
                          fontWeight: FontWeight.bold,
                          color: _tealColor,
                        ),
                      ),
                      if (mrpPrice != null && mrpPrice != _unitPrice) ...[
                        const SizedBox(width: 12),
                        Text(
                          'â‚¹${(mrpPrice is String ? double.tryParse(mrpPrice) ?? 0.0 : (mrpPrice as num).toDouble()).toStringAsFixed(2)}',
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            decoration: TextDecoration.lineThrough,
                            color: Colors.grey.shade500,
                          ),
                        ),
                      ],
                    ],
                  ),
                  const SizedBox(height: 24),
                  
                  // Stock Status
                  if (_remainingStock < 5 && _remainingStock >= 0)
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      decoration: BoxDecoration(
                        color: Colors.orange.shade100,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                          color: Colors.orange.shade300,
                          width: 1,
                        ),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.warning_amber_rounded,
                            size: 18,
                            color: Colors.orange.shade700,
                          ),
                          const SizedBox(width: 8),
                          Text(
                            'Low Stock! Only $_remainingStock available',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.w600,
                              color: Colors.orange.shade700,
                            ),
                          ),
                        ],
                      ),
                    ),
                  const SizedBox(height: 24),
                  
                  // Quantity Section
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'Quantity',
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade900,
                        ),
                      ),
                      Row(
                        children: [
                          // Decrement Button
                          Container(
                            decoration: BoxDecoration(
                              color: _quantity > 1 ? _tealColor : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: IconButton(
                              icon: const Icon(Icons.remove, color: Colors.white),
                              onPressed: _quantity > 1 ? _decrementQuantity : null,
                            ),
                          ),
                          const SizedBox(width: 16),
                          // Quantity Display
                          Text(
                            '$_quantity',
                            style: GoogleFonts.poppins(
                              fontSize: 20,
                              fontWeight: FontWeight.bold,
                              color: Colors.grey.shade900,
                            ),
                          ),
                          const SizedBox(width: 16),
                          // Increment Button
                          Container(
                            decoration: BoxDecoration(
                              color: _remainingStock > 0 ? _tealColor : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: IconButton(
                              icon: const Icon(Icons.add, color: Colors.white),
                              onPressed: _remainingStock > 0 ? _incrementQuantity : null,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  
                  // Divider
                  Divider(color: Colors.grey.shade300),
                  const SizedBox(height: 24),
                  
                  // Total Price Section
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'Total Price',
                        style: GoogleFonts.poppins(
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade900,
                        ),
                      ),
                      Text(
                        'â‚¹${_totalPrice.toStringAsFixed(2)}',
                        style: GoogleFonts.poppins(
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                          color: _tealColor,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
      bottomNavigationBar: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.2),
              blurRadius: 10,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: SafeArea(
          child: ElevatedButton(
            onPressed: _isProcessingPayment || _remainingStock < 0 ? null : _initiatePayment,
            style: ElevatedButton.styleFrom(
              backgroundColor: _tealColor,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            child: _isProcessingPayment
                ? const SizedBox(
                    height: 20,
                    width: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    ),
                  )
                : Text(
                    'Buy Now - â‚¹${_totalPrice.toStringAsFixed(2)}',
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
          ),
        ),
      ),
    );
  }
}

class ServiceDetailsScreen extends StatefulWidget {
  final int serviceId;
  const ServiceDetailsScreen({super.key, required this.serviceId});

  @override
  State<ServiceDetailsScreen> createState() => _ServiceDetailsScreenState();
}

class _ServiceDetailsScreenState extends State<ServiceDetailsScreen> {
  Map<String, dynamic>? _service;
  bool _loading = true;
  late PageController _imgCtrl;
  int _imgIndex = 0;
  Razorpay? _razorpay;
  Map<String, dynamic>? _pendingBookingPayload;
  bool _isProcessingPayment = false;
  // Selected price option from service details screen
  String? _selectedPriceOptionKey;
  double? _selectedPriceOptionValue;
  static const double _codConvenienceFee = 100.0;

  @override
  void initState() {
    super.initState();
    _imgCtrl = PageController();
    // Initialize Razorpay only for mobile platforms (Android/iOS)
    if (!kIsWeb) {
      _razorpay = Razorpay();
      _razorpay!.on(Razorpay.EVENT_PAYMENT_SUCCESS, _handlePaymentSuccess);
      _razorpay!.on(Razorpay.EVENT_PAYMENT_ERROR, _handlePaymentError);
      _razorpay!.on(Razorpay.EVENT_EXTERNAL_WALLET, _handleExternalWallet);
    }
    _fetch();
  }

  @override
  void dispose() {
    _imgCtrl.dispose();
    if (!kIsWeb && _razorpay != null) {
      _razorpay!.clear();
    }
    super.dispose();
  }

  void _handlePaymentSuccess(PaymentSuccessResponse response) {
    if (_pendingBookingPayload != null) {
      final nowIso = DateTime.now().toIso8601String();
      _pendingBookingPayload!['payment_status'] = _normalizePaymentStatusValue('paid');
      _pendingBookingPayload!['payment_method'] = _normalizePaymentMethodValue(_pendingBookingPayload!['payment_method'] ?? 'razorpay');
      if (response.paymentId != null) {
        _pendingBookingPayload!['payment_id'] = response.paymentId;
      }
      if (response.orderId != null) {
        _pendingBookingPayload!['transaction_id'] = response.orderId;
      }
      _pendingBookingPayload!['payment_completed_at'] = nowIso;
      _pendingBookingPayload!['gateway_response'] = jsonEncode({
        'payment_id': response.paymentId,
        'order_id': response.orderId,
        'signature': response.signature,
      });
      
      // Submit booking after successful payment capture
      _submitBooking(_pendingBookingPayload!).then((result) {
        if (mounted) {
          setState(() {
            _isProcessingPayment = false;
            _pendingBookingPayload = null;
          });
          if (result['success'] == true) {
            Navigator.of(context).pop(); // Close booking sheet if open
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Payment successful! Booking confirmed.'),
                backgroundColor: Colors.green,
              ),
            );
          } else {
            final errorMsg = result['message'] ?? 'Payment successful but booking creation failed. Please contact support.';
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(errorMsg),
                backgroundColor: Colors.orange,
                duration: const Duration(seconds: 5),
              ),
            );
          }
        }
      });
    }
  }

  void _handlePaymentError(PaymentFailureResponse response) {
    debugPrint('âŒ [PAYMENT] Payment error received');
    debugPrint('âŒ [PAYMENT] Error code: ${response.code}');
    debugPrint('âŒ [PAYMENT] Error message: ${response.message}');
    debugPrint('âŒ [PAYMENT] Error details: ${response.error.toString()}');
    
    if (_pendingBookingPayload != null) {
      _pendingBookingPayload!['payment_status'] = _normalizePaymentStatusValue('failed');
      _pendingBookingPayload!['payment_failed_at'] = DateTime.now().toIso8601String();
      _pendingBookingPayload!['gateway_response'] = jsonEncode(response.error ?? {});
    }
    
    if (mounted) {
      setState(() {
        _isProcessingPayment = false;
        _pendingBookingPayload = null;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Payment failed: ${response.message ?? "Unknown error"}'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 4),
        ),
      );
    }
  }

  void _handleExternalWallet(ExternalWalletResponse response) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('External wallet selected: ${response.walletName}'),
        ),
      );
    }
  }

  Future<void> _initiateRazorpayPayment(double amount, Map<String, dynamic> bookingPayload) async {
    try {
      debugPrint('ðŸ”µ [PAYMENT] Initiating Razorpay payment for amount: â‚¹$amount');
      
      setState(() {
        _isProcessingPayment = true;
        _pendingBookingPayload = bookingPayload;
      });

      // Ensure Razorpay is initialized for mobile
      if (!kIsWeb) {
        if (_razorpay == null) {
          debugPrint('âš ï¸ [PAYMENT] Razorpay not initialized, initializing now...');
          try {
            _razorpay = Razorpay();
            _razorpay!.on(Razorpay.EVENT_PAYMENT_SUCCESS, _handlePaymentSuccess);
            _razorpay!.on(Razorpay.EVENT_PAYMENT_ERROR, _handlePaymentError);
            _razorpay!.on(Razorpay.EVENT_EXTERNAL_WALLET, _handleExternalWallet);
            debugPrint('âœ… [PAYMENT] Razorpay initialized successfully');
          } catch (e) {
            debugPrint('âŒ [PAYMENT] Failed to initialize Razorpay: $e');
            if (mounted) {
              setState(() {
                _isProcessingPayment = false;
                _pendingBookingPayload = null;
              });
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Failed to initialize payment gateway: $e'),
                  backgroundColor: Colors.red,
                  duration: const Duration(seconds: 4),
                ),
              );
            }
            return;
          }
        } else {
          debugPrint('âœ… [PAYMENT] Razorpay already initialized');
        }
      }

      // Prepare options for mobile (without handler - mobile uses event listeners)
      final mobileOptions = {
        'key': kRazorpayKeyId,
        'amount': (amount * 100).toInt(), // Amount in paise
        'name': 'Super Daily',
        'description': 'Monthly Subscription Service',
        'prefill': {
          'contact': bookingPayload['phone'] ?? '',
          'email': '', // You can add email to booking payload if available
        },
        'external': {
          'wallets': ['paytm']
        },
      };

      // Prepare options for web (with handler)
      final webOptions = {
        ...mobileOptions,
        'handler': (response) {
          // This will be handled by platform-specific code
        }
      };

      debugPrint('ðŸ”µ [PAYMENT] Payment options prepared');

      if (kIsWeb) {
        // Use Razorpay JavaScript SDK for web
        debugPrint('ðŸ”µ [PAYMENT] Opening web payment...');
        await _initiateRazorpayWeb(webOptions, amount, bookingPayload);
      } else {
        // Use Razorpay Flutter SDK for mobile
        if (_razorpay != null) {
          debugPrint('ðŸ”µ [PAYMENT] Opening Razorpay payment gateway...');
          debugPrint('ðŸ”µ [PAYMENT] Amount: â‚¹$amount (${(amount * 100).toInt()} paise)');
          debugPrint('ðŸ”µ [PAYMENT] Phone: ${bookingPayload['phone'] ?? 'N/A'}');
          debugPrint('ðŸ”µ [PAYMENT] Razorpay key: $kRazorpayKeyId');
          
          // Validate payment options before opening
          final amountInPaise = (amount * 100).toInt();
          if (amountInPaise <= 0) {
            debugPrint('âŒ [PAYMENT] Invalid amount: $amount');
            if (mounted) {
              setState(() {
                _isProcessingPayment = false;
                _pendingBookingPayload = null;
              });
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Invalid payment amount. Please try again.'),
                  backgroundColor: Colors.red,
                  duration: Duration(seconds: 3),
                ),
              );
            }
            return;
          }
          
          if (kRazorpayKeyId.isEmpty) {
            debugPrint('âŒ [PAYMENT] Razorpay key is empty');
            if (mounted) {
              setState(() {
                _isProcessingPayment = false;
                _pendingBookingPayload = null;
              });
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Payment gateway configuration error. Please contact support.'),
                  backgroundColor: Colors.red,
                  duration: Duration(seconds: 3),
                ),
              );
            }
            return;
          }
          
          try {
            // Show user feedback that payment gateway is opening
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Opening payment gateway...'),
                  duration: Duration(seconds: 2),
                ),
              );
            }
            
            // Open Razorpay payment gateway
            debugPrint('ðŸ”µ [PAYMENT] Calling _razorpay.open()...');
            debugPrint('ðŸ”µ [PAYMENT] Options validated, opening gateway...');
            _razorpay!.open(mobileOptions);
            debugPrint('âœ… [PAYMENT] Razorpay.open() called successfully');
            
            // Give it a moment to open, then check if there was an error
            await Future.delayed(const Duration(milliseconds: 1500));
            
            // If we reach here and payment is still processing, the gateway should be open
            // If it failed, the error handler will be called
            debugPrint('ðŸ”µ [PAYMENT] Payment gateway should be open now');
            
            // If payment is still processing after delay, assume gateway opened successfully
            if (_isProcessingPayment) {
              debugPrint('âœ… [PAYMENT] Payment gateway opened successfully (payment processing flag is true)');
            }
          } catch (e, stackTrace) {
            debugPrint('âŒ [PAYMENT] Error calling Razorpay.open(): $e');
            debugPrint('Stack trace: $stackTrace');
            if (mounted) {
              setState(() {
                _isProcessingPayment = false;
                _pendingBookingPayload = null;
              });
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Failed to open payment gateway: $e\nPlease try again or contact support.'),
                  backgroundColor: Colors.red,
                  duration: const Duration(seconds: 5),
                ),
              );
            }
          }
        } else {
          debugPrint('âŒ [PAYMENT] Razorpay is null, cannot open payment');
          if (mounted) {
            setState(() {
              _isProcessingPayment = false;
              _pendingBookingPayload = null;
            });
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Payment gateway initialization failed. Please try again.'),
                backgroundColor: Colors.red,
                duration: Duration(seconds: 3),
              ),
            );
          }
        }
      }
    } catch (e, stackTrace) {
      debugPrint('âŒ [PAYMENT] Error initiating payment: $e');
      debugPrint('Stack trace: $stackTrace');
      if (mounted) {
        setState(() {
          _isProcessingPayment = false;
          _pendingBookingPayload = null;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error initiating payment: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
      }
    }
  }

  Future<void> _initiateRazorpayWeb(Map<String, dynamic> options, double amount, Map<String, dynamic> bookingPayload) async {
    // For web, we need to use JavaScript interop to call Razorpay Checkout
    // Since dart:html/js interop requires additional setup, we'll use a simpler approach
    try {
      // Use dart:js_interop or create an HTML file that handles payment
      // For now, show a message and allow direct booking for web
      if (mounted) {
        final confirm = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Payment Required'),
            content: Text(
              'Monthly subscription requires payment of â‚¹${amount.toStringAsFixed(2)}.\n\n'
              'For web payments, Razorpay integration requires server-side order creation.\n\n'
              'Would you like to proceed with booking confirmation? (Payment can be completed later)',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('Continue'),
              ),
            ],
          ),
        );
        
        if (confirm == true) {
          // Submit booking (payment info not stored in bookings table)
          final result = await _submitBooking(bookingPayload);
          if (mounted) {
            setState(() {
              _isProcessingPayment = false;
              _pendingBookingPayload = null;
            });
            if (result['success'] == true) {
              Navigator.of(context).pop(); // Close booking sheet if open
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Booking created. Please complete payment via mobile app or contact support.'),
                  backgroundColor: Colors.orange,
                  duration: Duration(seconds: 5),
                ),
              );
            } else {
              final errorMsg = result['message'] ?? 'Failed to create booking';
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(errorMsg),
                  backgroundColor: Colors.red,
                  duration: const Duration(seconds: 5),
                ),
              );
            }
          }
        } else {
          setState(() {
            _isProcessingPayment = false;
            _pendingBookingPayload = null;
          });
        }
      }
    } catch (e) {
      debugPrint('Web payment error: $e');
      if (mounted) {
        setState(() {
          _isProcessingPayment = false;
          _pendingBookingPayload = null;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Payment initialization failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _fetch() async {
    try {
      final uri = Uri.parse('https://superdailys.com/superdailyapp/get_service_details.php?id=' + widget.serviceId.toString());
      final resp = await http.get(uri);
      if (resp.statusCode == 200) {
        final data = jsonDecode(resp.body);
        if (mounted) {
          setState(() {
            _service = data['service'];
            _loading = false;
          });
        }
      } else {
        if (mounted) setState(() { _loading = false; });
      }
    } catch (e) {
      if (mounted) setState(() { _loading = false; });
    }
  }

  @override
  Widget build(BuildContext context) {
    final primary = const Color(0xFF00BFA5);
    return Scaffold(
      appBar: AppBar(
        backgroundColor: primary,
        foregroundColor: Colors.white,
        title: const Text('Service Details'),
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : _service == null
              ? const Center(child: Text('Service not found'))
              : SingleChildScrollView(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _buildImages(),
                      const SizedBox(height: 12),
                      _buildBadges(),
                      const SizedBox(height: 16),
                      Text(
                        (_service!['name'] ?? '').toString(),
                        style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.w700, color: Colors.grey.shade900),
                      ),
                      const SizedBox(height: 8),
                      _buildPriceBlock(),
                      const SizedBox(height: 12),
                      _buildBookingNotice(primary),
                      const SizedBox(height: 16),
                      _buildOptionsSection(),
                      const SizedBox(height: 12),
                      if ((_service!['description'] ?? '').toString().isNotEmpty)
                        _buildTitledBox('Description', (_service!['description'] ?? '').toString()),
                      // Information section hidden as requested
                      if ((_service!['features'] ?? '').toString().isNotEmpty)
                        _buildBulletedBox('Features', (_service!['features'] ?? '').toString()),
                      if ((_service!['requirements'] ?? '').toString().isNotEmpty)
                        _buildRequirementsBox((_service!['requirements'] ?? '').toString()),
                      const SizedBox(height: 80),
                    ],
                  ),
                ),
      bottomNavigationBar: SafeArea(
              child: Padding(
                padding: const EdgeInsets.all(16),
                  child: SizedBox(
                  height: 48,
                  child: ElevatedButton(
                    style: ElevatedButton.styleFrom(backgroundColor: primary, foregroundColor: Colors.white, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
                    onPressed: () { _openBookingSheet(); },
                    child: const Text('Book Now'),
                  ),
                ),
              ),
            ),
    );
  }

  Widget _buildBadges() {
    final mainCat = (_service!['main_category'] ?? '').toString();
    final subCat = (_service!['subcategory'] ?? '').toString();
    final isFeatured = ((_service!['is_featured'] ?? 0).toString() == '1');
    List<Widget> chips = [];
    if (mainCat.isNotEmpty) chips.add(_pill(mainCat));
    if (subCat.isNotEmpty) chips.add(_pill(subCat));
    if (isFeatured) chips.add(_pill('Featured', color: Colors.orange));
    if (chips.isEmpty) return const SizedBox.shrink();
    return Wrap(spacing: 8, runSpacing: 8, children: chips);
  }

  Widget _pill(String text, {Color color = const Color(0xFF00BFA5)}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(color: color.withOpacity(0.12), borderRadius: BorderRadius.circular(24), border: Border.all(color: color.withOpacity(0.4))),
      child: Text(text, style: GoogleFonts.poppins(fontSize: 12, fontWeight: FontWeight.w600, color: _darken(color))),
    );
  }

  Color _darken(Color c, [double amount = 0.2]) {
    final hsl = HSLColor.fromColor(c);
    final hslDark = hsl.withLightness((hsl.lightness - amount).clamp(0.0, 1.0));
    return hslDark.toColor();
  }

  Widget _buildBookingNotice(Color primary) {
    final hrs = (_service!['booking_advance_hours'] ?? '').toString();
    if (hrs.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(color: primary.withOpacity(0.08), borderRadius: BorderRadius.circular(12), border: Border.all(color: primary.withOpacity(0.2))),
      child: Row(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Icon(Icons.info_outline, color: primary),
        const SizedBox(width: 10),
        Expanded(
          child: RichText(
            text: TextSpan(style: GoogleFonts.poppins(color: Colors.grey.shade800, fontSize: 13), children: [
              const TextSpan(text: 'Booking Notice Required\n', style: TextStyle(fontWeight: FontWeight.w700)),
              TextSpan(text: 'Please book this service at least '),
              TextSpan(text: hrs + ' hours ', style: const TextStyle(fontWeight: FontWeight.w700)),
              const TextSpan(text: 'in advance.'),
            ]),
          ),
        ),
      ]),
    );
  }

  Widget _buildOptionsSection() {
    final Map<String, double> options = {};
    void addOpt(String label, dynamic v) {
      final d = _parsePriceForDetails(v);
      if (d != null && d > 0) options[label] = d;
    }
    addOpt('1 BHK', _service!['price_1_bhk']);
    addOpt('2 BHK', _service!['price_2_bhk']);
    addOpt('3 BHK', _service!['price_3_bhk']);
    addOpt('4 BHK', _service!['price_4_bhk']);
    addOpt('2 Washrooms', _service!['price_2_washroom']);
    addOpt('3 Washrooms', _service!['price_3_washroom']);
    addOpt('4 Washrooms', _service!['price_4_washroom']);
    addOpt('4+ Washrooms', _service!['price_4_plus_washroom']);
    addOpt('1 Person', _service!['price_1_person']);
    addOpt('2 Persons', _service!['price_2_persons']);
    addOpt('1-2 Persons', _service!['price_1_2_persons']);
    addOpt('2-5 Persons', _service!['price_2_5_persons']);
    addOpt('5-10 Persons', _service!['price_5_10_persons']);
    addOpt('10+ Persons', _service!['price_10_plus_persons']);
    addOpt('Cooking', _service!['cooking_price']);
    addOpt('Cleaning', _service!['cleaning_price']);

    if (options.isEmpty) return const SizedBox.shrink();

    return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
      Text(
        'Choose the price',
        style: GoogleFonts.poppins(
          fontSize: 18,
          fontWeight: FontWeight.w700,
          color: Colors.grey.shade900,
        ),
      ),
      const SizedBox(height: 16),
      Wrap(
        spacing: 12,
        runSpacing: 12,
        children: options.entries.map((e) => _optionCard(e.key, e.value)).toList(),
      ),
    ]);
  }

  double? _parsePriceForDetails(dynamic priceValue) {
    if (priceValue == null || priceValue == '' || priceValue == 'null') return null;
    if (priceValue is String) {
      String s = priceValue.trim();
      s = s.replaceAll(RegExp(r'[â‚¹$,]'), '');
      s = s.replaceAll(RegExp(r'[^0-9\.-]'), '');
      final firstDot = s.indexOf('.');
      if (firstDot != -1) {
        final before = s.substring(0, firstDot + 1);
        final after = s.substring(firstDot + 1).replaceAll('.', '');
        s = before + after;
      }
      if (s.isEmpty || s == '-' || s == '.') return null;
      return double.tryParse(s);
    } else if (priceValue is num) {
      return priceValue.toDouble();
    }
    return null;
  }

  Widget _optionCard(String label, double price) {
    final isSelected = _selectedPriceOptionKey == label;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedPriceOptionKey = label;
          _selectedPriceOptionValue = price;
        });
      },
      child: Container(
        width: 150,
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF00BFA5).withOpacity(0.1) : Colors.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected ? const Color(0xFF00BFA5) : Colors.grey.shade300,
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Text(label, style: GoogleFonts.poppins(fontSize: 12, color: isSelected ? const Color(0xFF00BFA5) : Colors.grey.shade700, fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal)),
          const SizedBox(height: 6),
          Text('â‚¹' + price.toStringAsFixed(2), style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w700, color: isSelected ? const Color(0xFF00BFA5) : const Color(0xFF0D47A1))),
        ]),
      ),
    );
  }

  Widget _buildBulletedBox(String title, String text) {
    final items = _formatBullets(text);
    return Container(
      margin: const EdgeInsets.only(top: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(color: Colors.grey.shade50, borderRadius: BorderRadius.circular(12), border: Border.all(color: Colors.grey.shade200)),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Text(title, style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w700, color: Colors.grey.shade900)),
        const SizedBox(height: 8),
        ...items.map((s) => Padding(
          padding: const EdgeInsets.only(bottom: 8),
          child: Row(crossAxisAlignment: CrossAxisAlignment.start, children: [
            const Padding(padding: EdgeInsets.only(top: 6), child: Icon(Icons.check_circle, size: 12, color: Color(0xFF00BFA5))),
            const SizedBox(width: 8),
            Expanded(child: Text(s, style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade800, height: 1.5))),
          ]),
        )),
      ]),
    );
  }

  Widget _buildRequirementsBox(String text) {
    final items = _formatBullets(text);
    return Container(
      margin: const EdgeInsets.only(top: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.grey.shade50,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Requirements',
            style: GoogleFonts.poppins(
              fontSize: 16,
              fontWeight: FontWeight.w700,
              color: Colors.grey.shade900,
            ),
          ),
          const SizedBox(height: 8),
          ...items.map(
            (s) => Padding(
              padding: const EdgeInsets.only(bottom: 8),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Padding(
                    padding: EdgeInsets.only(top: 6),
                    child: Icon(
                      Icons.info,
                      size: 12,
                      color: Color(0xFF2196F3),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      s,
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        color: Colors.grey.shade800,
                        height: 1.5,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  // Helper method to check if price options are available
  bool _hasPriceOptions() {
    if (_service == null) return false;
    final Map<String, double> options = {};
    void addOpt(String label, dynamic v) {
      final d = _parsePriceForDetails(v);
      if (d != null && d > 0) options[label] = d;
    }
    addOpt('1 BHK', _service!['price_1_bhk']);
    addOpt('2 BHK', _service!['price_2_bhk']);
    addOpt('3 BHK', _service!['price_3_bhk']);
    addOpt('4 BHK', _service!['price_4_bhk']);
    addOpt('2 Washrooms', _service!['price_2_washroom']);
    addOpt('3 Washrooms', _service!['price_3_washroom']);
    addOpt('4 Washrooms', _service!['price_4_washroom']);
    addOpt('4+ Washrooms', _service!['price_4_plus_washroom']);
    addOpt('1 Person', _service!['price_1_person']);
    addOpt('2 Persons', _service!['price_2_persons']);
    addOpt('1-2 Persons', _service!['price_1_2_persons']);
    addOpt('2-5 Persons', _service!['price_2_5_persons']);
    addOpt('5-10 Persons', _service!['price_5_10_persons']);
    addOpt('10+ Persons', _service!['price_10_plus_persons']);
    addOpt('Cooking', _service!['cooking_price']);
    addOpt('Cleaning', _service!['cleaning_price']);
    return options.isNotEmpty;
  }

  bool _isMonthlySelection(String? label) {
    if (label == null) return false;
    final lower = label.toLowerCase();
    return lower.contains('monthly') || lower.contains('subscription');
  }

  String _normalizePaymentMethodValue(String? method) {
    final value = (method ?? '').trim().toLowerCase();
    if (value.contains('cod') || value.contains('cash')) {
      return 'cod';
    }
    if (value.contains('upi') || value.contains('card') || value.contains('online')) {
      return 'online';
    }
    if (value.contains('razorpay')) {
      return 'razorpay';
    }
    return value.isNotEmpty ? value : 'razorpay';
  }

  String _normalizePaymentStatusValue(String? status) {
    final value = (status ?? '').trim().toLowerCase();
    if (value.contains('paid') || value.contains('success')) {
      return 'paid';
    }
    if (value.contains('fail') || value.contains('error')) {
      return 'failed';
    }
    return 'pending';
  }

  void _openBookingSheet() async {
    debugPrint('ðŸ”µ [BOOKING] _openBookingSheet called');
    debugPrint('ðŸ”µ [BOOKING] Service data: ${_service != null ? "available" : "null"}');
    debugPrint('ðŸ”µ [BOOKING] Mounted: $mounted');
    debugPrint('ðŸ”µ [BOOKING] Payment processing: $_isProcessingPayment');
    
    // Check if price options are available and if a price has been selected
    if (_hasPriceOptions() && (_selectedPriceOptionKey == null || _selectedPriceOptionValue == null)) {
      debugPrint('âŒ [BOOKING] Price option not selected');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please select the price first'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 2),
          ),
        );
      }
      return;
    }
    
    // Check if user is logged in
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    if (!isLoggedIn) {
      debugPrint('âŒ [BOOKING] User not logged in, redirecting to login');
      if (mounted) {
        // Store the serviceId so we can return to this service panel after login
        await prefs.setInt('pendingServiceId', widget.serviceId);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please login to book a service'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 2),
          ),
        );
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const LoginPage()),
        );
      }
      return;
    }
    
    // Check if service data is available
    if (_service == null) {
      debugPrint('âŒ [BOOKING] Service is null, returning');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Service information not available. Please try again.'),
            backgroundColor: Colors.red,
          ),
        );
      }
      return;
    }

    // Check if context is still valid
    if (!mounted) {
      debugPrint('âŒ [BOOKING] Widget not mounted, returning');
      return;
    }

    // NOTE: Location permission checks and getting current position are now done
    // AFTER the modal is shown to avoid blocking the UI. The modal will show
    // immediately and location will be fetched asynchronously.
    ///
      // Declare controllers outside try block so they can be disposed in catch/whenComplete
      TextEditingController? locationCtrl;
      TextEditingController? contactCtrl;
      TextEditingController? notesCtrl;
      GoogleMapController? mapController;
      
      // Initialize controllers first
      locationCtrl = TextEditingController();
      contactCtrl = TextEditingController();
      notesCtrl = TextEditingController();
      
      // Capture current payment processing state to avoid stale state issues
      final currentPaymentProcessing = _isProcessingPayment;
      
      DateTime? preferredDate;
      TimeOfDay? preferredTime;
      String? selectedPriceKey;
      double selectedPriceValue = 0.0;
      String selectedPaymentMethod = 'online';
    
      // Map state variables
      mapController = null;
      LatLng? selectedLocation;
      Set<Marker> mapMarkers = {};
      List<Map<String, dynamic>> autocompleteSuggestions = [];
      bool isLoadingSuggestions = false;
      bool isMapInitialized = false;
      
      // Real-time tracking variables
      bool isTrackingLocation = false;
      StreamSubscription<Position>? locationStreamSubscription;
      
      // Service location and distance calculation
      double? serviceLat = _service?['service_latitude'] != null ? double.tryParse(_service!['service_latitude'].toString()) : null;
      double? serviceLng = _service?['service_longitude'] != null ? double.tryParse(_service!['service_longitude'].toString()) : null;
      double? distanceInMeters;
      bool isServiceAvailable = false;
      
      // Initialize service location marker if available
      if (serviceLat != null && serviceLng != null) {
        try {
          mapMarkers.add(
            Marker(
              markerId: const MarkerId('service_location'),
              position: LatLng(serviceLat, serviceLng),
              infoWindow: const InfoWindow(title: 'Service Location'),
              icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueGreen),
            ),
          );
        } catch (e) {
          debugPrint('Error adding service location marker: $e');
        }
      }

      Map<String, double> personPrices = _extractPersonPrices(_service!);
      Map<String, double> bhkPrices = _extractBhkPrices(_service!);
      final double? monthlyPrice = _extractMonthlyPrice(_service!);

      // Build all options map for use throughout the function
      final Map<String, double> allOptions = {}..addAll(personPrices)..addAll(bhkPrices);
      if (monthlyPrice != null && monthlyPrice > 0) {
        allOptions['Monthly Subscription'] = monthlyPrice;
      }

      // Check if price was already selected in service details screen
      if (_selectedPriceOptionKey != null && _selectedPriceOptionValue != null) {
        selectedPriceKey = _selectedPriceOptionKey;
        selectedPriceValue = _selectedPriceOptionValue!;
      } else {
        // Preselect a price if only one option exists; if none, fall back to base service price
        if (allOptions.length == 1) {
          selectedPriceKey = allOptions.keys.first;
          selectedPriceValue = allOptions.values.first;
        } else if (allOptions.isEmpty) {
          final base = _fallbackBasePrice(_service!);
          if (base != null) {
            selectedPriceKey = 'Base Price';
            selectedPriceValue = base;
          }
        }
      }

      void setSelected(String key, double value, void Function(void Function()) setModalState) {
        setModalState(() { selectedPriceKey = key; selectedPriceValue = value; });
      }

      if (!mounted) return;
      
      // Flag to track if modal is still open
      bool isModalOpen = true;
      // Flag to ensure location is only initialized once per modal
      bool locationInitialized = false;
      debugPrint('ðŸ”µ [BOOKING] Initializing booking sheet');
      debugPrint('ðŸ”µ [BOOKING] Service Lat: $serviceLat, Lng: $serviceLng');
      debugPrint('ðŸ”µ [BOOKING] Map markers count: ${mapMarkers.length}');
      debugPrint('ðŸ”µ [BOOKING] Controllers initialized');
      
      // Wrap modal in try-catch for error handling
      try {
        debugPrint('ðŸ”µ [BOOKING] Opening modal bottom sheet');
        await showModalBottomSheet(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.white,
          shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(16))),
          isDismissible: true,
          enableDrag: true,
          builder: (ctx) {
          debugPrint('ðŸ”µ [BOOKING] Modal builder called');
          try {
          return StatefulBuilder(builder: (ctx, setModalState) {
          debugPrint('ðŸ”µ [BOOKING] StatefulBuilder created');
          
          // Initialize location permissions and get current position AFTER modal is shown
          // This prevents blocking the UI and allows the modal to appear immediately
          Position? currentPosition;
          
          // Use post-frame callback to initialize location after modal is built
          WidgetsBinding.instance.addPostFrameCallback((_) async {
            if (!isModalOpen || !ctx.mounted || locationInitialized) return;
            locationInitialized = true;
            
            debugPrint('ðŸ”µ [BOOKING] Starting location initialization after modal shown');
            
            try {
              // Check location service
              bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
              if (!serviceEnabled) {
                debugPrint('âš ï¸ [BOOKING] Location services are disabled.');
                if (isModalOpen && ctx.mounted) {
                  ScaffoldMessenger.of(ctx).showSnackBar(
                    const SnackBar(
                      content: Text('Please enable location services to use map features.'),
                      backgroundColor: Colors.orange,
                      duration: Duration(seconds: 3),
                    ),
                  );
                }
                return;
              }

              // Check and request permission
              LocationPermission permission = await Geolocator.checkPermission();
              if (permission == LocationPermission.denied) {
                permission = await Geolocator.requestPermission();
                if (permission == LocationPermission.denied) {
                  debugPrint('âŒ [BOOKING] Location permission denied.');
                  if (isModalOpen && ctx.mounted) {
                    ScaffoldMessenger.of(ctx).showSnackBar(
                      const SnackBar(
                        content: Text('Location permission denied. Map features may be limited.'),
                        backgroundColor: Colors.orange,
                        duration: Duration(seconds: 3),
                      ),
                    );
                  }
                  return;
                }
              }

              if (permission == LocationPermission.deniedForever) {
                debugPrint('âŒ [BOOKING] Location permission permanently denied.');
                if (isModalOpen && ctx.mounted) {
                  ScaffoldMessenger.of(ctx).showSnackBar(
                    SnackBar(
                      content: const Text('Location permission permanently denied. Enable it from app settings.'),
                      backgroundColor: Colors.orange,
                      duration: const Duration(seconds: 3),
                      action: SnackBarAction(
                        label: 'Settings',
                        textColor: Colors.white,
                        onPressed: () {
                          Geolocator.openAppSettings();
                        },
                      ),
                    ),
                  );
                }
                return;
              }

              debugPrint('âœ… [BOOKING] Location permission granted.');
              
              // Get current position (non-blocking, happens in background)
              try {
                debugPrint('ðŸ”µ [BOOKING] Fetching current position...');
                final position = await Geolocator.getCurrentPosition(
                  desiredAccuracy: LocationAccuracy.medium, // Use medium for faster response
                  timeLimit: const Duration(seconds: 5), // Timeout after 5 seconds
                );
                currentPosition = position;
                debugPrint('âœ… [BOOKING] Current location: ${position.latitude}, ${position.longitude}');
                
                // Update map center if position is available
                if (isModalOpen && ctx.mounted && mapController != null) {
                  try {
                    await mapController!.animateCamera(
                      CameraUpdate.newLatLng(
                        LatLng(position.latitude, position.longitude),
                      ),
                    );
                  } catch (e) {
                    debugPrint('Error updating map center: $e');
                  }
                }
              } catch (e) {
                debugPrint('âš ï¸ [BOOKING] Error fetching location: $e');
                // Don't block the UI if location fetch fails
              }
            } catch (e) {
              debugPrint('âŒ [BOOKING] Error checking permissions: $e');
              // Don't block the UI if permission check fails
            }
          });
          
          // Function to fetch autocomplete suggestions
          Future<void> fetchAutocompleteSuggestions(String query) async {
            debugPrint('ðŸ”µ [BOOKING] fetchAutocompleteSuggestions called with: "$query"');
            debugPrint('ðŸ”µ [BOOKING] Modal open: $isModalOpen');
            if (!isModalOpen) return;
            if (query.trim().isEmpty) {
              if (isModalOpen && ctx.mounted) {
                try {
                  setModalState(() {
                    autocompleteSuggestions = [];
                  });
                } catch (e) {
                  debugPrint('Error clearing autocomplete: $e');
                }
              }
              return;
            }
            
            if (isModalOpen && ctx.mounted) {
              try {
                setModalState(() {
                  isLoadingSuggestions = true;
                });
              } catch (e) {
                debugPrint('Error setting loading state: $e');
              }
            }
            
            try {
              final url = Uri.parse('https://superdailys.com/superdailyapp/places_autocomplete.php?input=' + Uri.encodeComponent(query));
              final response = await http.get(url);
              
              if (response.statusCode == 200 && isModalOpen && ctx.mounted) {
                final data = jsonDecode(response.body);
                final predictions = data['predictions'] ?? [];
                try {
                  setModalState(() {
                    autocompleteSuggestions = List<Map<String, dynamic>>.from(predictions);
                    isLoadingSuggestions = false;
                  });
                } catch (e) {
                  debugPrint('Error updating autocomplete suggestions: $e');
                }
              } else if (isModalOpen && ctx.mounted) {
                try {
                  setModalState(() {
                    autocompleteSuggestions = [];
                    isLoadingSuggestions = false;
                  });
                } catch (e) {
                  debugPrint('Error clearing autocomplete: $e');
                }
              }
            } catch (e) {
              debugPrint('Error fetching autocomplete: $e');
              if (isModalOpen && ctx.mounted) {
                try {
                  setModalState(() {
                    autocompleteSuggestions = [];
                    isLoadingSuggestions = false;
                  });
                } catch (e2) {
                  debugPrint('Error resetting autocomplete state: $e2');
                }
              }
            }
          }
          
          // Function to calculate distance and availability
          void calculateDistanceAndAvailability(LatLng bookingLocation) {
            debugPrint('ðŸ”µ [BOOKING] calculateDistanceAndAvailability called');
            debugPrint('ðŸ”µ [BOOKING] Booking location: $bookingLocation');
            debugPrint('ðŸ”µ [BOOKING] Service location: lat=$serviceLat, lng=$serviceLng');
            debugPrint('ðŸ”µ [BOOKING] Modal open: $isModalOpen');
            if (!isModalOpen) {
              debugPrint('âš ï¸ [BOOKING] Modal closed, skipping distance calculation');
              return;
            }
            if (serviceLat == null || serviceLng == null) {
              debugPrint('âš ï¸ [BOOKING] Service location missing, setting unavailable');
              if (isModalOpen && ctx.mounted) {
                try {
                  setModalState(() {
                    distanceInMeters = null;
                    isServiceAvailable = false;
                  });
                } catch (e) {
                  debugPrint('Error setting unavailable state: $e');
                }
              }
              return;
            }
            
            try {
              debugPrint('ðŸ”µ [BOOKING] Calculating distance...');
              // Calculate distance in meters using Geolocator
              final distance = Geolocator.distanceBetween(
                serviceLat,
                serviceLng,
                bookingLocation.latitude,
                bookingLocation.longitude,
              );
              debugPrint('âœ… [BOOKING] Distance calculated: ${distance.toStringAsFixed(2)} meters');
              debugPrint('ðŸ”µ [BOOKING] Service available: ${distance <= 200}');
              
              if (isModalOpen && ctx.mounted) {
                try {
                  setModalState(() {
                    distanceInMeters = distance;
                    isServiceAvailable = distance <= 200; // Within 200 meters
                  });
                  debugPrint('âœ… [BOOKING] Distance and availability state updated');
                } catch (e) {
                  debugPrint('Error updating distance state: $e');
                }
              }
            } catch (e) {
              debugPrint('âŒ [BOOKING] Error calculating distance: $e');
              if (isModalOpen && ctx.mounted) {
                try {
                  setModalState(() {
                    distanceInMeters = null;
                    isServiceAvailable = false;
                  });
                } catch (e2) {
                  debugPrint('Error setting error state: $e2');
                }
              }
            }
          }
          
          // Function to get place details and update map
          Future<void> selectPlace(Map<String, dynamic> prediction) async {
            debugPrint('ðŸ”µ [BOOKING] selectPlace called');
            debugPrint('ðŸ”µ [BOOKING] Prediction: ${prediction['description']}');
            debugPrint('ðŸ”µ [BOOKING] Modal open: $isModalOpen');
            if (!isModalOpen) {
              debugPrint('âš ï¸ [BOOKING] Modal closed, ignoring place selection');
              return;
            }
            final placeId = prediction['place_id'];
            debugPrint('ðŸ”µ [BOOKING] Place ID: $placeId');
            if (placeId == null) {
              debugPrint('âŒ [BOOKING] Place ID is null, returning');
              return;
            }
            
            try {
              final url = Uri.parse('https://superdailys.com/superdailyapp/place_details.php?place_id=' + Uri.encodeComponent(placeId));
              final response = await http.get(url);
              
              if (!isModalOpen) return;
              
              if (response.statusCode == 200) {
                final data = jsonDecode(response.body);
                final result = data['result'];
                if (result != null && result['geometry'] != null) {
                  final location = result['geometry']['location'];
                  final lat = location['lat'] as double;
                  final lng = location['lng'] as double;
                  final bookingLatLng = LatLng(lat, lng);
                  
                  // Calculate distance and availability first
                  calculateDistanceAndAvailability(bookingLatLng);
                  
                  // Update map markers - show both service location and booking location
                  Set<Marker> newMarkers = Set.from(mapMarkers);
                  // Remove old booking location marker if exists
                  newMarkers.removeWhere((m) => m.markerId.value == 'selected_location' || m.markerId.value == 'current_location');
                  // Add new booking location marker
                  newMarkers.add(
                    Marker(
                      markerId: const MarkerId('selected_location'),
                      position: bookingLatLng,
                      infoWindow: InfoWindow(title: prediction['description'] ?? 'Booking Location'),
                    ),
                  );
                  
                  if (isModalOpen && locationCtrl != null && ctx.mounted) {
                    try {
                      setModalState(() {
                        selectedLocation = bookingLatLng;
                        locationCtrl!.text = prediction['description'] ?? '';
                        autocompleteSuggestions = [];
                        mapMarkers = newMarkers;
                      });
                    } catch (e) {
                      debugPrint('Error updating place selection: $e');
                    }
                  }
                  
                  // Move map camera to show both locations (after state update)
                  Future.delayed(const Duration(milliseconds: 300), () {
                    if (!isModalOpen || mapController == null || selectedLocation == null) return;
                    try {
                      final currentMapController = mapController;
                      if (currentMapController != null && serviceLat != null && serviceLng != null) {
                        // Calculate bounds to show both locations
                        final bounds = LatLngBounds(
                          southwest: LatLng(
                            bookingLatLng.latitude < serviceLat ? bookingLatLng.latitude : serviceLat,
                            bookingLatLng.longitude < serviceLng ? bookingLatLng.longitude : serviceLng,
                          ),
                          northeast: LatLng(
                            bookingLatLng.latitude > serviceLat ? bookingLatLng.latitude : serviceLat,
                            bookingLatLng.longitude > serviceLng ? bookingLatLng.longitude : serviceLng,
                          ),
                        );
                        currentMapController.animateCamera(
                          CameraUpdate.newLatLngBounds(bounds, 100),
                        );
                      } else if (currentMapController != null) {
                        currentMapController.animateCamera(
                          CameraUpdate.newLatLngZoom(bookingLatLng, 15),
                        );
                      }
                    } catch (e) {
                      debugPrint('Error animating camera: $e');
                    }
                  });
                }
              }
            } catch (e) {
              debugPrint('Error getting place details: $e');
            }
          }
          
          // Safe MediaQuery access with error handling
          double bottomPadding = 16;
          try {
            if (ctx.mounted) {
              bottomPadding = MediaQuery.of(ctx).viewInsets.bottom + 16;
            }
          } catch (e) {
            debugPrint('Error getting MediaQuery: $e');
            bottomPadding = 16;
          }
          
          final bool isMonthlySelection = _isMonthlySelection(selectedPriceKey);
          final bool showPaymentOptions = !isMonthlySelection;
          final double codFee = showPaymentOptions && selectedPaymentMethod == 'cod' ? _codConvenienceFee : 0.0;
          final double payableAmount = (selectedPriceValue > 0 ? selectedPriceValue : 0) + codFee;

          return Padding(
            padding: EdgeInsets.only(
              left: 16,
              right: 16,
              top: 16,
              bottom: bottomPadding,
            ),
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text('Book Service', style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w700)),
                      const Spacer(),
                      IconButton(onPressed: () {
                        isModalOpen = false;
                        Navigator.of(ctx).pop();
                      }, icon: const Icon(Icons.close)),
                    ],
                  ),
                  const SizedBox(height: 8),
                  // Preferred Date
                  Text('Preferred Date', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: Colors.grey.shade700)),
                  const SizedBox(height: 6),
                  InkWell(
                    onTap: () async {
                      if (!isModalOpen || !ctx.mounted) return;
                      try {
                        final now = DateTime.now();
                        final picked = await showDatePicker(context: ctx, initialDate: now, firstDate: now, lastDate: now.add(const Duration(days: 365)));
                        if (picked != null && isModalOpen && ctx.mounted) {
                          try {
                            setModalState(() { preferredDate = picked; });
                          } catch (e) {
                            debugPrint('Error setting date: $e');
                          }
                        }
                      } catch (e) {
                        debugPrint('Error opening date picker: $e');
                        if (isModalOpen && ctx.mounted) {
                          ScaffoldMessenger.of(ctx).showSnackBar(
                            const SnackBar(content: Text('Unable to open date picker')),
                          );
                        }
                      }
                    },
                    child: _formBox(
                      child: Row(children: [
                        const Icon(Icons.calendar_today, size: 18, color: Color(0xFF00BFA5)),
                        const SizedBox(width: 8),
                        Text(preferredDate == null ? 'Select date' : _fmtDate(preferredDate!), style: GoogleFonts.poppins(fontSize: 14)),
                      ]),
                    ),
                  ),
                  const SizedBox(height: 12),
                  // Preferred Time
                  Text('Preferred Time', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: Colors.grey.shade700)),
                  const SizedBox(height: 6),
                  InkWell(
                    onTap: () async {
                      if (!isModalOpen || !ctx.mounted) return;
                      try {
                        final picked = await showTimePicker(context: ctx, initialTime: TimeOfDay.now());
                        if (picked != null && isModalOpen && ctx.mounted) {
                          try {
                            setModalState(() { preferredTime = picked; });
                          } catch (e) {
                            debugPrint('Error setting time: $e');
                          }
                        }
                      } catch (e) {
                        debugPrint('Error opening time picker: $e');
                        if (isModalOpen && ctx.mounted) {
                          ScaffoldMessenger.of(ctx).showSnackBar(
                            const SnackBar(content: Text('Unable to open time picker')),
                          );
                        }
                      }
                    },
                    child: _formBox(
                      child: Row(children: [
                        const Icon(Icons.access_time, size: 18, color: Color(0xFF00BFA5)),
                        const SizedBox(width: 8),
                        Text(
                          preferredTime == null
                            ? 'Select time'
                            : (() {
                                try {
                                  return preferredTime!.format(ctx);
                                } catch (e) {
                                  debugPrint('Error formatting time: $e');
                                  return '${preferredTime!.hour.toString().padLeft(2, '0')}:${preferredTime!.minute.toString().padLeft(2, '0')}';
                                }
                              })(),
                          style: GoogleFonts.poppins(fontSize: 14),
                        ),
                      ]),
                    ),
                  ),
                  const SizedBox(height: 12),
                  // Location Search Bar with Autocomplete
                  Text('Search Location', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: Colors.grey.shade700)),
                  const SizedBox(height: 6),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _formBox(
                        child: TextField(
                          controller: locationCtrl,
                          decoration: InputDecoration(
                            border: InputBorder.none,
                            hintText: 'Search address or area',
                            prefixIcon: isLoadingSuggestions
                                ? const SizedBox(
                                    width: 20,
                                    height: 20,
                                    child: Padding(
                                      padding: EdgeInsets.all(12.0),
                                      child: CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF00BFA5)),
                                    ),
                                  )
                                : const Icon(Icons.search, color: Color(0xFF00BFA5)),
                            suffixIcon: (locationCtrl != null && locationCtrl!.text.isNotEmpty)
                                ? IconButton(
                                    icon: const Icon(Icons.clear, size: 20),
                                    onPressed: () {
                                      if (isModalOpen && locationCtrl != null && ctx.mounted) {
                                        try {
                                          setModalState(() {
                                            locationCtrl!.clear();
                                            autocompleteSuggestions = [];
                                            selectedLocation = null;
                                            mapMarkers = {};
                                          });
                                        } catch (e) {
                                          debugPrint('Error clearing location: $e');
                                        }
                                      }
                                    },
                                  )
                                : null,
                          ),
                          onChanged: (value) {
                            if (!isModalOpen) return;
                            try {
                              setModalState(() {});
                              if (value.length >= 3) {
                                fetchAutocompleteSuggestions(value);
                              } else {
                                if (isModalOpen) {
                                  setModalState(() {
                                    autocompleteSuggestions = [];
                                  });
                                }
                              }
                            } catch (e) {
                              debugPrint('Error in location field onChanged: $e');
                            }
                          },
                        ),
                      ),
                      // Autocomplete suggestions dropdown - placed below the search box
                      if (autocompleteSuggestions.isNotEmpty)
                        Container(
                          margin: const EdgeInsets.only(top: 4),
                          constraints: const BoxConstraints(maxHeight: 200),
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(10),
                            border: Border.all(color: Colors.grey.shade300),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.15),
                                blurRadius: 10,
                                offset: const Offset(0, 4),
                              ),
                            ],
                          ),
                          child: Material(
                            color: Colors.transparent,
                            child: ListView.builder(
                              shrinkWrap: true,
                              padding: EdgeInsets.zero,
                              itemCount: autocompleteSuggestions.length > 5 ? 5 : autocompleteSuggestions.length,
                              itemBuilder: (context, index) {
                                final suggestion = autocompleteSuggestions[index];
                                return InkWell(
                                  onTap: () {
                                    selectPlace(suggestion);
                                  },
                                  child: Padding(
                                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                    child: Row(
                                      children: [
                                        const Icon(Icons.location_on, color: Color(0xFF00BFA5), size: 20),
                                        const SizedBox(width: 12),
                                        Expanded(
                                          child: Text(
                                            suggestion['description'] ?? '',
                                            style: GoogleFonts.poppins(fontSize: 14),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                );
                              },
                            ),
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  /// Google Map
                  Container(
                    height: 250,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(10),
                      border: Border.all(color: Colors.grey.shade300),
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(10),
                      child: Builder(
                        builder: (mapContext) {
                          // Safe default location
                          LatLng defaultLocation;
                          double defaultZoom;
                          try {
                            if (selectedLocation != null) {
                              defaultLocation = selectedLocation!;
                              defaultZoom = 15;
                            } else if (serviceLat != null && serviceLng != null) {
                              defaultLocation = LatLng(serviceLat, serviceLng);
                              defaultZoom = 14;
                            } else {
                              defaultLocation = const LatLng(28.6139, 77.2090);
                              defaultZoom = 12;
                            }
                          } catch (e) {
                            debugPrint('Error setting default location: $e');
                            defaultLocation = const LatLng(28.6139, 77.2090);
                            defaultZoom = 12;
                          }

                          try {
                            return GoogleMap(
                              key: const ValueKey('booking_map'), // Stable key to prevent unnecessary rebuilds
                              initialCameraPosition: CameraPosition(
                                target: defaultLocation,
                                zoom: defaultZoom,
                              ),
                              mapType: MapType.normal,
                              myLocationEnabled: isTrackingLocation, // Enable when real-time tracking is active
                              myLocationButtonEnabled: false,
                              zoomControlsEnabled: false,
                              markers: mapMarkers,
                              onTap: (LatLng latLng) {
                                // Optional: Handle map tap
                              },
                              onMapCreated: (GoogleMapController controller) {
                                try {
                                  debugPrint('ðŸ”µ [BOOKING] GoogleMap onMapCreated called');
                                  debugPrint('ðŸ”µ [BOOKING] Modal open: $isModalOpen');
                                  if (!isModalOpen) {
                                    debugPrint('âš ï¸ [BOOKING] Modal closed when map created, skipping');
                                    // Don't dispose manually - GoogleMap handles its own lifecycle
                                    return;
                                  }
                                  // Store the controller reference
                                  mapController = controller;
                                  isMapInitialized = true;
                                  debugPrint('âœ… [BOOKING] Map controller initialized: ${controller != null}');
                                  debugPrint('âœ… [BOOKING] Map initialized flag: $isMapInitialized');

                                  // If we already have a selected location, move camera to it after a short delay
                                  if (selectedLocation != null && isModalOpen) {
                                    Future.delayed(const Duration(milliseconds: 500), () {
                                      if (!isModalOpen || mapController == null || selectedLocation == null) return;
                                      try {
                                        if (mapController != null) {
                                          mapController!.animateCamera(
                                            CameraUpdate.newLatLngZoom(selectedLocation!, 15),
                                          );
                                        }
                                      } catch (e) {
                                        debugPrint('Error animating camera on map created: $e');
                                      }
                                    });
                                  }
                                } catch (e) {
                                  debugPrint('Error in onMapCreated: $e');
                                }
                              },
                            );
                            } catch (e, stackTrace) {
                              debugPrint('âŒ Error creating GoogleMap: $e');
                              debugPrint('Stack trace: $stackTrace');
                              // Return a safe fallback widget
                              return Container(
                                height: 250,
                                color: Colors.grey.shade200,
                                child: Center(
                                  child: Column(
                                    mainAxisAlignment: MainAxisAlignment.center,
                                    children: [
                                      Icon(Icons.map_outlined, size: 48, color: Colors.grey.shade400),
                                      const SizedBox(height: 8),
                                      Text(
                                        'Map unavailable',
                                        style: GoogleFonts.poppins(
                                          fontSize: 14,
                                          color: Colors.grey.shade600,
                                        ),
                                      ),
                                      const SizedBox(height: 4),
                                      Text(
                                        'You can still continue booking',
                                        style: GoogleFonts.poppins(
                                          fontSize: 12,
                                          color: Colors.grey.shade500,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              );
                            }
                        },
                      ),
                    ),
                  ),
                  /// Distance and Availability Status
                  if (selectedLocation != null && distanceInMeters != null)
                    Container(
                      margin: const EdgeInsets.only(top: 8),
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: isServiceAvailable ? Colors.green.shade50 : Colors.red.shade50,
                        borderRadius: BorderRadius.circular(10),
                        border: Border.all(
                          color: isServiceAvailable ? Colors.green.shade300 : Colors.red.shade300,
                          width: 1.5,
                        ),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            isServiceAvailable ? Icons.check_circle : Icons.cancel,
                            color: isServiceAvailable ? Colors.green.shade700 : Colors.red.shade700,
                            size: 24,
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  isServiceAvailable ? 'Service Available' : 'Service Unavailable',
                                  style: GoogleFonts.poppins(
                                    fontSize: 14,
                                    fontWeight: FontWeight.w700,
                                    color: isServiceAvailable ? Colors.green.shade700 : Colors.red.shade700,
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  'Distance: ${distanceInMeters!.toStringAsFixed(0)} meters (${(distanceInMeters! / 1000).toStringAsFixed(2)} km)',
                                  style: GoogleFonts.poppins(
                                    fontSize: 12,
                                    color: Colors.grey.shade700,
                                  ),
                                ),
                                if (!isServiceAvailable)
                                  Padding(
                                    padding: const EdgeInsets.only(top: 4),
                                    child: Text(
                                      'Service is only available within 200 meters',
                                      style: GoogleFonts.poppins(
                                        fontSize: 11,
                                        color: Colors.red.shade600,
                                        fontStyle: FontStyle.italic,
                                      ),
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  const SizedBox(height: 12),
                  // Real-time Tracking Toggle
                  Container(
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(10),
                      border: Border.all(
                        color: isTrackingLocation ? Colors.green : Colors.grey.shade300,
                        width: 1.5,
                      ),
                      color: isTrackingLocation ? Colors.green.shade50 : Colors.white,
                    ),
                    child: ListTile(
                      leading: Icon(
                        isTrackingLocation ? Icons.my_location : Icons.location_searching,
                        color: isTrackingLocation ? Colors.green : Colors.grey.shade700,
                      ),
                      title: Text(
                        isTrackingLocation ? 'Real-time Tracking Active' : 'Enable Real-time Tracking',
                        style: GoogleFonts.poppins(
                          fontWeight: FontWeight.w600,
                          color: isTrackingLocation ? Colors.green.shade700 : Colors.grey.shade700,
                        ),
                      ),
                      subtitle: Text(
                        isTrackingLocation ? 'Your location is updating live' : 'Track your location in real-time',
                        style: GoogleFonts.poppins(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                      ),
                      trailing: Switch(
                        value: isTrackingLocation,
                        onChanged: (currentPaymentProcessing || !isModalOpen) ? null : (value) async {
                          debugPrint('ðŸ”µ [BOOKING] Real-time tracking switch changed: $value');
                          debugPrint('ðŸ”µ [BOOKING] Payment processing: $currentPaymentProcessing');
                          debugPrint('ðŸ”µ [BOOKING] Modal open: $isModalOpen');
                          if (!isModalOpen || !ctx.mounted) {
                            debugPrint('âš ï¸ [BOOKING] Modal closed or context invalid, ignoring tracking toggle');
                            return;
                          }
                          try {

                          if (value) {
                            debugPrint('ðŸ”µ [BOOKING] Starting real-time tracking...');
                            // Start real-time tracking
                            try {
                              // Request location permission first
                              debugPrint('ðŸ”µ [BOOKING] Checking location service...');
                              bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
                              debugPrint('ðŸ”µ [BOOKING] Location service enabled: $serviceEnabled');
                              if (!serviceEnabled) {
                                debugPrint('âŒ [BOOKING] Location service disabled');
                                if (isModalOpen) {
                                  ScaffoldMessenger.of(ctx).showSnackBar(
                                    const SnackBar(content: Text('Location services are disabled. Please enable location services in settings.')),
                                  );
                                }
                                return;
                              }

                              debugPrint('ðŸ”µ [BOOKING] Checking location permission...');
                              LocationPermission permission = await Geolocator.checkPermission();
                              debugPrint('ðŸ”µ [BOOKING] Current permission: $permission');
                              if (permission == LocationPermission.denied) {
                                debugPrint('ðŸ”µ [BOOKING] Requesting location permission...');
                                permission = await Geolocator.requestPermission();
                                debugPrint('ðŸ”µ [BOOKING] Permission after request: $permission');
                                if (permission == LocationPermission.denied) {
                                  debugPrint('âŒ [BOOKING] Location permission denied');
                                  if (isModalOpen) {
                                    ScaffoldMessenger.of(ctx).showSnackBar(
                                      const SnackBar(content: Text('Location permission denied. Please enable location permission to use this feature.')),
                                    );
                                  }
                                  return;
                                }
                              }

                              if (permission == LocationPermission.deniedForever) {
                                if (isModalOpen) {
                                  ScaffoldMessenger.of(ctx).showSnackBar(
                                    const SnackBar(content: Text('Location permissions are permanently denied. Please enable them in app settings.')),
                                  );
                                }
                                return;
                              }

                              // Start location stream
                              debugPrint('ðŸ”µ [BOOKING] Starting location stream...');
                              locationStreamSubscription = Geolocator.getPositionStream(
                                locationSettings: const LocationSettings(
                                  accuracy: LocationAccuracy.high,
                                  distanceFilter: 5, // Update every 5 meters
                                ),
                              ).listen((Position position) {
                                debugPrint('ðŸ“ [BOOKING] Location update received: ${position.latitude}, ${position.longitude}');
                                debugPrint('ðŸ“ [BOOKING] Modal open: $isModalOpen');
                                if (!isModalOpen) {
                                  debugPrint('âš ï¸ [BOOKING] Modal closed, ignoring location update');
                                  return;
                                }

                                final newLocation = LatLng(position.latitude, position.longitude);
                                selectedLocation = newLocation;
                                debugPrint('ðŸ“ [BOOKING] New location set: $newLocation');

                                // Update markers
                                Set<Marker> newMarkers = Set.from(mapMarkers);
                                newMarkers.removeWhere((m) => m.markerId.value == 'current_location' || m.markerId.value == 'tracking_location');

                                newMarkers.add(
                                  Marker(
                                    markerId: const MarkerId('tracking_location'),
                                    position: newLocation,
                                    infoWindow: const InfoWindow(title: 'Your Current Location'),
                                    icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueAzure),
                                  ),
                                );

                                if (isModalOpen) {
                                  try {
                                    setModalState(() {
                                      selectedLocation = newLocation;
                                      mapMarkers = newMarkers;
                                      isTrackingLocation = true;
                                    });
                                  } catch (e) {
                                    debugPrint('Error in setModalState for location update: $e');
                                  }
                                }

                                // Calculate distance and availability
                                calculateDistanceAndAvailability(newLocation);

                                // Update location text field
                                if (locationCtrl != null && isModalOpen) {
                                  try {
                                    setModalState(() {
                                      locationCtrl!.text = 'Lat: ${position.latitude.toStringAsFixed(6)}, Lng: ${position.longitude.toStringAsFixed(6)}';
                                    });
                                  } catch (e) {
                                    debugPrint('Error updating location text: $e');
                                  }
                                }

                                // Move camera to follow location (smooth animation)
                                debugPrint('ðŸ“ [BOOKING] Attempting to move camera');
                                debugPrint('ðŸ“ [BOOKING] Map controller: ${mapController != null}');
                                debugPrint('ðŸ“ [BOOKING] Modal open: $isModalOpen');
                                if (mapController != null && isModalOpen) {
                                  try {
                                    debugPrint('ðŸ“ [BOOKING] Animating camera to: $newLocation');
                                    mapController!.animateCamera(
                                      CameraUpdate.newLatLng(newLocation),
                                    );
                                    debugPrint('âœ… [BOOKING] Camera animation started');
                                  } catch (e) {
                                    debugPrint('âŒ [BOOKING] Error moving camera in tracking: $e');
                                  }
                                } else {
                                  debugPrint('âš ï¸ [BOOKING] Cannot move camera: controller=${mapController != null}, modal=$isModalOpen');
                                }

                                // Try to get address
                                placemarkFromCoordinates(position.latitude, position.longitude).then((placemarks) {
                                  if (!isModalOpen || locationCtrl == null) return;
                                  if (placemarks.isNotEmpty) {
                                    final place = placemarks[0];
                                    final addr = '${place.street ?? ''} ${place.subLocality ?? ''} ${place.locality ?? ''}'.trim();
                                    if (addr.isNotEmpty && isModalOpen) {
                                      try {
                                        setModalState(() {
                                          locationCtrl!.text = addr;
                                        });
                                      } catch (e) {
                                        debugPrint('Error updating address in tracking: $e');
                                      }
                                    }
                                  }
                                }).catchError((e) {
                                  debugPrint('Error getting address in tracking: $e');
                                });
                              });

                              debugPrint('âœ… [BOOKING] Setting tracking state to true');
                              if (isModalOpen && ctx.mounted) {
                                try {
                                  setModalState(() {
                                    isTrackingLocation = true;
                                  });
                                  debugPrint('âœ… [BOOKING] Real-time tracking started successfully');

                                  if (isModalOpen && ctx.mounted) {
                                    debugPrint('ðŸ”µ [BOOKING] Showing success snackbar');
                                    ScaffoldMessenger.of(ctx).showSnackBar(
                                      const SnackBar(
                                        content: Text('Real-time tracking started'),
                                        backgroundColor: Colors.green,
                                        duration: Duration(seconds: 2),
                                      ),
                                    );
                                  }
                                } catch (e) {
                                  debugPrint('Error setting tracking state: $e');
                                }
                              }
                            } catch (e) {
                              debugPrint('Error starting real-time tracking: $e');
                              if (isModalOpen) {
                                ScaffoldMessenger.of(ctx).showSnackBar(
                                  SnackBar(
                                    content: Text('Error starting tracking: ${e.toString()}'),
                                    backgroundColor: Colors.red,
                                  ),
                                );
                              }
                            }
                          } else {
                            // Stop real-time tracking
                            try {
                              debugPrint('ðŸ”µ [BOOKING] Stopping real-time tracking...');
                              locationStreamSubscription?.cancel();
                              locationStreamSubscription = null;
                              debugPrint('âœ… [BOOKING] Location stream cancelled');
                              if (isModalOpen && ctx.mounted) {
                                setModalState(() {
                                  isTrackingLocation = false;
                                });
                                debugPrint('âœ… [BOOKING] Tracking state set to false');
                                if (isModalOpen && ctx.mounted) {
                                  debugPrint('ðŸ”µ [BOOKING] Showing stop snackbar');
                                  ScaffoldMessenger.of(ctx).showSnackBar(
                                    const SnackBar(
                                      content: Text('Real-time tracking stopped'),
                                      backgroundColor: Colors.orange,
                                      duration: Duration(seconds: 2),
                                    ),
                                  );
                                }
                              }
                            } catch (e) {
                              debugPrint('Error stopping real-time tracking: $e');
                            }
                          }
                          } catch (e) {
                            debugPrint('âŒ Error in tracking switch callback: $e');
                            if (isModalOpen && ctx.mounted) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                SnackBar(
                                  content: Text('Error: ${e.toString()}'),
                                  backgroundColor: Colors.red,
                                ),
                              );
                            }
                          }
                        },
                        activeColor: Colors.green,
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  // Current Location Button (One-time)
                  SizedBox(
                    width: double.infinity,
                    child: ElevatedButton.icon(
                      onPressed: (currentPaymentProcessing || !isModalOpen) ? null : () async {
                        debugPrint('ðŸ”µ [BOOKING] Current Location button pressed');
                        debugPrint('ðŸ”µ [BOOKING] Payment processing: $currentPaymentProcessing');
                        debugPrint('ðŸ”µ [BOOKING] Modal open: $isModalOpen');
                        debugPrint('ðŸ”µ [BOOKING] Map controller: ${mapController != null}');
                        // Show loading
                        ScaffoldMessenger.of(ctx).showSnackBar(
                          const SnackBar(
                            content: Row(
                              children: [
                                SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                  ),
                                ),
                                SizedBox(width: 12),
                                Text('Getting your location...'),
                              ],
                            ),
                            duration: Duration(seconds: 2),
                          ),
                        );

                        try {
                          if (!isModalOpen) return;

                          // Request location permission
                          bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
                          if (!serviceEnabled) {
                            if (isModalOpen) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                const SnackBar(content: Text('Location services are disabled. Please enable location services in settings.')),
                              );
                            }
                            return;
                          }

                          if (!isModalOpen) return;

                          LocationPermission permission = await Geolocator.checkPermission();
                          if (permission == LocationPermission.denied) {
                            permission = await Geolocator.requestPermission();
                            if (!isModalOpen) return;
                            if (permission == LocationPermission.denied) {
                              if (isModalOpen) {
                                ScaffoldMessenger.of(ctx).showSnackBar(
                                  const SnackBar(content: Text('Location permission denied. Please enable location permission to use this feature.')),
                                );
                              }
                              return;
                            }
                          }

                          if (!isModalOpen) return;

                          if (permission == LocationPermission.deniedForever) {
                            if (isModalOpen) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                const SnackBar(content: Text('Location permissions are permanently denied. Please enable them in app settings.')),
                              );
                            }
                            return;
                          }

                          if (!isModalOpen) return;

                          // Ensure we have permission
                          if (permission != LocationPermission.whileInUse && permission != LocationPermission.always) {
                            if (isModalOpen) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                const SnackBar(content: Text('Location permission not granted')),
                              );
                            }
                            return;
                          }

                          if (!isModalOpen) return;

                          // Get current position with timeout
                          Position position = await Geolocator.getCurrentPosition(
                            desiredAccuracy: LocationAccuracy.high,
                            timeLimit: const Duration(seconds: 10),
                          ).timeout(
                            const Duration(seconds: 15),
                            onTimeout: () {
                              throw Exception('Location request timed out. Please try again.');
                            },
                          );

                          debugPrint('ðŸ“ Current location obtained: ${position.latitude}, ${position.longitude}');

                          // Check if modal is still open
                          if (!isModalOpen) return;

                          // Update location and map immediately
                          final currentLatLng = LatLng(position.latitude, position.longitude);

                          // Calculate distance and availability
                          calculateDistanceAndAvailability(currentLatLng);

                          // Update map markers - keep service location, replace booking location
                          Set<Marker> newMarkers = Set.from(mapMarkers);
                          // Remove old booking location markers
                          newMarkers.removeWhere((m) => m.markerId.value == 'selected_location' || m.markerId.value == 'current_location');

                          // Try to reverse geocode for address
                          String address = '';
                          try {
                            List<Placemark> placemarks = await placemarkFromCoordinates(
                              position.latitude,
                              position.longitude,
                            ).timeout(const Duration(seconds: 5));

                            if (placemarks.isNotEmpty) {
                              Placemark place = placemarks[0];
                              address = [
                                place.street,
                                place.subThoroughfare,
                                place.thoroughfare,
                                place.locality,
                                place.administrativeArea,
                                place.postalCode,
                                place.country,
                              ].where((s) => s != null && s.isNotEmpty && s.toString().trim().isNotEmpty).join(', ');
                            }
                          } catch (e) {
                            debugPrint('Geocoding error: $e');
                            // Continue without address
                          }

                          // Add new current location marker
                          newMarkers.add(
                            Marker(
                              markerId: const MarkerId('current_location'),
                              position: currentLatLng,
                              infoWindow: InfoWindow(title: address.isEmpty ? 'Your Current Location' : address),
                              icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueAzure),
                            ),
                          );

                          // Update state first
                          if (isModalOpen && locationCtrl != null) {
                            setModalState(() {
                              locationCtrl!.text = address.isEmpty
                                  ? 'Lat: ${position.latitude.toStringAsFixed(6)}, Lng: ${position.longitude.toStringAsFixed(6)}'
                                  : address;
                              selectedLocation = currentLatLng;
                              mapMarkers = newMarkers;
                            });
                          }

                          // Wait a bit for state to update and map to be ready
                          await Future.delayed(const Duration(milliseconds: 500));

                          // Move map camera - ensure controller is ready
                          if (!isModalOpen || mapController == null) {
                            debugPrint('âš ï¸ Cannot move camera: modal closed or controller null');
                            if (isModalOpen) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                const SnackBar(
                                  content: Text('Location found. Please wait for map to load.'),
                                  backgroundColor: Colors.orange,
                                ),
                              );
                            }
                            return;
                          }

                          try {
                            final currentMapController = mapController;
                            if (currentMapController == null) return;

                            if (serviceLat != null && serviceLng != null) {
                              // Show both locations in bounds with padding
                              final bounds = LatLngBounds(
                                southwest: LatLng(
                                  currentLatLng.latitude < serviceLat ? currentLatLng.latitude : serviceLat,
                                  currentLatLng.longitude < serviceLng ? currentLatLng.longitude : serviceLng,
                                ),
                                northeast: LatLng(
                                  currentLatLng.latitude > serviceLat ? currentLatLng.latitude : serviceLat,
                                  currentLatLng.longitude > serviceLng ? currentLatLng.longitude : serviceLng,
                                ),
                              );
                              currentMapController.animateCamera(
                                CameraUpdate.newLatLngBounds(bounds, 150),
                              );
                            } else {
                              // Just show current location
                              currentMapController.animateCamera(
                                CameraUpdate.newLatLngZoom(
                                  currentLatLng,
                                  16,
                                ),
                              );
                            }

                            debugPrint('âœ… Map camera moved to current location');

                            if (isModalOpen) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    address.isEmpty
                                        ? 'Location found: ${position.latitude.toStringAsFixed(6)}, ${position.longitude.toStringAsFixed(6)}'
                                        : 'Location: $address',
                                  ),
                                  duration: const Duration(seconds: 3),
                                  backgroundColor: Colors.green,
                                ),
                              );
                            }
                          } catch (e) {
                            debugPrint('âŒ Error animating camera: $e');
                            if (isModalOpen) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                SnackBar(
                                  content: Text('Location found but map update failed: ${e.toString()}'),
                                  backgroundColor: Colors.orange,
                                  duration: const Duration(seconds: 3),
                                ),
                              );
                            }
                          }
                        } catch (e) {
                          debugPrint('âŒ [BOOKING] Error getting location: $e');
                          debugPrint('âŒ [BOOKING] Error stack trace: ${StackTrace.current}');
                          ScaffoldMessenger.of(ctx).showSnackBar(
                            SnackBar(
                              content: Text('Error getting location: ${e.toString()}'),
                              backgroundColor: Colors.red,
                              duration: const Duration(seconds: 4),
                            ),
                          );
                        }
                      },
                      icon: const Icon(Icons.my_location, color: Colors.white),
                      label: Text('Current Location', style: GoogleFonts.poppins(color: Colors.white)),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF00BFA5),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  // Contact
                  Text('Contact Number', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: Colors.grey.shade700)),
                  const SizedBox(height: 6),
                  _formBox(child: TextField(controller: contactCtrl, keyboardType: TextInputType.phone, decoration: const InputDecoration(border: InputBorder.none, hintText: 'e.g. 9876543210'))),
                  const SizedBox(height: 12),
                  // Notes
                  Text('Special Instructions', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: Colors.grey.shade700)),
                  const SizedBox(height: 6),
                  _formBox(child: TextField(controller: notesCtrl, maxLines: 3, decoration: const InputDecoration(border: InputBorder.none, hintText: 'Any notes for professional'))),

                  const SizedBox(height: 16),
                  // Price Options
                  // If price was pre-selected in service details, just display it
                  if (_selectedPriceOptionKey != null && _selectedPriceOptionValue != null) ...[
                    Text('Selected Price', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w700, color: Colors.grey.shade800)),
                    const SizedBox(height: 8),
                    Container(
                      padding: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        color: const Color(0xFF00BFA5).withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(color: const Color(0xFF00BFA5), width: 2),
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              _selectedPriceOptionKey!,
                              style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600, color: const Color(0xFF00BFA5)),
                            ),
                          ),
                          Text(
                            'â‚¹' + _selectedPriceOptionValue!.toStringAsFixed(2),
                            style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.w700, color: const Color(0xFF0D47A1)),
                          ),
                        ],
                      ),
                    ),
                  ] else ...[
                    // Show choose price options if not pre-selected
                    if (personPrices.isNotEmpty)
                      Text('Choose Price - Persons', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w700, color: Colors.grey.shade800)),
                    if (personPrices.isNotEmpty)
                      ...personPrices.entries.map((e) => RadioListTile<String>(
                            dense: true,
                            value: e.key,
                            groupValue: selectedPriceKey,
                            onChanged: (v) {
                              if (isModalOpen && v != null) {
                                setSelected(e.key, e.value, setModalState);
                              }
                            },
                            title: Text(e.key, style: GoogleFonts.poppins(fontSize: 14)),
                            secondary: Text('â‚¹' + e.value.toStringAsFixed(2), style: GoogleFonts.poppins(fontWeight: FontWeight.w700)),
                          )),
                    if (bhkPrices.isNotEmpty) const SizedBox(height: 8),
                    if (bhkPrices.isNotEmpty)
                      Text('Choose Price - BHKs', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w700, color: Colors.grey.shade800)),
                    if (bhkPrices.isNotEmpty)
                      ...bhkPrices.entries.map((e) => RadioListTile<String>(
                            dense: true,
                            value: e.key,
                            groupValue: selectedPriceKey,
                            onChanged: (v) {
                              if (isModalOpen && v != null) {
                                setSelected(e.key, e.value, setModalState);
                              }
                            },
                            title: Text(e.key, style: GoogleFonts.poppins(fontSize: 14)),
                            secondary: Text('â‚¹' + e.value.toStringAsFixed(2), style: GoogleFonts.poppins(fontWeight: FontWeight.w700)),
                          )),

                    if (monthlyPrice != null && monthlyPrice > 0) const SizedBox(height: 8),
                    if (monthlyPrice != null && monthlyPrice > 0)
                      Text('Subscription', style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w700, color: Colors.grey.shade800)),
                    if (monthlyPrice != null && monthlyPrice > 0)
                      RadioListTile<String>(
                        dense: true,
                        value: 'Monthly Subscription',
                        groupValue: selectedPriceKey,
                        onChanged: (v) {
                          if (isModalOpen && v != null) {
                            setSelected('Monthly Subscription', monthlyPrice, setModalState);
                          }
                        },
                        title: Text('Monthly Subscription', style: GoogleFonts.poppins(fontSize: 14)),
                        secondary: Text('â‚¹' + monthlyPrice.toStringAsFixed(2), style: GoogleFonts.poppins(fontWeight: FontWeight.w700)),
                      ),

                    const SizedBox(height: 12),
                    if (selectedPriceKey != null)
                      Row(
                        children: [
                          Expanded(child: Text('Selected: ' + selectedPriceKey!, style: GoogleFonts.poppins(fontSize: 14, fontWeight: FontWeight.w600))),
                          Text('â‚¹' + selectedPriceValue.toStringAsFixed(2), style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w700, color: const Color(0xFF0D47A1))),
                        ],
                      ),
                  ],
                  if (showPaymentOptions && selectedPriceKey != null) ...[
                    const SizedBox(height: 16),
                    Text(
                      'Payment Method',
                      style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w700, color: Colors.grey.shade800),
                    ),
                    const SizedBox(height: 6),
                    RadioListTile<String>(
                      dense: true,
                      value: 'online',
                      groupValue: selectedPaymentMethod,
                      title: Text('Pay Online (UPI / Card)', style: GoogleFonts.poppins(fontSize: 14)),
                      subtitle: Text('Secure payment via Razorpay', style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600)),
                      onChanged: (value) {
                        if (value != null) {
                          setModalState(() => selectedPaymentMethod = value);
                        }
                      },
                    ),
                    RadioListTile<String>(
                      dense: true,
                      value: 'cod',
                      groupValue: selectedPaymentMethod,
                      title: Text('Cash on Delivery', style: GoogleFonts.poppins(fontSize: 14)),
                      subtitle: Text('â‚¹${_codConvenienceFee.toStringAsFixed(0)} convenience fee applies', style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600)),
                      onChanged: (value) {
                        if (value != null) {
                          setModalState(() => selectedPaymentMethod = value);
                        }
                      },
                    ),
                    Container(
                      width: double.infinity,
                      margin: const EdgeInsets.only(top: 8),
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: const Color(0xFFEEF7F2),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(color: const Color(0xFF00BFA5).withOpacity(0.3)),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            selectedPaymentMethod == 'cod' ? 'Payable at service' : 'Pay online now',
                            style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: const Color(0xFF0D47A1)),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            'â‚¹' + payableAmount.toStringAsFixed(2),
                            style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w700, color: const Color(0xFF0D47A1)),
                          ),
                          if (selectedPaymentMethod == 'cod')
                            Text(
                              'Includes â‚¹${_codConvenienceFee.toStringAsFixed(0)} cash handling fee',
                              style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade700),
                            ),
                        ],
                      ),
                    ),
                  ],
                  const SizedBox(height: 12),
                  SizedBox(
                    width: double.infinity,
                    height: 46,
                    child: ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: (currentPaymentProcessing || (serviceLat != null && serviceLng != null && selectedLocation != null && distanceInMeters != null && !isServiceAvailable))
                            ? Colors.grey.shade400
                            : const Color(0xFF00BFA5),
                        foregroundColor: Colors.white,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      ),
                      onPressed: (currentPaymentProcessing || (serviceLat != null && serviceLng != null && selectedLocation != null && distanceInMeters != null && !isServiceAvailable))
                          ? null
                          : () async {
                        debugPrint('ðŸ”µ [BOOKING] Confirm Booking button pressed');
                        debugPrint('ðŸ”µ [BOOKING] Payment processing: $currentPaymentProcessing');
                        debugPrint('ðŸ”µ [BOOKING] Selected price: $selectedPriceKey = â‚¹$selectedPriceValue');
                        debugPrint('ðŸ”µ [BOOKING] Preferred date: $preferredDate');
                        debugPrint('ðŸ”µ [BOOKING] Preferred time: $preferredTime');
                        debugPrint('ðŸ”µ [BOOKING] Selected location: $selectedLocation');
                        debugPrint('ðŸ”µ [BOOKING] Location text: ${locationCtrl?.text}');
                        debugPrint('ðŸ”µ [BOOKING] Contact text: ${contactCtrl?.text}');
                        debugPrint('ðŸ”µ [BOOKING] Distance: $distanceInMeters meters');
                        debugPrint('ðŸ”µ [BOOKING] Service available: $isServiceAvailable');
                        debugPrint('ðŸ”µ [BOOKING] Modal open: $isModalOpen');
                        // Lazy-select first option if nothing chosen yet
                        if (selectedPriceKey == null) {
                          debugPrint('âš ï¸ [BOOKING] No price selected, selecting first option');
                          if (allOptions.isNotEmpty) {
                            final first = allOptions.entries.first;
                            setModalState(() { selectedPriceKey = first.key; selectedPriceValue = first.value; });
                          } else {
                            final base = _fallbackBasePrice(_service!);
                            if (base != null) {
                              setModalState(() { selectedPriceKey = 'Base Price'; selectedPriceValue = base; });
                            }
                          }
                        }
                        if (selectedPriceKey == null) {
                          debugPrint('âŒ [BOOKING] Validation failed: No price selected');
                          ScaffoldMessenger.of(ctx).showSnackBar(const SnackBar(content: Text('Please choose a price option')));
                          return;
                        }
                        if (preferredDate == null || preferredTime == null) {
                          debugPrint('âŒ [BOOKING] Validation failed: Date or time missing');
                          ScaffoldMessenger.of(ctx).showSnackBar(const SnackBar(content: Text('Please select date and time')));
                          return;
                        }
                        if (locationCtrl == null || contactCtrl == null || locationCtrl!.text.trim().isEmpty || contactCtrl!.text.trim().isEmpty) {
                          debugPrint('âŒ [BOOKING] Validation failed: Location or contact missing');
                          ScaffoldMessenger.of(ctx).showSnackBar(const SnackBar(content: Text('Please enter location and phone')));
                          return;
                        }
                        debugPrint('âœ… [BOOKING] All validations passed');
                        // Check if service is available at the selected location (within 200 meters)
                        if (serviceLat != null && serviceLng != null && selectedLocation != null) {
                          // Recalculate to ensure latest distance
                          debugPrint('ðŸ”µ [BOOKING] Checking service availability at location...');
                          calculateDistanceAndAvailability(selectedLocation!);
                          if (distanceInMeters != null && !isServiceAvailable) {
                            debugPrint('âŒ [BOOKING] Service unavailable at distance: $distanceInMeters meters');
                            ScaffoldMessenger.of(ctx).showSnackBar(
                              SnackBar(
                                content: Text('Service unavailable. Distance: ${distanceInMeters!.toStringAsFixed(0)} meters. Service is only available within 200 meters.'),
                                backgroundColor: Colors.red,
                                duration: const Duration(seconds: 4),
                              ),
                            );
                            return;
                          }
                        } else if (serviceLat != null && serviceLng != null && selectedLocation == null) {
                          ScaffoldMessenger.of(ctx).showSnackBar(const SnackBar(content: Text('Please select a location to check service availability')));
                          return;
                        }
                        debugPrint('ðŸ”µ [BOOKING] Building booking payload...');
                        // Capture controller values BEFORE closing modal to avoid disposal issues
                        final capturedAddress = locationCtrl?.text.trim() ?? '';
                        final capturedPhone = contactCtrl?.text.trim() ?? '';
                        final capturedNotes = notesCtrl?.text.trim() ?? '';

                        bool otpVerified = true;
                        if (kEnableOtpVerification) {
                          // Show OTP verification dialog before proceeding with booking/payment
                          debugPrint('ðŸ”µ [BOOKING] Showing OTP verification dialog...');
                          otpVerified = await _showOTPVerificationDialog(ctx, capturedPhone);
                          
                          if (!otpVerified) {
                            debugPrint('âŒ [BOOKING] OTP verification failed or cancelled');
                            if (ctx.mounted) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                const SnackBar(
                                  content: Text('OTP verification is required to proceed with booking'),
                                  backgroundColor: Colors.orange,
                                  duration: Duration(seconds: 3),
                                ),
                              );
                            }
                            return; // Stop booking process if OTP not verified
                          }
                          
                          debugPrint('âœ… [BOOKING] OTP verified successfully, proceeding with booking...');
                        } else {
                          debugPrint('âš ï¸ [BOOKING] OTP verification temporarily disabled; auto-approving.');
                        }

                        // Check if this is a monthly subscription service
                        final mainCategory = (_service!['main_category'] ?? '').toString().toLowerCase();
                        final hasMonthlyCategory = mainCategory.contains('monthly') || mainCategory.contains('subscription');
                        
                        final hasMonthlyKey = (selectedPriceKey?.toLowerCase() ?? '').contains('monthly') || 
                                              (selectedPriceKey?.toLowerCase() ?? '').contains('subscription');
                        
                        final serviceName = (_service!['name'] ?? _service!['service_name'] ?? '').toString().toLowerCase();
                        final hasMonthlyName = serviceName.contains('monthly') || serviceName.contains('subscription');
                        
                        final isMonthlySubscription = hasMonthlyCategory || hasMonthlyKey || hasMonthlyName;
                        debugPrint('ðŸ”µ [BOOKING] Is monthly subscription: $isMonthlySubscription');
                        debugPrint('   - main_category: $mainCategory');
                        debugPrint('   - selectedPriceKey: $selectedPriceKey');
                        debugPrint('   - serviceName: $serviceName');

                        final bool requiresPaymentGateway = isMonthlySubscription || selectedPaymentMethod == 'online';
                        final String rawPaymentMethod = requiresPaymentGateway ? 'razorpay' : selectedPaymentMethod;
                        final String rawPaymentStatus = requiresPaymentGateway ? 'pending' : 'pending';
                        final String paymentMethodForPayload = _normalizePaymentMethodValue(rawPaymentMethod);
                        final String paymentStatusForPayload = _normalizePaymentStatusValue(rawPaymentStatus);
                        final payload = await _buildBookingPayload(
                          bookingDate: preferredDate!,
                          bookingTime: preferredTime!,
                          address: capturedAddress,
                          phone: capturedPhone,
                          notes: capturedNotes,
                          selectedLabel: selectedPriceKey!,
                          selectedPrice: selectedPriceValue,
                          paymentMethod: paymentMethodForPayload,
                          paymentStatus: paymentStatusForPayload,
                          additionalCharge: codFee,
                        );
                        debugPrint('âœ… [BOOKING] Booking payload built: ${payload.keys.toList()}');
                        debugPrint('âœ… [BOOKING] Payment meta -> method: $paymentMethodForPayload, status: $paymentStatusForPayload');

                        if (requiresPaymentGateway) {
                          debugPrint('ðŸ”µ [BOOKING] Initiating Razorpay payment...');
                          debugPrint('   - reason: ${isMonthlySubscription ? "monthly subscription" : "one-time online payment"}');
                          // Use Razorpay when gateway payment is required
                          isModalOpen = false;
                          debugPrint('ðŸ”µ [BOOKING] Closing modal before payment');
                          
                          // Show loading indicator before closing modal
                          if (ctx.mounted) {
                            ScaffoldMessenger.of(ctx).showSnackBar(
                              const SnackBar(
                                content: Row(
                                  children: [
                                    SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                      ),
                                    ),
                                    SizedBox(width: 12),
                                    Text('Opening payment gateway...'),
                                  ],
                                ),
                                duration: Duration(seconds: 2),
                              ),
                            );
                          }
                          
                          // Dispose controllers before closing modal to prevent disposal errors
                          try {
                            locationCtrl?.dispose();
                            contactCtrl?.dispose();
                            notesCtrl?.dispose();
                            locationCtrl = null;
                            contactCtrl = null;
                            notesCtrl = null;
                          } catch (e) {
                            debugPrint('Error disposing controllers: $e');
                          }
                          
                          // Close modal first
                          Navigator.of(ctx).pop();
                          
                          // Wait for modal to fully close and UI to be ready
                          // Use a longer delay to ensure the modal animation completes
                          await Future.delayed(const Duration(milliseconds: 800));
                          
                          // Now initiate payment directly - ensure we're on the main widget context
                          if (mounted) {
                            debugPrint('ðŸ”µ [BOOKING] Modal closed, UI ready, initiating payment...');
                            // Use a small delay to ensure context is fully ready
                            await Future.delayed(const Duration(milliseconds: 200));
                            await _initiateRazorpayPayment(selectedPriceValue, payload);
                          } else {
                            debugPrint('âŒ [BOOKING] Widget not mounted, cannot initiate payment');
                            // Try to show error if context is available
                            try {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Unable to open payment gateway. Please try again.'),
                                  backgroundColor: Colors.red,
                                  duration: Duration(seconds: 3),
                                ),
                              );
                            } catch (e) {
                              debugPrint('Error showing snackbar: $e');
                            }
                          }
                        } else {
                          // Cash on Delivery path with convenience fee
                          debugPrint('ðŸ”µ [BOOKING] Proceeding with COD booking (fee: â‚¹${codFee.toStringAsFixed(2)})');
                          final result = await _submitBooking(payload);
                          if (!mounted) return;
                          if (result['success'] == true) {
                            isModalOpen = false;
                            Navigator.of(ctx).pop();
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    'Booking confirmed! Pay â‚¹${payableAmount.toStringAsFixed(2)} in cash (incl. â‚¹${_codConvenienceFee.toStringAsFixed(0)} COD fee).',
                                    style: GoogleFonts.poppins(fontWeight: FontWeight.w500),
                                  ),
                                  backgroundColor: Colors.green,
                                  duration: const Duration(seconds: 4),
                                  behavior: SnackBarBehavior.floating,
                                ),
                              );
                            }
                          } else {
                            if (mounted) {
                              final errorMsg = result['message'] ?? 'Failed to create booking';
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(errorMsg),
                                  backgroundColor: Colors.red,
                                  duration: const Duration(seconds: 5),
                                ),
                              );
                            }
                          }
                        }
                        },
                      child: currentPaymentProcessing
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                              ),
                            )
                          : Text(
                        (serviceLat != null && serviceLng != null && selectedLocation != null && distanceInMeters != null && !isServiceAvailable)
                            ? 'Service Unavailable'
                            : 'Confirm Booking',
                        style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        });
        } catch (e, stackTrace) {
          debugPrint('âŒ [BOOKING] Error in modal builder: $e');
          debugPrint('Stack trace: $stackTrace');
          // Return a safe error widget
          return Container(
            padding: const EdgeInsets.all(24),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.error_outline, size: 48, color: Colors.red.shade300),
                const SizedBox(height: 16),
                Text(
                  'Unable to load booking form',
                  style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600),
                ),
                const SizedBox(height: 8),
                Text(
                  'Please try again later',
                  style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade600),
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => Navigator.of(ctx).pop(),
                  child: const Text('Close'),
                ),
              ],
            ),
          );
        }
      },
    ).catchError((error) {
      debugPrint('Error opening booking sheet: $error');
      isModalOpen = false;
      // Stop real-time tracking if active
      try {
        locationStreamSubscription?.cancel();
        locationStreamSubscription = null;
      } catch (e) {
        debugPrint('Error canceling location stream in catch: $e');
      }
      // Dispose controllers on error (only if not already disposed)
      try {
        if (locationCtrl != null) {
          locationCtrl?.dispose();
          locationCtrl = null;
        }
        if (contactCtrl != null) {
          contactCtrl?.dispose();
          contactCtrl = null;
        }
        if (notesCtrl != null) {
          notesCtrl?.dispose();
          notesCtrl = null;
        }
        // Don't manually dispose map controller - GoogleMap handles its own lifecycle
        // Just nullify the reference
        mapController = null;
      } catch (e) {
        debugPrint('Error disposing controllers: $e');
      }
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening booking form: ${error.toString()}'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }).whenComplete(() {
      debugPrint('ðŸ”µ [BOOKING] Modal whenComplete called');
      isModalOpen = false;
      debugPrint('ðŸ”µ [BOOKING] Modal state set to closed');
      // Stop real-time tracking if active
      try {
        debugPrint('ðŸ”µ [BOOKING] Cleaning up location stream...');
        locationStreamSubscription?.cancel();
        locationStreamSubscription = null;
        debugPrint('âœ… [BOOKING] Location stream cleaned up');
      } catch (e) {
        debugPrint('âŒ [BOOKING] Error canceling location stream: $e');
      }
      // Ensure controllers are disposed when modal closes (only if not already disposed)
      try {
        if (locationCtrl != null) {
          locationCtrl?.dispose();
          locationCtrl = null;
        }
        if (contactCtrl != null) {
          contactCtrl?.dispose();
          contactCtrl = null;
        }
        if (notesCtrl != null) {
          notesCtrl?.dispose();
          notesCtrl = null;
        }
        // Don't manually dispose map controller - GoogleMap handles its own lifecycle
        // Just nullify the reference
        mapController = null;
      } catch (e) {
        debugPrint('Error disposing controllers in whenComplete: $e');
      }
    });
    } catch (e) {
      debugPrint('âŒ [BOOKING] Exception in _openBookingSheet: $e');
      debugPrint('âŒ [BOOKING] Exception stack trace: ${StackTrace.current}');
      // Dispose controllers on exception (only if not already disposed)
      try {
        debugPrint('ðŸ”µ [BOOKING] Disposing controllers on exception...');
        if (locationCtrl != null) {
          locationCtrl?.dispose();
          locationCtrl = null;
        }
        if (contactCtrl != null) {
          contactCtrl?.dispose();
          contactCtrl = null;
        }
        if (notesCtrl != null) {
          notesCtrl?.dispose();
          notesCtrl = null;
        }
      } catch (disposeError) {
        debugPrint('Error disposing controllers in catch: $disposeError');
      }
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Unable to open booking form. Please try again.'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  Widget _formBox({required Widget child}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      decoration: BoxDecoration(color: Colors.white, borderRadius: BorderRadius.circular(10), border: Border.all(color: Colors.grey.shade300)),
      child: child,
    );
  }

  Map<String, double> _extractPersonPrices(Map svc) {
    double? p(dynamic v) {
      if (v == null) return null;
      if (v is num) return v.toDouble();
      final s = v.toString().trim();
      if (s.isEmpty) return null;
      return double.tryParse(s);
    }
    final Map<String, double> out = {};
    void add(String label, dynamic val) { final v = p(val); if (v != null && v > 0) out[label] = v; }
    add('1 person', svc['price_1_person']);
    add('2 persons', svc['price_2_persons']);
    add('1-2 persons', svc['price_1_2_persons']);
    add('2-5 persons', svc['price_2_5_persons']);
    add('5-10 persons', svc['price_5_10_persons']);
    add('10+ persons', svc['price_10_plus_persons']);
    return out;
  }

  Map<String, double> _extractBhkPrices(Map svc) {
    double? p(dynamic v) {
      if (v == null) return null;
      if (v is num) return v.toDouble();
      final s = v.toString().trim();
      if (s.isEmpty) return null;
      return double.tryParse(s);
    }
    final Map<String, double> out = {};
    void add(String label, dynamic val) { final v = p(val); if (v != null && v > 0) out[label] = v; }
    add('1 BHK', svc['price_1_bhk']);
    add('2 BHK', svc['price_2_bhk']);
    add('3 BHK', svc['price_3_bhk']);
    add('4 BHK', svc['price_4_bhk']);
    add('2 washrooms', svc['price_2_washroom']);
    add('3 washrooms', svc['price_3_washroom']);
    add('4 washrooms', svc['price_4_washroom']);
    add('4+ washrooms', svc['price_4_plus_washroom']);
    return out;
  }

  double? _extractMonthlyPrice(Map svc) {
    double? p(dynamic v) {
      if (v == null) return null;
      if (v is num) return v.toDouble();
      final s = v.toString().trim();
      if (s.isEmpty) return null;
      return double.tryParse(s);
    }
    final m = p(svc['monthly_plan_price']);
    if (m != null && m > 0) return m;
    return null;
  }

  String _fmtDate(DateTime d) {
    return '${d.day.toString().padLeft(2,'0')}/${d.month.toString().padLeft(2,'0')}/${d.year}';
  }

  double? _fallbackBasePrice(Map svc) {
    double? parse(dynamic v) {
      if (v == null) return null;
      if (v is num) return v.toDouble();
      return double.tryParse(v.toString());
    }
    final base = parse(svc['price']) ?? 0;
    final discount = parse(svc['discount_price']);
    if (discount != null && discount > 0 && discount < base) return discount;
    return base > 0 ? base : null;
  }

  Future<Map<String, dynamic>> _buildBookingPayload({
    required DateTime bookingDate,
    required TimeOfDay bookingTime,
    required String address,
    required String phone,
    required String notes,
    required String selectedLabel,
    required double selectedPrice,
    required String paymentMethod,
    required String paymentStatus,
    double additionalCharge = 0.0,
  }) async {
    final prefs = await SharedPreferences.getInstance();
    Map<String, dynamic>? user;
    try {
      final s = prefs.getString('userData');
      if (s != null) user = jsonDecode(s) as Map<String, dynamic>;
    } catch (_) {}
    final userId = user != null ? (user['id'] ?? user['user_id']) : null;

    final normalizedMethod = _normalizePaymentMethodValue(paymentMethod);
    final normalizedStatus = _normalizePaymentStatusValue(paymentStatus);

    final serviceId = _service!['id'];
    final durationRaw = (_service!['duration'] ?? '').toString();
    final durationHours = int.tryParse(RegExp(r'[0-9]+').firstMatch(durationRaw)?.group(0) ?? '') ?? 1; // Integer, default to 1 hour

    final discountAmount = 0.0; // can be computed if you apply coupons
    final extraCharge = additionalCharge < 0 ? 0.0 : additionalCharge;
    final totalAmount = selectedPrice + extraCharge;
    final finalAmount = totalAmount - discountAmount;

    String two(int n) => n.toString().padLeft(2, '0');
    final dateStr = '${bookingDate.year}-${two(bookingDate.month)}-${two(bookingDate.day)}';
    final timeStr = '${two(bookingTime.hour)}:${two(bookingTime.minute)}:00';
    // Simple time slot: start to start+duration_hours (rounded to minutes)
    String? timeSlot;
    if (durationHours > 0) {
      final start = DateTime(bookingDate.year, bookingDate.month, bookingDate.day, bookingTime.hour, bookingTime.minute);
      final end = start.add(Duration(minutes: (durationHours * 60).round()));
      timeSlot = '${two(start.hour)}:${two(start.minute)} - ${two(end.hour)}:${two(end.minute)}';
    }

    final bookingRef = 'BK' + DateTime.now().millisecondsSinceEpoch.toString();
    final nowIso = DateTime.now().toIso8601String();

    final serviceName = (_service!['name'] ?? _service!['service_name'] ?? '').toString();

    // Check if this is a monthly subscription service
    // Method 1: Check main_category field
    final mainCategory = (_service!['main_category'] ?? '').toString().toLowerCase();
    final hasMonthlyCategory = mainCategory.contains('monthly') || mainCategory.contains('subscription');
    
    // Method 2: Check selected label
    final hasMonthlyLabel = selectedLabel.toLowerCase().contains('monthly') || 
                            selectedLabel.toLowerCase().contains('subscription');
    
    // Method 3: Check service name
    final hasMonthlyName = serviceName.toLowerCase().contains('monthly') || 
                           serviceName.toLowerCase().contains('subscription');
    
    final isMonthlySubscription = hasMonthlyCategory || hasMonthlyLabel || hasMonthlyName;
    
    debugPrint('ðŸ”µ [BOOKING DETECTION] Checking monthly subscription:');
    debugPrint('   - main_category: $mainCategory (hasMonthly: $hasMonthlyCategory)');
    debugPrint('   - selectedLabel: $selectedLabel (hasMonthly: $hasMonthlyLabel)');
    debugPrint('   - serviceName: $serviceName (hasMonthly: $hasMonthlyName)');
    debugPrint('   - Final isMonthlySubscription: $isMonthlySubscription');
    
    // For monthly subscriptions, service start date should be the next day after preferred date
    // and service end date should be one month after the start date
    String? subscriptionPlanDetails;
    if (isMonthlySubscription) {
      // Calculate service start date (next day after preferred date)
      final serviceStartDate = bookingDate.add(const Duration(days: 1));
      final serviceStartDateStr = '${serviceStartDate.year}-${two(serviceStartDate.month)}-${two(serviceStartDate.day)}';
      
      // Calculate service end date (one month after start date)
      // Add 1 month to the start date
      final serviceEndDate = DateTime(
        serviceStartDate.year,
        serviceStartDate.month + 1,
        serviceStartDate.day,
      );
      final serviceEndDateStr = '${serviceEndDate.year}-${two(serviceEndDate.month)}-${two(serviceEndDate.day)}';
      
      // Get service image (use first available image from service)
      String? serviceImage;
      for (var imgKey in ['image', 'image_2', 'image_3', 'image_4']) {
        final imgValue = _service![imgKey];
        if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
          final rawUrl = imgValue.toString().trim();
          // If it's already a full URL, use it
          if (rawUrl.startsWith('https://superdailys.com/storage/services/')) {
            serviceImage = rawUrl;
            break;
          } else if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
            serviceImage = rawUrl;
            break;
          } else {
            // Extract filename and build full URL
            String filename = rawUrl.split('/').last.split('\\').last;
            filename = filename.split('?').first.split('#').first;
            if (filename.isNotEmpty && filename.contains('.')) {
              serviceImage = 'https://superdailys.com/storage/services/' + filename;
              break;
            }
          }
        }
      }
      
      // Create subscription plan details with start and end dates
      final subscriptionDetails = {
        'plan_type': 'monthly',
        'billing_cycle': 'monthly',
        'start_date': serviceStartDateStr,
        'end_date': serviceEndDateStr,
        'service_name': serviceName,
        'price': selectedPrice.toString(),
        'duration_hours': durationHours.toString(),
        'selected_price_option': selectedLabel,
        if (serviceImage != null) 'image': serviceImage,
      };
      subscriptionPlanDetails = jsonEncode(subscriptionDetails);
      debugPrint('ðŸ”µ [BOOKING] Monthly subscription - Service start date: $serviceStartDateStr, Service end date: $serviceEndDateStr (preferred date: $dateStr)');
    }

    return {
      'user_id': userId,
      'maid_id': null,
      'assigned_at': null,
      'assigned_by': null,
      'assignment_notes': null,
      'partner_id': null,
      'service_id': serviceId,
      'service_name': serviceName,
      'booking_reference': bookingRef,
      'booking_date': dateStr,
      'booking_time': timeStr,
      'time_slot': timeSlot,
      'address': address,
      'phone': phone,
      'special_instructions': notes,
      'duration_hours': durationHours,
      'total_amount': totalAmount,
      'discount_amount': discountAmount,
      'final_amount': finalAmount,
      'selected_price_option': selectedLabel, // e.g., "price_1_bhk", "price_2_persons", etc.
      'status': 'pending',
      'payment_method': normalizedMethod,
      'payment_status': normalizedStatus,
      'payment_id': null,
      'transaction_id': null,
      'gateway_response': null,
      'payment_completed_at': null,
      'payment_failed_at': null,
      'customer_notes': null,
      'maid_notes': null,
      'admin_notes': null,
      'address_details': address.isNotEmpty ? jsonEncode({'address': address}) : null,
      'service_requirements': _service!['requirements'] != null && _service!['requirements'].toString().isNotEmpty 
          ? (() {
              try {
                final reqStr = _service!['requirements'].toString();
                // Try to parse as JSON first
                final parsed = jsonDecode(reqStr);
                if (parsed is Map) {
                  return jsonEncode(parsed);
                } else {
                  return jsonEncode({'requirements': reqStr});
                }
              } catch (_) {
                // If not valid JSON, wrap it
                return jsonEncode({'requirements': _service!['requirements'].toString()});
              }
            })()
          : null,
      'subscription_plan': isMonthlySubscription ? 'monthly' : null, // Set to 'monthly' for monthly subscriptions
      'subscription_plan_details': subscriptionPlanDetails, // For monthly subscriptions, includes start_date (next day)
      'confirmed_at': null,
      'started_at': null,
      'completed_at': null,
      'allocated_at': null,
      'cancelled_at': null,
      'created_at': nowIso,
      'updated_at': nowIso,
    };
  }

  Future<bool> _showOTPVerificationDialog(BuildContext context, String initialPhone) async {
    final phoneController = TextEditingController(text: initialPhone);
    final otpController = TextEditingController();
    
    // Store state variables that need to persist across rebuilds
    String? verifiedPhone; // Store phone number after OTP is sent
    String? verificationId; // Store Firebase verification ID for SMS sending
    int? resendToken; // Store resend token for OTP
    
    // State variables that need to persist - use ValueNotifier for proper state management
    final isLoading = ValueNotifier<bool>(false);
    final isGeneratingOTP = ValueNotifier<bool>(false);
    final errorMessage = ValueNotifier<String?>(null);
    
    // For web: reCAPTCHA verifier
    // Note: In firebase_auth_web 6.x, the RecaptchaVerifier API may have changed
    // Setting to null - Firebase may handle reCAPTCHA automatically or it will be required at runtime
    dynamic recaptchaVerifier;
    if (kIsWeb) {
      // TODO: Re-implement reCAPTCHA verifier when API is confirmed for firebase_auth_web 6.x
      // For now, setting to null - phone auth on web may require reCAPTCHA configuration
      recaptchaVerifier = null;
      debugPrint('Note: reCAPTCHA verifier not initialized. Phone auth on web may require reCAPTCHA setup.');
    }
    
    return await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
          builder: (context, setState) {
            // Listen to state changes and rebuild when needed
            return ValueListenableBuilder<bool>(
              valueListenable: isLoading,
              builder: (context, loadingValue, _) {
                return ValueListenableBuilder<bool>(
                  valueListenable: isGeneratingOTP,
                  builder: (context, generatingValue, _) {
                    return ValueListenableBuilder<String?>(
                      valueListenable: errorMessage,
                      builder: (context, errorValue, _) {
                        // Local state for UI updates
                        final currentIsLoading = loadingValue;
                        final currentIsGeneratingOTP = generatingValue;
                        final currentErrorMessage = errorValue;
            
            Future<void> generateOTP() async {
              // Prevent multiple simultaneous requests
              if (isGeneratingOTP.value || isLoading.value) {
                return;
              }
              
              final phone = phoneController.text.trim();
              if (phone.isEmpty) {
                errorMessage.value = 'Please enter phone number';
                return;
              }
              
              // Format phone number with country code if not present
              String formattedPhone = phone.replaceAll(' ', '').replaceAll('-', '');
              
              if (!formattedPhone.startsWith('+')) {
                // Add +91 for India if no country code
                if (formattedPhone.length == 10) {
                  formattedPhone = '+91$formattedPhone';
                } else {
                  errorMessage.value = 'Please enter a valid 10-digit phone number';
                  isGeneratingOTP.value = false;
                  return;
                }
              }
              
              // Validate phone number format
              if (formattedPhone.length < 10 || !formattedPhone.startsWith('+')) {
                errorMessage.value = 'Please enter a valid phone number with country code (e.g., +91XXXXXXXXXX)';
                isGeneratingOTP.value = false;
                return;
              }
              
              // Set loading state immediately
              isGeneratingOTP.value = true;
              errorMessage.value = null;
              
              debugPrint('ðŸ”µ [OTP] Sending OTP via Firebase to: $formattedPhone');
              
              try {
                // Use Firebase Auth to send SMS
                // On web, reCAPTCHA may be handled automatically in firebase_auth_web 6.x
                if (kIsWeb) {
                  // Web version - recaptchaVerifier parameter removed as API changed in 6.x
                  // Firebase may handle reCAPTCHA automatically or require configuration
                  await FirebaseAuth.instance.verifyPhoneNumber(
                    phoneNumber: formattedPhone,
                    timeout: const Duration(seconds: 60),
                    forceResendingToken: resendToken,
                    verificationCompleted: (PhoneAuthCredential credential) async {
                    // Auto-verification completed (Android only)
                    if (context.mounted) {
                      isGeneratingOTP.value = false;
                      isLoading.value = true;
                      
                      try {
                        await FirebaseAuth.instance.signInWithCredential(credential);
                        // Sign out immediately after verification
                        await FirebaseAuth.instance.signOut();
                        verifiedPhone = formattedPhone.replaceAll('+', '').replaceAll(' ', '');
                        Navigator.of(dialogContext).pop(true);
                      } catch (e) {
                        isLoading.value = false;
                        errorMessage.value = 'Auto-verification failed: ${e.toString()}';
                      }
                    }
                  },
                  verificationFailed: (FirebaseAuthException e) {
                    debugPrint('âŒ [OTP] Verification failed: ${e.code} - ${e.message}');
                    if (context.mounted) {
                      isGeneratingOTP.value = false;
                      String errorMsg = 'Failed to send OTP. ';
                      if (e.code == 'invalid-phone-number') {
                        errorMsg = 'Invalid phone number format. Please enter with country code (e.g., +91XXXXXXXXXX)';
                      } else if (e.code == 'too-many-requests') {
                        errorMsg = 'Too many requests. Please try again later.';
                      } else if (e.code == 'quota-exceeded') {
                        errorMsg = 'SMS quota exceeded. Please try again later.';
                      } else if (e.code == 'invalid-app-credential') {
                        errorMsg = 'reCAPTCHA verification failed. Please try again.';
                        // Clear and recreate reCAPTCHA verifier on web
                        if (kIsWeb && recaptchaVerifier != null) {
                          try {
                            (recaptchaVerifier as dynamic).clear();
                          } catch (_) {}
                        }
                      } else {
                        errorMsg += e.message ?? 'Please check your phone number and try again.';
                      }
                      errorMessage.value = errorMsg;
                    }
                  },
                  codeSent: (String vid, int? token) {
                    debugPrint('âœ… [OTP] SMS sent! Verification ID received');
                    // Store verification ID and resend token
                    verificationId = vid;
                    resendToken = token;
                    verifiedPhone = formattedPhone.replaceAll('+', '').replaceAll(' ', '');
                    
                    if (context.mounted) {
                      isGeneratingOTP.value = false;
                      errorMessage.value = null;
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('OTP sent successfully to $formattedPhone'),
                          backgroundColor: Colors.green,
                          duration: const Duration(seconds: 3),
                        ),
                      );
                    }
                  },
                  codeAutoRetrievalTimeout: (String vid) {
                    // Auto-retrieval timeout (Android only)
                    debugPrint('â±ï¸ [OTP] Auto-retrieval timeout');
                    verificationId = vid;
                  },
                  );
                } else {
                  // Mobile version without reCAPTCHA
                  await FirebaseAuth.instance.verifyPhoneNumber(
                    phoneNumber: formattedPhone,
                    timeout: const Duration(seconds: 60),
                    forceResendingToken: resendToken,
                    verificationCompleted: (PhoneAuthCredential credential) async {
                      // Auto-verification completed (Android only)
                      if (context.mounted) {
                        isGeneratingOTP.value = false;
                        isLoading.value = true;
                        
                        try {
                          await FirebaseAuth.instance.signInWithCredential(credential);
                          // Sign out immediately after verification
                          await FirebaseAuth.instance.signOut();
                          verifiedPhone = formattedPhone.replaceAll('+', '').replaceAll(' ', '');
                          Navigator.of(dialogContext).pop(true);
                        } catch (e) {
                          isLoading.value = false;
                          errorMessage.value = 'Auto-verification failed: ${e.toString()}';
                        }
                      }
                    },
                    verificationFailed: (FirebaseAuthException e) {
                      debugPrint('âŒ [OTP] Verification failed: ${e.code} - ${e.message}');
                      if (context.mounted) {
                        isGeneratingOTP.value = false;
                        String errorMsg = 'Failed to send OTP. ';
                        if (e.code == 'invalid-phone-number') {
                          errorMsg = 'Invalid phone number format. Please enter with country code (e.g., +91XXXXXXXXXX)';
                        } else if (e.code == 'too-many-requests') {
                          errorMsg = 'Too many requests. Please try again later.';
                        } else if (e.code == 'quota-exceeded') {
                          errorMsg = 'SMS quota exceeded. Please try again later.';
                        } else if (e.code == 'invalid-app-credential') {
                          errorMsg = 'reCAPTCHA verification failed. Please try again.';
                          // Clear and recreate reCAPTCHA verifier on web
                          if (kIsWeb && recaptchaVerifier != null) {
                            try {
                              (recaptchaVerifier as dynamic).clear();
                            } catch (_) {}
                          }
                        } else {
                          errorMsg += e.message ?? 'Please check your phone number and try again.';
                        }
                        errorMessage.value = errorMsg;
                      }
                    },
                    codeSent: (String vid, int? token) {
                      debugPrint('âœ… [OTP] SMS sent! Verification ID received');
                      // Store verification ID and resend token
                      verificationId = vid;
                      resendToken = token;
                      verifiedPhone = formattedPhone.replaceAll('+', '').replaceAll(' ', '');
                      
                      if (context.mounted) {
                        isGeneratingOTP.value = false;
                        errorMessage.value = null;
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('OTP sent successfully to $formattedPhone'),
                            backgroundColor: Colors.green,
                            duration: const Duration(seconds: 3),
                          ),
                        );
                      }
                    },
                    codeAutoRetrievalTimeout: (String vid) {
                      // Auto-retrieval timeout (Android only)
                      debugPrint('â±ï¸ [OTP] Auto-retrieval timeout');
                      verificationId = vid;
                    },
                  );
                }
              } catch (e) {
                if (context.mounted) {
                  isGeneratingOTP.value = false;
                  errorMessage.value = 'Error sending OTP: ${e.toString()}';
                  debugPrint('âŒ [OTP] Error: $e');
                }
              }
            }
            
            Future<void> verifyOTP() async {
              // Prevent multiple simultaneous requests
              if (isLoading.value || isGeneratingOTP.value) {
                return;
              }
              
              final otp = otpController.text.trim();
              
              if (verificationId == null || verifiedPhone == null) {
                errorMessage.value = 'Please send OTP first';
                return;
              }
              
              if (otp.isEmpty) {
                errorMessage.value = 'Please enter OTP';
                return;
              }
              
              if (otp.length != 6) {
                errorMessage.value = 'OTP must be 6 digits';
                return;
              }
              
              isLoading.value = true;
              errorMessage.value = null;
              
              try {
                // Verify OTP using Firebase (SMS was sent via Firebase)
                final credential = PhoneAuthProvider.credential(
                  verificationId: verificationId!,
                  smsCode: otp,
                );
                
                // Sign in with credential to verify OTP
                await FirebaseAuth.instance.signInWithCredential(credential);
                
                // Sign out immediately after verification (we only use Firebase for OTP, not authentication)
                await FirebaseAuth.instance.signOut();
                
                // OTP verified successfully
                if (context.mounted) {
                  debugPrint('âœ… [OTP] OTP verified successfully');
                  Navigator.of(dialogContext).pop(true);
                }
              } on FirebaseAuthException catch (e) {
                if (context.mounted) {
                  isLoading.value = false;
                  if (e.code == 'invalid-verification-code') {
                    errorMessage.value = 'Invalid OTP. Please check and try again.';
                  } else if (e.code == 'session-expired') {
                    errorMessage.value = 'OTP session expired. Please request a new OTP.';
                  } else {
                    errorMessage.value = e.message ?? 'Failed to verify OTP';
                  }
                  debugPrint('âŒ [OTP] Verification error: ${e.code} - ${e.message}');
                }
              } catch (e) {
                if (context.mounted) {
                  isLoading.value = false;
                  errorMessage.value = 'Error verifying OTP: ${e.toString()}';
                  debugPrint('âŒ [OTP] Error: $e');
                }
              }
            }
            
            return AlertDialog(
              title: Text(
                'OTP Verification',
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
              ),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(
                      'Please verify your phone number to proceed with booking',
                      style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade700),
                    ),
                    const SizedBox(height: 20),
                    TextField(
                      controller: phoneController,
                      decoration: InputDecoration(
                        labelText: 'Phone Number',
                        hintText: 'Enter phone number',
                        prefixIcon: const Icon(Icons.phone),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                        enabled: !currentIsGeneratingOTP && !currentIsLoading,
                      ),
                      keyboardType: TextInputType.phone,
                    ),
                    // reCAPTCHA container for web
                    if (kIsWeb) ...[
                      const SizedBox(height: 12),
                      Container(
                        key: const Key('recaptcha-container'),
                        height: 78,
                        alignment: Alignment.center,
                        child: const Text(
                          'reCAPTCHA will appear here',
                          style: TextStyle(fontSize: 12, color: Colors.grey),
                        ),
                      ),
                    ],
                    const SizedBox(height: 12),
                    Row(
                      children: [
                        Expanded(
                          child: TextField(
                            controller: otpController,
                            decoration: InputDecoration(
                              labelText: 'OTP',
                              hintText: 'Enter 6-digit OTP',
                              prefixIcon: const Icon(Icons.lock),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                              ),
                              enabled: !currentIsLoading,
                            ),
                            keyboardType: TextInputType.number,
                            maxLength: 6,
                          ),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton(
                          onPressed: (currentIsGeneratingOTP || currentIsLoading) ? null : generateOTP,
                          style: ElevatedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                          ),
                          child: currentIsGeneratingOTP
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(strokeWidth: 2),
                                )
                              : const Text('Send OTP'),
                        ),
                      ],
                    ),
                    if (currentErrorMessage != null) ...[
                      const SizedBox(height: 12),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade200),
                        ),
                        child: Row(
                          children: [
                            Icon(Icons.error_outline, color: Colors.red.shade700, size: 20),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                currentErrorMessage!,
                                style: GoogleFonts.poppins(
                                  fontSize: 12,
                                  color: Colors.red.shade700,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: currentIsLoading ? null : () => Navigator.of(dialogContext).pop(false),
                  child: Text(
                    'Cancel',
                    style: GoogleFonts.poppins(),
                  ),
                ),
                ElevatedButton(
                  onPressed: currentIsLoading ? null : verifyOTP,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue,
                    foregroundColor: Colors.white,
                  ),
                  child: currentIsLoading
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        )
                      : Text(
                          'Verify & Continue',
                          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
                        ),
                ),
              ],
            );
                      },
                    );
                  },
                );
              },
            );
          },
        );
      },
    ) ?? false;
  }

  Future<Map<String, dynamic>> _submitBooking(Map<String, dynamic> payload) async {
    try {
      debugPrint('ðŸ”µ [BOOKING] Submitting booking to: ${kBackendBaseUrl}bookings_create.php');
      debugPrint('ðŸ”µ [BOOKING] Payload keys: ${payload.keys.toList()}');
      
      final uri = Uri.parse(kBackendBaseUrl + 'bookings_create.php');
      final res = await http.post(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(payload),
      ).timeout(const Duration(seconds: 30));
      
      debugPrint('ðŸ”µ [BOOKING] Response status: ${res.statusCode}');
      debugPrint('ðŸ”µ [BOOKING] Response body: ${res.body}');
      
      if (res.statusCode == 200) {
        try {
        final data = jsonDecode(res.body);
          if (data is Map) {
            if (data['success'] == true || data['status'] == 'ok') {
              debugPrint('âœ… [BOOKING] Booking created successfully with ID: ${data['id'] ?? 'N/A'}');
              return {'success': true, 'id': data['id']};
            } else {
              final errorMsg = data['message'] ?? data['error'] ?? 'Unknown error';
              debugPrint('âŒ [BOOKING] Booking create response (not success): ${jsonEncode(data)}');
              debugPrint('âŒ [BOOKING] Error message: $errorMsg');
              return {'success': false, 'message': errorMsg};
            }
          } else {
            debugPrint('âŒ [BOOKING] Invalid response format: ${res.body}');
            return {'success': false, 'message': 'Invalid response format from server'};
          }
    } catch (e) {
          debugPrint('âŒ [BOOKING] JSON decode error: $e');
          debugPrint('âŒ [BOOKING] Raw response: ${res.body}');
          return {'success': false, 'message': 'Failed to parse server response'};
        }
      } else {
        debugPrint('âŒ [BOOKING] HTTP error: ${res.statusCode}');
        debugPrint('âŒ [BOOKING] Response body: ${res.body}');
        try {
          final errorData = jsonDecode(res.body);
          final errorMsg = errorData['message'] ?? errorData['error'] ?? 'Server error (${res.statusCode})';
          return {'success': false, 'message': errorMsg};
        } catch (_) {
          return {'success': false, 'message': 'Server error (${res.statusCode})'};
        }
      }
    } catch (e) {
      debugPrint('âŒ [BOOKING] Booking create error: $e');
      debugPrint('âŒ [BOOKING] Error type: ${e.runtimeType}');
      return {'success': false, 'message': 'Network error: ${e.toString()}'};
    }
  }

  List<String> _formatBullets(String text) {
    // Normalize common escape sequences first
    String normalize(String s) {
      String n = s
          .replaceAll('\\r\\n', '\n')
          .replaceAll('\\n', '\n')
          .replaceAll('\\t', ' ')
          .replaceAll('\\u2019', "'");
      // Trim any surrounding quotes/brackets artifacts
      if (n.startsWith('"') && n.endsWith('"')) {
        n = n.substring(1, n.length - 1);
      }
      return n;
    }

    List<String> splitLoose(String s) {
      // Primary: newlines, semicolons or vertical bars
      final primary = s.split(RegExp(r'\n+|;|\|')).map((e) => e.trim()).where((e) => e.isNotEmpty).toList();
      if (primary.length > 1) return primary;
      // Fallback: split by sentence boundaries if still a single blob
      final sentences = s.split(RegExp(r'(?<=[.!?])\s+')).map((e) => e.trim()).where((e) => e.isNotEmpty).toList();
      return sentences.isEmpty ? [s.trim()] : sentences;
    }

    // Attempt to parse JSON array strings like ["a","b"]
    try {
      final dynamic decoded = jsonDecode(text);
      if (decoded is List) {
        return decoded
            .map((e) => normalize(e.toString()))
            .expand((e) => splitLoose(e))
            .map((e) => e.trim())
            .where((e) => e.isNotEmpty)
            .toList();
      } else if (decoded is String) {
        final n = normalize(decoded);
        return splitLoose(n);
      }
    } catch (_) {
      // not JSON, fall back to loose parsing
    }

    final n = normalize(text);
    return splitLoose(n);
  }

  String _resolveServiceImageUrlForDetails(String raw) {
    if (raw.isEmpty) return raw;
    String p = raw.trim();
    // Normalize slashes
    p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
    
    // Already absolute URL starting with https://superdailys.com/storage/services/
    if (p.startsWith('https://superdailys.com/storage/services/')) {
      return p;
    }
    
    // Handle URLs with superdailyapp/storage/services/ or superdailyapp/storage/products/
    if (p.contains('/superdailyapp/storage/')) {
      final filename = p.split('/').last.split('?').first.split('#').first;
      if (filename.isNotEmpty && filename.contains('.')) {
        return 'https://superdailys.com/storage/services/' + filename;
      }
    }
    
    // Handle Hostinger file server URLs - convert to regular domain (since those are failing)
    if (p.contains('srv1881-files.hstgr.io')) {
      final filename = p.split('/').last.split('?').first.split('#').first;
      if (filename.isNotEmpty && filename.contains('.')) {
        return 'https://superdailys.com/storage/services/' + filename;
      }
    }
    
    // Already absolute URL (any other URL)
    if (p.startsWith('http://') || p.startsWith('https://')) {
      return p;
    }
    
    // Extract just the filename from the path
    String filename = p.split('/').last.split('\\').last;
    // Remove query parameters and hash
    filename = filename.split('?').first.split('#').first;
    
    // If filename is empty or doesn't have extension, try to find it
    if (filename.isEmpty || !filename.contains('.')) {
      final parts = p.split('/');
      for (var part in parts.reversed) {
        if (part.contains('.') && part.length > 3) {
          filename = part.split('?').first.split('#').first;
          break;
        }
      }
    }
    
    // Build full URL - use same as monthly subscription (which works)
    if (filename.isNotEmpty && filename.contains('.')) {
      return 'https://superdailys.com/storage/services/' + filename;
    }
    
    return '';
  }

  Widget _buildImages() {
    // Collect all available service images (image, image_2, image_3, image_4)
    final List<String> serviceImages = [];
    for (var imgKey in ['image', 'image_2', 'image_3', 'image_4']) {
      final imgValue = _service![imgKey];
      if (imgValue != null && imgValue.toString().trim().isNotEmpty) {
        final resolvedUrl = _resolveServiceImageUrlForDetails(imgValue.toString());
        if (resolvedUrl.isNotEmpty && resolvedUrl.startsWith('http')) {
          serviceImages.add(resolvedUrl);
          debugPrint('ðŸ–¼ï¸ Service Details - Found image from $imgKey: $resolvedUrl');
        }
      }
    }
    
    if (serviceImages.isEmpty) {
      return Container(
        height: 220,
        decoration: BoxDecoration(color: Colors.grey.shade100, borderRadius: BorderRadius.circular(12)),
        child: const Center(child: Icon(Icons.image_not_supported, size: 64, color: Colors.grey)),
      );
    }
    
    return SizedBox(
      height: 260,
      child: Stack(
        children: [
          PageView.builder(
            controller: _imgCtrl,
            itemCount: serviceImages.length,
            onPageChanged: (i) => setState(() { _imgIndex = i; }),
            itemBuilder: (context, i) {
              final imageUrl = serviceImages[i];
              return ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: _ServiceDetailsImageWidget(
                  imageUrl: imageUrl,
                  serviceName: _service!['name']?.toString() ?? 'Service',
                ),
              );
            },
          ),
          Positioned(
            bottom: 8,
            left: 0,
            right: 0,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: List.generate(serviceImages.length, (i) {
                final active = i == _imgIndex;
                return Container(
                  width: active ? 24 : 8,
                  height: 8,
                  margin: const EdgeInsets.symmetric(horizontal: 3),
                  decoration: BoxDecoration(color: active ? Colors.white : Colors.white70, borderRadius: BorderRadius.circular(8)),
                );
              }),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPriceBlock() {
    double? parse(dynamic v) => v == null ? null : (v is num ? v.toDouble() : double.tryParse(v.toString()));
    final base = parse(_service!['price']) ?? 0;
    final discount = parse(_service!['discount_price']);
    final monthly = parse(_service!['monthly_plan_price']);
    final chosen = monthly != null && monthly > 0 ? monthly : (discount != null && discount > 0 && discount < base ? discount : base);
    
    // Hide price block if price is 0.00 (services with options only)
    if (chosen == 0 || chosen == 0.0) {
      return const SizedBox.shrink();
    }
    
    return Row(
      children: [
        Text('â‚¹' + chosen.toStringAsFixed(2), style: GoogleFonts.poppins(fontSize: 24, fontWeight: FontWeight.w700, color: const Color(0xFF0D47A1))),
        const SizedBox(width: 12),
        if (discount != null && discount < base && discount > 0)
          Text('â‚¹' + base.toStringAsFixed(2), style: GoogleFonts.poppins(decoration: TextDecoration.lineThrough, color: Colors.grey)),
      ],
    );
  }

  Widget _buildTitledBox(String title, String content) {
    return Container(
      margin: const EdgeInsets.only(top: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(color: Colors.grey.shade50, borderRadius: BorderRadius.circular(12), border: Border.all(color: Colors.grey.shade200)),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Text(title, style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w700, color: Colors.grey.shade900)),
        const SizedBox(height: 8),
        Text(content, style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade800, height: 1.5)),
      ]),
    );
  }

  Widget _buildFacts() {
    List<Widget> rows = [];
    void add(String label, dynamic value) {
      if (value == null) return;
      final s = value.toString();
      if (s.isEmpty) return;
      rows.add(_factRow(label, s));
    }
    add('Main Category', _service!['main_category']);
    add('Subcategory', _service!['subcategory']);
    add('Persons Count', _service!['persons_count']);
    add('Property Type', _service!['property_type']);
    add('Duration', _service!['duration']);
    add('Advance (hrs)', _service!['booking_advance_hours']);
    add('Category', _service!['category']);
    add('Subscription Plans', _service!['subscription_plans']);
    add('Coupon Type', _service!['coupon_type']);
    add('Coupon Discount', _service!['coupon_discount_price']);
    add('Booking Requirements', _service!['booking_requirements']);
    add('Location Id', _service!['location_id']);
    add('Unit', _service!['unit']);
    add('Latitude', _service!['service_latitude']);
    add('Longitude', _service!['service_longitude']);
    return Container(
      margin: const EdgeInsets.only(top: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(color: Colors.white, borderRadius: BorderRadius.circular(12), border: Border.all(color: Colors.grey.shade200)),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Text('Information', style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w700, color: Colors.grey.shade900)),
        const SizedBox(height: 12),
        ...rows,
      ]),
    );
  }

  Widget _factRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 10),
      child: Row(crossAxisAlignment: CrossAxisAlignment.start, children: [
        SizedBox(width: 130, child: Text(label, style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: Colors.grey.shade700))),
        Expanded(child: Text(value, style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade900))),
      ]),
    );
  }
}

class MyOrdersScreen extends StatefulWidget {
  final Map<String, dynamic> userData;
  
  const MyOrdersScreen({super.key, required this.userData});

  @override
  State<MyOrdersScreen> createState() => _MyOrdersScreenState();
}

class _MyOrdersScreenState extends State<MyOrdersScreen> {
  List<dynamic> _orders = [];
  bool _isLoading = true;
  static const Color _tealColor = Color(0xFF00BFA5);
  static const String _backendBaseUrl = 'https://superdailys.com/superdailyapp/';

  @override
  void initState() {
    super.initState();
    _fetchOrders();
  }
  
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Refresh orders when screen becomes visible to show new orders
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _fetchOrders();
    });
  }

  Future<void> _fetchOrders() async {
    setState(() {
      _isLoading = true;
    });

    try {
      final userId = widget.userData['id'] ?? widget.userData['user_id'];
      if (userId == null) {
        setState(() {
          _isLoading = false;
          _orders = [];
        });
        return;
      }

      final apiUrl = '${_backendBaseUrl}get_my_orders.php?user_id=$userId';
      
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true && data['orders'] != null) {
            setState(() {
              _orders = data['orders'];
              _isLoading = false;
            });
          } else {
            setState(() {
              _orders = [];
              _isLoading = false;
            });
          }
        } else {
          setState(() {
            _orders = [];
            _isLoading = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        debugPrint('Error fetching orders: $e');
        setState(() {
          _orders = [];
          _isLoading = false;
        });
      }
    }
  }

  String _resolveImageUrl(String raw) {
    if (raw.isEmpty) return raw;
    String p = raw.trim();
    p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
    
    if (p.startsWith('https://superdailys.com/storage/products/')) {
      return p;
    }
    
    if (p.startsWith('http://') || p.startsWith('https://')) {
      if (!p.contains('/storage/products/')) {
        final filename = p.split('/').last.split('?').first.split('#').first;
        if (filename.isNotEmpty && filename.contains('.')) {
          return 'https://superdailys.com/storage/products/' + filename;
        }
      }
      return p;
    }
    
    String filename = p.split('/').last.split('\\').last;
    filename = filename.split('?').first.split('#').first;
    
    if (filename.isEmpty || !filename.contains('.')) {
      return '';
    }
    
    return 'https://superdailys.com/storage/products/' + filename;
  }

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async {
        // Navigate back to home page
        Navigator.of(context).popUntil((route) => route.isFirst);
        return false; // Prevent default back behavior
      },
      child: Scaffold(
        backgroundColor: const Color(0xFFE0F2F1),
        appBar: AppBar(
          title: Text(
            'My Orders',
            style: GoogleFonts.poppins(
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          backgroundColor: _tealColor,
          iconTheme: const IconThemeData(color: Colors.white),
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () {
              // Navigate back to home page
              Navigator.of(context).popUntil((route) => route.isFirst);
            },
          ),
        ),
      body: _isLoading
          ? const Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            )
          : _orders.isEmpty
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.shopping_cart_outlined,
                        size: 80,
                        color: Colors.grey.shade400,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'No orders yet',
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade600,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Your product orders will appear here',
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          color: Colors.grey.shade500,
                        ),
                      ),
                    ],
                  ),
                )
              : RefreshIndicator(
                  onRefresh: _fetchOrders,
                  color: _tealColor,
                  child: ListView.builder(
                    padding: const EdgeInsets.all(16),
                    itemCount: _orders.length,
                    itemBuilder: (context, index) {
                      final order = _orders[index];
                      return _buildOrderCard(order);
                    },
                  ),
                ),
      ),
    );
  }

  Widget _buildOrderCard(Map<String, dynamic> order) {
    final product = order['product'];
    final productName = product != null ? (product['name'] ?? 'Product') : 'Product';
    final productImage = product != null ? _resolveImageUrl(product['image'] ?? '') : '';
    final quantity = order['quantity'] ?? 1;
    final pricePerUnit = order['price_per_unit'] ?? 0.0;
    final pricePerUnitValue = pricePerUnit is String 
        ? double.tryParse(pricePerUnit) ?? 0.0 
        : (pricePerUnit is num ? pricePerUnit.toDouble() : 0.0);
    final totalAmountValue = order['total_amount'] ?? 0.0;
    final totalAmount = totalAmountValue is String 
        ? double.tryParse(totalAmountValue) ?? 0.0 
        : (totalAmountValue is num ? totalAmountValue.toDouble() : 0.0);
    final paymentStatus = order['payment_status'] ?? 'pending';
    final orderStatus = order['order_status'] ?? 'pending';
    final orderDate = order['created_at'] ?? '';
    final orderNumber = order['order_number'] ?? order['id'] ?? '';
    final transactionId = order['razorpay_payment_id'] ?? order['razorpay_order_id'] ?? '';

    // Format date and time
    String formattedDate = '';
    String formattedTime = '';
    if (orderDate.isNotEmpty) {
      try {
        final date = DateTime.parse(orderDate);
        formattedDate = '${date.day}/${date.month}/${date.year}';
        // Format time in 12-hour format
        final hour = date.hour > 12 ? date.hour - 12 : (date.hour == 0 ? 12 : date.hour);
        final minute = date.minute.toString().padLeft(2, '0');
        final amPm = date.hour >= 12 ? 'PM' : 'AM';
        formattedTime = '$hour:$minute $amPm';
      } catch (e) {
        formattedDate = orderDate;
      }
    }

    return GestureDetector(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => OrderDetailScreen(order: order),
          ),
        );
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Order Header
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: _tealColor.withOpacity(0.1),
              borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (formattedDate.isNotEmpty) ...[
                      Text(
                        'Date: $formattedDate',
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade900,
                        ),
                      ),
                      if (formattedTime.isNotEmpty) ...[
                        const SizedBox(height: 4),
                        Text(
                          'Time: $formattedTime',
                          style: GoogleFonts.poppins(
                            fontSize: 12,
                            color: Colors.grey.shade600,
                          ),
                        ),
                      ],
                    ],
                  ],
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: _getStatusColor(paymentStatus).withOpacity(0.2),
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Text(
                    paymentStatus.toUpperCase(),
                    style: GoogleFonts.poppins(
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                      color: _getStatusColor(paymentStatus),
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Product Details
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Product Image
                Container(
                  width: 80,
                  height: 80,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade200,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: productImage.isNotEmpty
                      ? ClipRRect(
                          borderRadius: BorderRadius.circular(12),
                          child: CachedNetworkImage(
                            imageUrl: productImage,
                            fit: BoxFit.cover,
                            placeholder: (context, url) => const Center(
                              child: CircularProgressIndicator(strokeWidth: 2),
                            ),
                            errorWidget: (context, url, error) => Icon(
                              Icons.image_not_supported,
                              color: Colors.grey.shade400,
                            ),
                          ),
                        )
                      : Icon(
                          Icons.image_not_supported,
                          color: Colors.grey.shade400,
                        ),
                ),
                const SizedBox(width: 12),
                // Product Info
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        productName,
                        style: GoogleFonts.poppins(
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey.shade900,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          Text(
                            'Qty: ',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              color: Colors.grey.shade600,
                            ),
                          ),
                          Text(
                            quantity.toString(),
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              fontWeight: FontWeight.w600,
                              color: Colors.grey.shade900,
                            ),
                          ),
                          const SizedBox(width: 16),
                          if (pricePerUnitValue > 0) ...[
                            Text(
                              'â‚¹${pricePerUnitValue.toStringAsFixed(2)}',
                              style: GoogleFonts.poppins(
                                fontSize: 14,
                                color: Colors.grey.shade600,
                              ),
                            ),
                            Text(
                              ' Ã— ${quantity.toString()}',
                              style: GoogleFonts.poppins(
                                fontSize: 14,
                                color: Colors.grey.shade600,
                              ),
                            ),
                          ],
                        ],
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'â‚¹${totalAmount.toStringAsFixed(2)}',
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: _tealColor,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
        ),
      ),
    );
  }

  Color _getStatusColor(String status) {
    switch (status.toLowerCase()) {
      case 'paid':
      case 'completed':
      case 'delivered':
        return Colors.green;
      case 'pending':
        return Colors.orange;
      case 'failed':
      case 'cancelled':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
}

// Order Detail Screen
class OrderDetailScreen extends StatelessWidget {
  final Map<String, dynamic> order;
  static const Color _tealColor = Color(0xFF00BFA5);
  static const String _backendBaseUrl = 'https://superdailys.com/superdailyapp/';

  const OrderDetailScreen({super.key, required this.order});

  String _resolveImageUrl(String raw) {
    if (raw.isEmpty) return raw;
    String p = raw.trim();
    p = p.replaceAll('\\\\', '/').replaceAll('\\', '/');
    
    if (p.startsWith('https://superdailys.com/storage/products/')) {
      return p;
    }
    
    if (p.startsWith('http://') || p.startsWith('https://')) {
      if (!p.contains('/storage/products/')) {
        final filename = p.split('/').last.split('?').first.split('#').first;
        if (filename.isNotEmpty && filename.contains('.')) {
          return 'https://superdailys.com/storage/products/' + filename;
        }
      }
      return p;
    }
    
    String filename = p.split('/').last.split('\\').last;
    filename = filename.split('?').first.split('#').first;
    
    if (filename.isEmpty || !filename.contains('.')) {
      return '';
    }
    
    return 'https://superdailys.com/storage/products/' + filename;
  }

  Color _getStatusColor(String status) {
    switch (status.toLowerCase()) {
      case 'paid':
      case 'completed':
      case 'delivered':
        return Colors.green;
      case 'pending':
        return Colors.orange;
      case 'failed':
      case 'cancelled':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  String _formatDate(String? dateStr) {
    if (dateStr == null || dateStr.isEmpty) return 'N/A';
    try {
      final date = DateTime.parse(dateStr);
      return '${date.day}/${date.month}/${date.year} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
    } catch (e) {
      return dateStr;
    }
  }

  @override
  Widget build(BuildContext context) {
    final product = order['product'];
    final productName = product != null ? (product['name'] ?? 'Product') : 'Product';
    final productImage = product != null ? _resolveImageUrl(product['image'] ?? '') : '';
    final quantity = order['quantity'] ?? 1;
    final pricePerUnit = order['price_per_unit'] ?? 0.0;
    final pricePerUnitValue = pricePerUnit is String 
        ? double.tryParse(pricePerUnit) ?? 0.0 
        : (pricePerUnit is num ? pricePerUnit.toDouble() : 0.0);
    final totalAmountValue = order['total_amount'] ?? 0.0;
    final totalAmount = totalAmountValue is String 
        ? double.tryParse(totalAmountValue) ?? 0.0 
        : (totalAmountValue is num ? totalAmountValue.toDouble() : 0.0);
    final paymentStatus = order['payment_status'] ?? 'pending';
    final orderStatus = order['order_status'] ?? 'pending';
    final orderDate = order['created_at'] ?? '';
    final orderNumber = order['order_number'] ?? order['id'] ?? '';
    final transactionId = order['razorpay_payment_id'] ?? order['razorpay_order_id'] ?? '';
    final batchNumber = order['batch_number']?.toString() ?? '';
    final paymentMethod = order['payment_method']?.toString() ?? 'N/A';
    final paymentCompletedAt = order['payment_completed_at']?.toString() ?? '';

    return Scaffold(
      backgroundColor: const Color(0xFFE0F2F1),
      appBar: AppBar(
        title: Text(
          'Order Details',
          style: GoogleFonts.poppins(
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        backgroundColor: _tealColor,
        iconTheme: const IconThemeData(color: Colors.white),
        elevation: 0,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Order Card
            Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(16),
                boxShadow: [
                  BoxShadow(
                    color: Colors.grey.withOpacity(0.1),
                    blurRadius: 10,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Order Header
                  Container(
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: _tealColor.withOpacity(0.1),
                      borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            if (orderDate.isNotEmpty) ...[
                              Text(
                                _formatDate(orderDate),
                                style: GoogleFonts.poppins(
                                  fontSize: 14,
                                  fontWeight: FontWeight.w500,
                                  color: Colors.grey.shade700,
                                ),
                              ),
                            ],
                          ],
                        ),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                          decoration: BoxDecoration(
                            color: _getStatusColor(paymentStatus).withOpacity(0.2),
                            borderRadius: BorderRadius.circular(20),
                          ),
                          child: Text(
                            paymentStatus.toUpperCase(),
                            style: GoogleFonts.poppins(
                              fontSize: 11,
                              fontWeight: FontWeight.w600,
                              color: _getStatusColor(paymentStatus),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  // Product Details
                  Padding(
                    padding: const EdgeInsets.all(16),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Product Image
                        Container(
                          width: 100,
                          height: 100,
                          decoration: BoxDecoration(
                            color: Colors.grey.shade200,
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: productImage.isNotEmpty
                              ? ClipRRect(
                                  borderRadius: BorderRadius.circular(12),
                                  child: CachedNetworkImage(
                                    imageUrl: productImage,
                                    fit: BoxFit.cover,
                                    placeholder: (context, url) => const Center(
                                      child: CircularProgressIndicator(strokeWidth: 2),
                                    ),
                                    errorWidget: (context, url, error) => Icon(
                                      Icons.image_not_supported,
                                      color: Colors.grey.shade400,
                                    ),
                                  ),
                                )
                              : Icon(
                                  Icons.image_not_supported,
                                  color: Colors.grey.shade400,
                                ),
                        ),
                        const SizedBox(width: 16),
                        // Product Info
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                productName,
                                style: GoogleFonts.poppins(
                                  fontSize: 18,
                                  fontWeight: FontWeight.w600,
                                  color: Colors.grey.shade900,
                                ),
                              ),
                              const SizedBox(height: 12),
                              Row(
                                children: [
                                  Text(
                                    'Qty: ',
                                    style: GoogleFonts.poppins(
                                      fontSize: 14,
                                      color: Colors.grey.shade600,
                                    ),
                                  ),
                                  Text(
                                    quantity.toString(),
                                    style: GoogleFonts.poppins(
                                      fontSize: 14,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.grey.shade900,
                                    ),
                                  ),
                                  const SizedBox(width: 16),
                                  if (pricePerUnitValue > 0) ...[
                                    Text(
                                      'â‚¹${pricePerUnitValue.toStringAsFixed(2)}',
                                      style: GoogleFonts.poppins(
                                        fontSize: 14,
                                        color: Colors.grey.shade600,
                                      ),
                                    ),
                                    Text(
                                      ' Ã— ${quantity.toString()}',
                                      style: GoogleFonts.poppins(
                                        fontSize: 14,
                                        color: Colors.grey.shade600,
                                      ),
                                    ),
                                  ],
                                ],
                              ),
                              const SizedBox(height: 12),
                              Text(
                                'Total: â‚¹${totalAmount.toStringAsFixed(2)}',
                                style: GoogleFonts.poppins(
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                  color: _tealColor,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                  // Order Information Section
                  Container(
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: Colors.grey.shade50,
                      borderRadius: const BorderRadius.vertical(bottom: Radius.circular(16)),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Order Information',
                          style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: Colors.grey.shade900,
                          ),
                        ),
                        const SizedBox(height: 16),
                        // Order Status
                        if (orderStatus.isNotEmpty) ...[
                          _buildInfoRow('Order Status', orderStatus.toUpperCase(), _getStatusColor(orderStatus)),
                          const SizedBox(height: 12),
                        ],
                        // Payment Status
                        _buildInfoRow('Payment Status', paymentStatus.toUpperCase(), _getStatusColor(paymentStatus)),
                        const SizedBox(height: 12),
                        // Payment Method
                        _buildInfoRow('Payment Method', paymentMethod.toUpperCase(), Colors.grey.shade700),
                        const SizedBox(height: 12),
                        // Transaction ID
                        if (transactionId.isNotEmpty) ...[
                          _buildInfoRow('Transaction ID', transactionId, Colors.grey.shade700),
                          const SizedBox(height: 12),
                        ],
                        // Batch Number
                        if (batchNumber.isNotEmpty) ...[
                          _buildInfoRow('Batch Number', batchNumber, Colors.grey.shade700),
                          const SizedBox(height: 12),
                        ],
                        // Payment Completed At
                        if (paymentCompletedAt.isNotEmpty) ...[
                          _buildInfoRow('Payment Completed', _formatDate(paymentCompletedAt), Colors.grey.shade700),
                        ],
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value, Color valueColor) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SizedBox(
          width: 140,
          child: Text(
            label,
            style: GoogleFonts.poppins(
              fontSize: 13,
              fontWeight: FontWeight.w600,
              color: Colors.grey.shade600,
            ),
          ),
        ),
        Expanded(
          child: Text(
            value,
            style: GoogleFonts.poppins(
              fontSize: 13,
              fontWeight: FontWeight.w600,
              color: valueColor,
            ),
            textAlign: TextAlign.right,
          ),
        ),
      ],
    );
  }
}

// Favorites Screen
class FavoritesScreen extends StatefulWidget {
  final Map<String, dynamic>? userData;
  
  const FavoritesScreen({super.key, this.userData});

  @override
  State<FavoritesScreen> createState() => _FavoritesScreenState();
}

class _FavoritesScreenState extends State<FavoritesScreen> {
  List<Map<String, dynamic>> _favoriteProducts = [];
  List<Map<String, dynamic>> _favoriteServices = [];
  bool _isLoading = true;
  static const Color _tealColor = Color(0xFF00BFA5);
  static const String _backendBaseUrl = 'https://superdailys.com/superdailyapp/';

  @override
  void initState() {
    super.initState();
    _loadFavorites();
  }

  Future<void> _loadFavorites() async {
    setState(() {
      _isLoading = true;
    });

    try {
      final prefs = await SharedPreferences.getInstance();
      final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
      
      // If user is not logged in, clear favorites and return
      if (!isLoggedIn) {
        if (mounted) {
          setState(() {
            _favoriteProducts = [];
            _favoriteServices = [];
            _isLoading = false;
          });
        }
        return;
      }
      
      final favoriteProductIds = prefs.getStringList('favorite_products') ?? [];
      final favoriteServiceIds = prefs.getStringList('favorite_services') ?? [];

      // Load product details
      _favoriteProducts = [];
      for (var productId in favoriteProductIds) {
        try {
          final response = await http.get(
            Uri.parse('$_backendBaseUrl' + 'get_product_details.php?id=$productId'),
            headers: {'Content-Type': 'application/json'},
          );
          if (response.statusCode == 200) {
            final data = jsonDecode(response.body);
            if (data['success'] == true && data['product'] != null) {
              _favoriteProducts.add(data['product']);
            }
          }
        } catch (e) {
          debugPrint('Error loading favorite product $productId: $e');
        }
      }

      // Load service details
      _favoriteServices = [];
      for (var serviceId in favoriteServiceIds) {
        try {
          final response = await http.get(
            Uri.parse('$_backendBaseUrl' + 'get_service_details.php?id=$serviceId'),
            headers: {'Content-Type': 'application/json'},
          );
          if (response.statusCode == 200) {
            final data = jsonDecode(response.body);
            if (data['success'] == true && data['service'] != null) {
              _favoriteServices.add(data['service']);
            }
          }
        } catch (e) {
          debugPrint('Error loading favorite service $serviceId: $e');
        }
      }
    } catch (e) {
      debugPrint('Error loading favorites: $e');
    }

    if (mounted) {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<void> _removeFavorite(String type, String id) async {
    final prefs = await SharedPreferences.getInstance();
    if (type == 'product') {
      final favorites = prefs.getStringList('favorite_products') ?? [];
      favorites.remove(id);
      await prefs.setStringList('favorite_products', favorites);
      setState(() {
        _favoriteProducts.removeWhere((p) => p['id'].toString() == id);
      });
    } else {
      final favorites = prefs.getStringList('favorite_services') ?? [];
      favorites.remove(id);
      await prefs.setStringList('favorite_services', favorites);
      setState(() {
        _favoriteServices.removeWhere((s) => s['id'].toString() == id);
      });
    }
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Removed from favorites'),
        duration: Duration(seconds: 1),
      ),
    );
  }

  String _resolveImageUrl(String raw) {
    if (raw.isEmpty) return raw;
    String p = raw.trim().replaceAll('\\\\', '/').replaceAll('\\', '/');
    if (p.startsWith('https://superdailys.com/storage/')) return p;
    String filename = p.split('/').last.split('\\').last.split('?').first.split('#').first;
    if (filename.isNotEmpty && filename.contains('.')) {
      if (p.contains('products')) {
        return 'https://superdailys.com/storage/products/' + filename;
      } else if (p.contains('services')) {
        return 'https://superdailys.com/storage/services/' + filename;
      }
    }
    return raw;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFE0F2F1),
      appBar: AppBar(
        title: Text(
          'My Favorites',
          style: GoogleFonts.poppins(
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        backgroundColor: _tealColor,
        iconTheme: const IconThemeData(color: Colors.white),
        elevation: 0,
      ),
      body: _isLoading
          ? const Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF00BFA5)),
              ),
            )
          : (_favoriteProducts.isEmpty && _favoriteServices.isEmpty)
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.favorite_border,
                        size: 80,
                        color: Colors.grey.shade400,
                      ),
                      const SizedBox(height: 16),
                      FutureBuilder<bool>(
                        future: SharedPreferences.getInstance().then((prefs) => prefs.getBool('isLoggedIn') ?? false),
                        builder: (context, snapshot) {
                          final isLoggedIn = snapshot.data ?? false;
                          return Column(
                            children: [
                              Text(
                                isLoggedIn ? 'No favorites yet' : 'Please login to view favorites',
                                style: GoogleFonts.poppins(
                                  fontSize: 18,
                                  fontWeight: FontWeight.w600,
                                  color: Colors.grey.shade600,
                                ),
                              ),
                              const SizedBox(height: 8),
                              Text(
                                isLoggedIn 
                                  ? 'Tap the heart icon on products or services\nto add them to favorites'
                                  : 'Login to save your favorite products and services',
                                textAlign: TextAlign.center,
                                style: GoogleFonts.poppins(
                                  fontSize: 14,
                                  color: Colors.grey.shade500,
                                ),
                              ),
                            ],
                          );
                        },
                      ),
                    ],
                  ),
                )
              : RefreshIndicator(
                  onRefresh: _loadFavorites,
                  color: _tealColor,
                  child: ListView(
                    padding: const EdgeInsets.all(16),
                    children: [
                      if (_favoriteProducts.isNotEmpty) ...[
                        Text(
                          'Favorite Products',
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.grey.shade900,
                          ),
                        ),
                        const SizedBox(height: 12),
                        ..._favoriteProducts.map((product) => _buildFavoriteItem(product, 'product')),
                        const SizedBox(height: 24),
                      ],
                      if (_favoriteServices.isNotEmpty) ...[
                        Text(
                          'Favorite Services',
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.grey.shade900,
                          ),
                        ),
                        const SizedBox(height: 12),
                        ..._favoriteServices.map((service) => _buildFavoriteItem(service, 'service')),
                      ],
                    ],
                  ),
                ),
    );
  }

  Widget _buildFavoriteItem(Map<String, dynamic> item, String type) {
    final name = item['name'] ?? (type == 'product' ? 'Product' : 'Service');
    final image = type == 'product' 
        ? (item['image'] ?? item['image_2'] ?? item['image_3'] ?? item['image_4'] ?? '')
        : (item['image'] ?? item['image_2'] ?? item['image_3'] ?? item['image_4'] ?? '');
    final imageUrl = image.toString().isNotEmpty ? _resolveImageUrl(image.toString()) : '';
    final price = type == 'product'
        ? (item['selling_price'] ?? item['price'] ?? 0)
        : (item['price'] ?? 0);
    final priceNum = price is String ? double.tryParse(price) ?? 0.0 : (price is num ? price.toDouble() : 0.0);
    final id = item['id'].toString();

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ListTile(
        leading: imageUrl.isNotEmpty
            ? ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.network(
                  imageUrl,
                  width: 60,
                  height: 60,
                  fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) => Container(
                    width: 60,
                    height: 60,
                    color: Colors.grey.shade200,
                    child: Icon(Icons.image, color: Colors.grey.shade400),
                  ),
                ),
              )
            : Container(
                width: 60,
                height: 60,
                decoration: BoxDecoration(
                  color: Colors.grey.shade200,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  type == 'product' ? Icons.shopping_bag : Icons.room_service,
                  color: Colors.grey.shade400,
                ),
              ),
        title: Text(
          name,
          style: GoogleFonts.poppins(
            fontSize: 16,
            fontWeight: FontWeight.w600,
            color: Colors.grey.shade900,
          ),
        ),
        subtitle: Text(
          'â‚¹${priceNum.toStringAsFixed(2)}',
          style: GoogleFonts.poppins(
            fontSize: 14,
            fontWeight: FontWeight.w700,
            color: _tealColor,
          ),
        ),
        trailing: IconButton(
          icon: const Icon(Icons.favorite, color: Colors.red),
          onPressed: () => _removeFavorite(type, id),
        ),
        onTap: () {
          if (type == 'product') {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ProductDetailsScreen(productId: int.parse(id)),
              ),
            );
          } else {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ServiceDetailsScreen(serviceId: int.parse(id)),
              ),
            );
          }
        },
      ),
    );
  }
}

// Settings Screen
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  static const Color _tealColor = Color(0xFF00BFA5);
  bool _notificationsEnabled = true;
  bool _emailNotifications = true;
  bool _pushNotifications = true;
  String _themeMode = 'Light'; // 'Light' or 'Dark'
  
  @override
  void initState() {
    super.initState();
    _loadThemePreference();
  }
  
  Future<void> _loadThemePreference() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _themeMode = prefs.getString('theme_mode') ?? 'Light';
    });
  }
  
  Future<void> _saveThemePreference(String theme) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('theme_mode', theme);
    setState(() {
      _themeMode = theme;
    });
    // Update the global theme notifier to trigger app-wide theme change
    themeNotifier.value = theme == 'Dark' ? ThemeMode.dark : ThemeMode.light;
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        title: Text(
          'Settings',
          style: GoogleFonts.poppins(
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        backgroundColor: _tealColor,
        iconTheme: const IconThemeData(color: Colors.white),
        elevation: 0,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _buildSectionTitle('Notifications'),
          _buildSettingTile(
            'Enable Notifications',
            'Receive notifications about your orders and bookings',
            Icons.notifications,
            _notificationsEnabled,
            (value) => setState(() => _notificationsEnabled = value!),
          ),
          _buildSettingTile(
            'Email Notifications',
            'Receive updates via email',
            Icons.email,
            _emailNotifications,
            (value) => setState(() => _emailNotifications = value!),
            enabled: _notificationsEnabled,
          ),
          _buildSettingTile(
            'Push Notifications',
            'Receive push notifications on your device',
            Icons.phone_android,
            _pushNotifications,
            (value) => setState(() => _pushNotifications = value!),
            enabled: _notificationsEnabled,
          ),
          const SizedBox(height: 24),
          _buildSectionTitle('About'),
          _buildInfoTile('App Version', '1.0.0', Icons.info),
          _buildInfoTile('Build Number', '1', Icons.build),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return Padding(
      padding: const EdgeInsets.only(bottom: 12, top: 8),
      child: Text(
        title,
        style: GoogleFonts.poppins(
          fontSize: 16,
          fontWeight: FontWeight.bold,
          color: isDark ? Colors.grey.shade300 : Colors.grey.shade700,
        ),
      ),
    );
  }

  Widget _buildSettingTile(
    String title,
    String subtitle,
    IconData icon,
    bool value,
    ValueChanged<bool?> onChanged, {
    bool enabled = true,
  }) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(isDark ? 0.3 : 0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ListTile(
        leading: Icon(icon, color: enabled ? _tealColor : Colors.grey),
        title: Text(
          title,
          style: GoogleFonts.poppins(
            fontSize: 16,
            fontWeight: FontWeight.w600,
            color: enabled 
                ? (isDark ? Colors.white : Colors.grey.shade900) 
                : Colors.grey,
          ),
        ),
        subtitle: Text(
          subtitle,
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: enabled 
                ? (isDark ? Colors.grey.shade400 : Colors.grey.shade600) 
                : Colors.grey,
          ),
        ),
        trailing: Switch(
          value: value,
          onChanged: enabled ? onChanged : null,
          activeColor: _tealColor,
        ),
      ),
    );
  }

  Widget _buildActionTile(String title, String subtitle, IconData icon, VoidCallback onTap) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(isDark ? 0.3 : 0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ListTile(
        leading: Icon(icon, color: _tealColor),
        title: Text(
          title,
          style: GoogleFonts.poppins(
            fontSize: 16,
            fontWeight: FontWeight.w600,
            color: isDark ? Colors.white : Colors.grey.shade900,
          ),
        ),
        subtitle: Text(
          subtitle,
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: isDark ? Colors.grey.shade400 : Colors.grey.shade600,
          ),
        ),
        trailing: const Icon(Icons.chevron_right, color: Colors.grey),
        onTap: onTap,
      ),
    );
  }

  Widget _buildInfoTile(String title, String value, IconData icon) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(isDark ? 0.3 : 0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ListTile(
        leading: Icon(icon, color: _tealColor),
        title: Text(
          title,
          style: GoogleFonts.poppins(
            fontSize: 16,
            fontWeight: FontWeight.w600,
            color: isDark ? Colors.white : Colors.grey.shade900,
          ),
        ),
        trailing: Text(
          value,
          style: GoogleFonts.poppins(
            fontSize: 14,
            color: isDark ? Colors.grey.shade400 : Colors.grey.shade600,
          ),
        ),
      ),
    );
  }
  
  void _showThemeDialog() {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return Dialog(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20),
          ),
          backgroundColor: Theme.of(context).dialogBackgroundColor,
          child: Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(20),
              gradient: isDark
                  ? LinearGradient(
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                      colors: [
                        const Color(0xFF1E1E1E),
                        const Color(0xFF2D2D2D).withOpacity(0.8),
                      ],
                    )
                  : LinearGradient(
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                      colors: [
                        Colors.white,
                        const Color(0xFFE0F2F1).withOpacity(0.3),
                      ],
                    ),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Choose Theme',
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    fontWeight: FontWeight.bold,
                    color: isDark ? Colors.white : Colors.grey.shade900,
                  ),
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    _buildThemeOption(
                      'Day',
                      Icons.wb_sunny,
                      Colors.orange,
                      _themeMode == 'Light',
                      () {
                        _saveThemePreference('Light');
                        Navigator.of(context).pop();
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Theme changed to Day mode'),
                            backgroundColor: Color(0xFF00BFA5),
                            duration: Duration(seconds: 2),
                          ),
                        );
                      },
                    ),
                    _buildThemeOption(
                      'Night',
                      Icons.nightlight_round,
                      Colors.indigo,
                      _themeMode == 'Dark',
                      () {
                        _saveThemePreference('Dark');
                        Navigator.of(context).pop();
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Theme changed to Night mode'),
                            backgroundColor: Color(0xFF00BFA5),
                            duration: Duration(seconds: 2),
                          ),
                        );
                      },
                    ),
                  ],
                ),
                const SizedBox(height: 20),
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: Text(
                    'Cancel',
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: isDark ? Colors.grey.shade400 : Colors.grey.shade600,
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
  
  Widget _buildThemeOption(
    String title,
    IconData icon,
    Color color,
    bool isSelected,
    VoidCallback onTap,
  ) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return GestureDetector(
      onTap: onTap,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
        width: 120,
        height: 140,
        decoration: BoxDecoration(
          color: isSelected 
              ? (isDark ? color.withOpacity(0.4) : color.withOpacity(0.2))
              : (isDark ? const Color(0xFF2D2D2D) : Colors.white),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
            color: isSelected ? color : (isDark ? Colors.grey.shade700 : Colors.grey.shade300),
            width: isSelected ? 3 : 1,
          ),
          boxShadow: isSelected
              ? [
                  BoxShadow(
                    color: color.withOpacity(isDark ? 0.5 : 0.3),
                    blurRadius: 12,
                    offset: const Offset(0, 4),
                  ),
                ]
              : [
                  BoxShadow(
                    color: Colors.grey.withOpacity(isDark ? 0.3 : 0.1),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            AnimatedContainer(
              duration: const Duration(milliseconds: 300),
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: isSelected ? color : color.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(
                icon,
                size: 40,
                color: isSelected ? Colors.white : color,
              ),
            ),
            const SizedBox(height: 12),
            Text(
              title,
              style: GoogleFonts.poppins(
                fontSize: 16,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.w600,
                color: isSelected 
                    ? (isDark ? Colors.white : color)
                    : (isDark ? Colors.grey.shade300 : Colors.grey.shade700),
              ),
            ),
            if (isSelected) ...[
              const SizedBox(height: 8),
              Container(
                width: 8,
                height: 8,
                decoration: BoxDecoration(
                  color: isDark ? Colors.white : color,
                  shape: BoxShape.circle,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

// Super Wallet Screen
class SuperWalletScreen extends StatefulWidget {
  final Map<String, dynamic> userData;
  
  const SuperWalletScreen({super.key, required this.userData});

  @override
  State<SuperWalletScreen> createState() => _SuperWalletScreenState();
}

class _SuperWalletScreenState extends State<SuperWalletScreen> {
  static const Color _tealColor = Color(0xFF00BFA5);
  static const String _backendBaseUrl = 'https://superdailys.com/superdailyapp/';
  
  DateTime? _fromDate;
  DateTime? _toDate;
  double _walletBalance = 0.0;
  double _calculatedRemainingAmount = 0.0;
  bool _isLoading = false;
  bool _isCalculating = false;
  List<Map<String, dynamic>> _serviceBookings = [];

  @override
  void initState() {
    super.initState();
    _loadWalletBalance();
  }

  Future<void> _loadWalletBalance() async {
    setState(() {
      _isLoading = true;
    });

    try {
      final response = await http.get(
        Uri.parse('${_backendBaseUrl}get_wallet_balance.php?user_id=${widget.userData['id']}'),
        headers: {'Content-Type': 'application/json'},
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            setState(() {
              _walletBalance = (data['balance'] ?? 0.0).toDouble();
            });
          }
        }
      }
    } catch (e) {
      debugPrint('Error loading wallet balance: $e');
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _calculateRemainingAmount() async {
    if (_fromDate == null || _toDate == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please select both From Date and To Date'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    if (_toDate!.isBefore(_fromDate!)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('To Date must be after From Date'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    setState(() {
      _isCalculating = true;
      _calculatedRemainingAmount = 0.0;
      _serviceBookings = [];
    });

    try {
      final response = await http.post(
        Uri.parse('${_backendBaseUrl}calculate_wallet_amount.php'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'user_id': widget.userData['id'],
          'from_date': '${_fromDate!.year}-${_fromDate!.month.toString().padLeft(2, '0')}-${_fromDate!.day.toString().padLeft(2, '0')}',
          'to_date': '${_toDate!.year}-${_toDate!.month.toString().padLeft(2, '0')}-${_toDate!.day.toString().padLeft(2, '0')}',
        }),
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            setState(() {
              _calculatedRemainingAmount = (data['remaining_amount'] ?? 0.0).toDouble();
              _serviceBookings = List<Map<String, dynamic>>.from(data['bookings'] ?? []);
            });
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Failed to calculate remaining amount'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      }
    } catch (e) {
      debugPrint('Error calculating remaining amount: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isCalculating = false;
        });
      }
    }
  }

  Future<void> _addToWallet() async {
    if (_calculatedRemainingAmount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No remaining amount to add to wallet'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    if (_fromDate == null || _toDate == null) {
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final response = await http.post(
        Uri.parse('${_backendBaseUrl}add_to_wallet.php'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'user_id': widget.userData['id'],
          'amount': _calculatedRemainingAmount,
          'from_date': '${_fromDate!.year}-${_fromDate!.month.toString().padLeft(2, '0')}-${_fromDate!.day.toString().padLeft(2, '0')}',
          'to_date': '${_toDate!.year}-${_toDate!.month.toString().padLeft(2, '0')}-${_toDate!.day.toString().padLeft(2, '0')}',
        }),
      );

      if (mounted) {
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data['success'] == true) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('â‚¹${_calculatedRemainingAmount.toStringAsFixed(2)} added to wallet successfully!'),
                backgroundColor: Colors.green,
              ),
            );
            // Reload wallet balance
            await _loadWalletBalance();
            // Reset calculated amount
            setState(() {
              _calculatedRemainingAmount = 0.0;
              _serviceBookings = [];
            });
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(data['message'] ?? 'Failed to add amount to wallet'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      }
    } catch (e) {
      debugPrint('Error adding to wallet: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _selectFromDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _fromDate ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null) {
      setState(() {
        _fromDate = picked;
        // Reset calculated amount when date changes
        _calculatedRemainingAmount = 0.0;
        _serviceBookings = [];
      });
    }
  }

  Future<void> _selectToDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _toDate ?? (_fromDate ?? DateTime.now()),
      firstDate: _fromDate ?? DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null) {
      setState(() {
        _toDate = picked;
        // Reset calculated amount when date changes
        _calculatedRemainingAmount = 0.0;
        _serviceBookings = [];
      });
    }
  }

  String _formatDate(DateTime? date) {
    if (date == null) return 'Select Date';
    return '${date.day}/${date.month}/${date.year}';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFE0F2F1),
      appBar: AppBar(
        title: Text(
          'Super Wallet',
          style: GoogleFonts.poppins(
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        backgroundColor: _tealColor,
        iconTheme: const IconThemeData(color: Colors.white),
        elevation: 0,
      ),
      body: _isLoading && _walletBalance == 0.0
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Wallet Balance Card
                  Container(
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: [_tealColor, const Color(0xFF00A692)],
                      ),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Column(
                      children: [
                        Text(
                          'Wallet Balance',
                          style: GoogleFonts.poppins(
                            fontSize: 16,
                            color: Colors.white.withOpacity(0.9),
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'â‚¹${_walletBalance.toStringAsFixed(2)}',
                          style: GoogleFonts.poppins(
                            fontSize: 36,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 24),
                  
                  // Date Selection Card
                  Container(
                    padding: const EdgeInsets.all(20),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(16),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.grey.withOpacity(0.1),
                          blurRadius: 10,
                          offset: const Offset(0, 4),
                        ),
                      ],
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Select Date Range',
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.grey.shade900,
                          ),
                        ),
                        const SizedBox(height: 20),
                        // From Date
                        Row(
                          children: [
                            Expanded(
                              child: GestureDetector(
                                onTap: _selectFromDate,
                                child: Container(
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    border: Border.all(color: Colors.grey.shade300),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Row(
                                    children: [
                                      Icon(Icons.calendar_today, color: _tealColor, size: 20),
                                      const SizedBox(width: 12),
                                      Text(
                                        _formatDate(_fromDate),
                                        style: GoogleFonts.poppins(
                                          fontSize: 14,
                                          color: _fromDate == null ? Colors.grey : Colors.grey.shade900,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: GestureDetector(
                                onTap: _selectToDate,
                                child: Container(
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    border: Border.all(color: Colors.grey.shade300),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Row(
                                    children: [
                                      Icon(Icons.calendar_today, color: _tealColor, size: 20),
                                      const SizedBox(width: 12),
                                      Text(
                                        _formatDate(_toDate),
                                        style: GoogleFonts.poppins(
                                          fontSize: 14,
                                          color: _toDate == null ? Colors.grey : Colors.grey.shade900,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 20),
                        // Calculate Button
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton(
                            onPressed: _isCalculating ? null : _calculateRemainingAmount,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: _tealColor,
                              padding: const EdgeInsets.symmetric(vertical: 16),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                            ),
                            child: _isCalculating
                                ? const SizedBox(
                                    height: 20,
                                    width: 20,
                                    child: CircularProgressIndicator(
                                      strokeWidth: 2,
                                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                    ),
                                  )
                                : Text(
                                    'Calculate Remaining Amount',
                                    style: GoogleFonts.poppins(
                                      fontSize: 16,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.white,
                                    ),
                                  ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  
                  // Calculated Amount Display
                  if (_calculatedRemainingAmount > 0) ...[
                    const SizedBox(height: 20),
                    Container(
                      padding: const EdgeInsets.all(20),
                      decoration: BoxDecoration(
                        color: Colors.green.shade50,
                        borderRadius: BorderRadius.circular(16),
                        border: Border.all(color: Colors.green.shade200),
                      ),
                      child: Column(
                        children: [
                          Text(
                            'Remaining Amount',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              color: Colors.green.shade700,
                            ),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'â‚¹${_calculatedRemainingAmount.toStringAsFixed(2)}',
                            style: GoogleFonts.poppins(
                              fontSize: 28,
                              fontWeight: FontWeight.bold,
                              color: Colors.green.shade700,
                            ),
                          ),
                          const SizedBox(height: 16),
                          SizedBox(
                            width: double.infinity,
                            child: ElevatedButton(
                              onPressed: _isLoading ? null : _addToWallet,
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.green,
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(12),
                                ),
                              ),
                              child: _isLoading
                                  ? const SizedBox(
                                      height: 20,
                                      width: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                      ),
                                    )
                                  : Text(
                                      'Add to Wallet',
                                      style: GoogleFonts.poppins(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                        color: Colors.white,
                                      ),
                                    ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                  
                  // Service Bookings List
                  if (_serviceBookings.isNotEmpty) ...[
                    const SizedBox(height: 20),
                    Text(
                      'Service Bookings',
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Colors.grey.shade900,
                      ),
                    ),
                    const SizedBox(height: 12),
                    ..._serviceBookings.map((booking) => Container(
                      margin: const EdgeInsets.only(bottom: 12),
                      padding: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(12),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.grey.withOpacity(0.1),
                            blurRadius: 4,
                            offset: const Offset(0, 2),
                          ),
                        ],
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            booking['service_name'] ?? 'Service',
                            style: GoogleFonts.poppins(
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                              color: Colors.grey.shade900,
                            ),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'Amount: â‚¹${(booking['remaining_amount'] ?? 0.0).toStringAsFixed(2)}',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              color: Colors.grey.shade700,
                            ),
                          ),
                        ],
                      ),
                    )),
                  ],
                ],
              ),
            ),
    );
  }
}

// Help & Support Screen
class HelpSupportScreen extends StatelessWidget {
  const HelpSupportScreen({super.key});

  static const Color _tealColor = Color(0xFF00BFA5);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFE0F2F1),
      appBar: AppBar(
        title: Text(
          'Help & Support',
          style: GoogleFonts.poppins(
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        backgroundColor: _tealColor,
        iconTheme: const IconThemeData(color: Colors.white),
        elevation: 0,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _buildSectionCard(
            'Frequently Asked Questions',
            Icons.help_outline,
            [
              _buildFAQItem('How do I place an order?', 'Browse products, select the one you want, and proceed to payment.'),
              _buildFAQItem('How do I book a service?', 'Go to services, select a service, choose your preferred date and time, then complete the booking.'),
              _buildFAQItem('What payment methods are accepted?', 'We accept payments through Razorpay including credit/debit cards, UPI, and digital wallets.'),
              _buildFAQItem('How can I track my order?', 'Go to "My Orders" in your profile to see all your orders and their status.'),
            ],
          ),
          const SizedBox(height: 16),
          _buildSectionCard(
            'Contact Support',
            Icons.support_agent,
            [
              _buildContactItem('Email', 'support@superdailys.com', Icons.email, () {}),
              _buildContactItem('Phone', '+91 1234567890', Icons.phone, () {}),
              _buildContactItem('WhatsApp', '+91 1234567890', Icons.chat, () {}),
            ],
          ),
          const SizedBox(height: 16),
          _buildSectionCard(
            'About Super Daily',
            Icons.info,
            [
              _buildInfoItem('Super Daily is your one-stop solution for daily needs including products and services.'),
              _buildInfoItem('We provide quality products and professional services to make your life easier.'),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSectionCard(String title, IconData icon, List<Widget> children) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                Icon(icon, color: _tealColor, size: 24),
                const SizedBox(width: 12),
                Text(
                  title,
                  style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey.shade900,
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1),
          ...children,
        ],
      ),
    );
  }

  Widget _buildFAQItem(String question, String answer) {
    return ExpansionTile(
      title: Text(
        question,
        style: GoogleFonts.poppins(
          fontSize: 14,
          fontWeight: FontWeight.w600,
          color: Colors.grey.shade900,
        ),
      ),
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Text(
            answer,
            style: GoogleFonts.poppins(
              fontSize: 13,
              color: Colors.grey.shade700,
              height: 1.5,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildContactItem(String label, String value, IconData icon, VoidCallback onTap) {
    return ListTile(
      leading: Icon(icon, color: _tealColor),
      title: Text(
        label,
        style: GoogleFonts.poppins(
          fontSize: 14,
          fontWeight: FontWeight.w600,
          color: Colors.grey.shade900,
        ),
      ),
      subtitle: Text(
        value,
        style: GoogleFonts.poppins(
          fontSize: 13,
          color: Colors.grey.shade600,
        ),
      ),
      trailing: const Icon(Icons.chevron_right, color: Colors.grey),
      onTap: onTap,
    );
  }

  Widget _buildInfoItem(String text) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Text(
        text,
        style: GoogleFonts.poppins(
          fontSize: 13,
          color: Colors.grey.shade700,
          height: 1.5,
        ),
      ),
    );
  }
}

// Notifications Screen
class NotificationsScreen extends StatefulWidget {
  final int userId;
  
  const NotificationsScreen({super.key, required this.userId});

  @override
  State<NotificationsScreen> createState() => _NotificationsScreenState();
}

class _NotificationsScreenState extends State<NotificationsScreen> {
  List<dynamic> _notifications = [];
  bool _isLoading = true;
  String? _errorMessage;
  int _unreadCount = 0;
  static const Color _tealColor = Color(0xFF00BFA5);
  static const String _backendBaseUrl = 'https://superdailys.com/superdailyapp/';

  @override
  void initState() {
    super.initState();
    _fetchNotifications();
  }

  Future<void> _fetchNotifications() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      // Fetch both regular notifications and push notifications
      final regularResponse = await http.get(
        Uri.parse('${_backendBaseUrl}get_notifications.php?user_id=${widget.userId}'),
        headers: {'Content-Type': 'application/json'},
      );

      final pushResponse = await http.get(
        Uri.parse('${_backendBaseUrl}get_push_notifications.php?user_id=${widget.userId}'),
        headers: {'Content-Type': 'application/json'},
      );

      if (mounted) {
        List<dynamic> allNotifications = [];
        int unreadCount = 0;

        // Process regular notifications
        if (regularResponse.statusCode == 200) {
          final regularData = jsonDecode(regularResponse.body);
          if (regularData['success'] == true) {
            final regularNotifications = regularData['notifications'] ?? [];
            for (var notification in regularNotifications) {
              allNotifications.add({
                ...notification,
                'notification_type': 'regular',
              });
              if (!(notification['is_read'] ?? false)) {
                unreadCount++;
              }
            }
          }
        }

        // Process push notifications
        if (pushResponse.statusCode == 200) {
          final pushData = jsonDecode(pushResponse.body);
          if (pushData['success'] == true) {
            final pushNotifications = pushData['notifications'] ?? [];
            for (var notification in pushNotifications) {
              allNotifications.add({
                'id': notification['id'],
                'type': 'push',
                'title': notification['title'],
                'message': notification['body'],
                'url': notification['url'],
                'icon': notification['icon'],
                'created_at': notification['created_at'],
                'updated_at': notification['updated_at'],
                'notification_type': 'push',
                'product_id': notification['product_id'],
                'service_ids': notification['service_ids'],
                'product_ids': notification['product_ids'],
                'prize': notification['prize'],
              });
            }
          }
        }

        // Sort by created_at (newest first)
        allNotifications.sort((a, b) {
          final aDate = a['created_at'] ?? '';
          final bDate = b['created_at'] ?? '';
          return bDate.compareTo(aDate);
        });

        setState(() {
          _notifications = allNotifications;
          _unreadCount = unreadCount;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = 'Error: $e';
          _isLoading = false;
        });
      }
    }
  }

  String _formatDateTime(String? dateTimeString) {
    if (dateTimeString == null || dateTimeString.isEmpty) {
      return '';
    }
    
    try {
      final dateTime = DateTime.parse(dateTimeString);
      final now = DateTime.now();
      final difference = now.difference(dateTime);

      if (difference.inDays == 0) {
        if (difference.inHours == 0) {
          if (difference.inMinutes == 0) {
            return 'Just now';
          }
          return '${difference.inMinutes} minute${difference.inMinutes == 1 ? '' : 's'} ago';
        }
        return '${difference.inHours} hour${difference.inHours == 1 ? '' : 's'} ago';
      } else if (difference.inDays == 1) {
        return 'Yesterday';
      } else if (difference.inDays < 7) {
        return '${difference.inDays} days ago';
      } else {
        return '${dateTime.day}/${dateTime.month}/${dateTime.year}';
      }
    } catch (e) {
      return dateTimeString;
    }
  }

  IconData _getNotificationIcon(String? type) {
    switch (type?.toLowerCase()) {
      case 'order':
        return Icons.shopping_bag;
      case 'booking':
        return Icons.book_online;
      case 'payment':
        return Icons.payment;
      case 'promotion':
        return Icons.local_offer;
      default:
        return Icons.notifications;
    }
  }

  Color _getNotificationColor(String? type) {
    switch (type?.toLowerCase()) {
      case 'order':
        return Colors.blue;
      case 'booking':
        return Colors.green;
      case 'payment':
        return Colors.orange;
      case 'promotion':
        return Colors.purple;
      default:
        return _tealColor;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: _tealColor,
        foregroundColor: Colors.white,
        title: const Text('Notifications'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _fetchNotifications,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.error_outline,
                        size: 64,
                        color: Colors.grey.shade400,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        _errorMessage!,
                        style: GoogleFonts.poppins(
                          fontSize: 16,
                          color: Colors.grey.shade600,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 24),
                      ElevatedButton(
                        onPressed: _fetchNotifications,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _tealColor,
                          foregroundColor: Colors.white,
                        ),
                        child: const Text('Retry'),
                      ),
                    ],
                  ),
                )
              : _notifications.isEmpty
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.notifications_none,
                            size: 64,
                            color: Colors.grey.shade400,
                          ),
                          const SizedBox(height: 16),
                          Text(
                            'No notifications',
                            style: GoogleFonts.poppins(
                              fontSize: 18,
                              fontWeight: FontWeight.w600,
                              color: Colors.grey.shade600,
                            ),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'You\'re all caught up!',
                            style: GoogleFonts.poppins(
                              fontSize: 14,
                              color: Colors.grey.shade500,
                            ),
                          ),
                        ],
                      ),
                    )
                  : RefreshIndicator(
                      onRefresh: _fetchNotifications,
                      child: ListView.builder(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        itemCount: _notifications.length,
                        itemBuilder: (context, index) {
                          final notification = _notifications[index];
                          final isRead = notification['is_read'] ?? false;
                          final type = notification['type'];
                          final title = notification['title'] ?? 'Notification';
                          final message = notification['message'] ?? '';
                          final createdAt = notification['created_at'];

                          return Container(
                            margin: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 4,
                            ),
                            decoration: BoxDecoration(
                              color: isRead ? Colors.white : _tealColor.withOpacity(0.05),
                              borderRadius: BorderRadius.circular(12),
                              border: Border.all(
                                color: isRead
                                    ? Colors.grey.shade200
                                    : _tealColor.withOpacity(0.3),
                                width: 1,
                              ),
                            ),
                            child: ListTile(
                              contentPadding: const EdgeInsets.symmetric(
                                horizontal: 16,
                                vertical: 12,
                              ),
                              leading: Container(
                                width: 48,
                                height: 48,
                                decoration: BoxDecoration(
                                  color: _getNotificationColor(type).withOpacity(0.1),
                                  shape: BoxShape.circle,
                                ),
                                child: Icon(
                                  _getNotificationIcon(type),
                                  color: _getNotificationColor(type),
                                  size: 24,
                                ),
                              ),
                              title: Text(
                                title,
                                style: GoogleFonts.poppins(
                                  fontSize: 16,
                                  fontWeight: isRead ? FontWeight.w500 : FontWeight.w600,
                                  color: Colors.grey.shade900,
                                ),
                              ),
                              subtitle: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  const SizedBox(height: 4),
                                  Text(
                                    message,
                                    style: GoogleFonts.poppins(
                                      fontSize: 14,
                                      color: Colors.grey.shade600,
                                      height: 1.4,
                                    ),
                                    maxLines: 2,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  const SizedBox(height: 8),
                                  Text(
                                    _formatDateTime(createdAt),
                                    style: GoogleFonts.poppins(
                                      fontSize: 12,
                                      color: Colors.grey.shade500,
                                    ),
                                  ),
                                ],
                              ),
                              trailing: !isRead
                                  ? Container(
                                      width: 8,
                                      height: 8,
                                      decoration: const BoxDecoration(
                                        color: _tealColor,
                                        shape: BoxShape.circle,
                                      ),
                                    )
                                  : null,
                              onTap: () {
                                // Handle notification tap - can navigate to related content
                                if (notification['url'] != null &&
                                    notification['url'].toString().isNotEmpty) {
                                  // Handle URL navigation if needed
                                }
                              },
                            ),
                          );
                        },
        ),
      ),
    );
  }
}

// Shopping Cart Page
class ShoppingCartPage extends StatefulWidget {
  final List<Map<String, dynamic>> cartItems;
  final Function(int productId, int newQuantity) onUpdateQuantity;
  final Function(int productId) onRemoveItem;
  final VoidCallback onClearCart;
  final VoidCallback onCartUpdated;

  const ShoppingCartPage({
    super.key,
    required this.cartItems,
    required this.onUpdateQuantity,
    required this.onRemoveItem,
    required this.onClearCart,
    required this.onCartUpdated,
  });

  @override
  State<ShoppingCartPage> createState() => _ShoppingCartPageState();
}

class _ShoppingCartPageState extends State<ShoppingCartPage> {
  static const Color _tealColor = Color(0xFF00BFA5);
  static const Color _tealLight = Color(0xFFE0F2F1);
  Razorpay? _razorpay;
  bool _isProcessingPayment = false;
  List<Map<String, dynamic>> _localCartItems = [];

  @override
  void initState() {
    super.initState();
    // Initialize local cart items from widget
    _localCartItems = List.from(widget.cartItems);
    // Initialize Razorpay only for mobile platforms (Android/iOS)
    if (!kIsWeb) {
      _razorpay = Razorpay();
      _razorpay!.on(Razorpay.EVENT_PAYMENT_SUCCESS, _handlePaymentSuccess);
      _razorpay!.on(Razorpay.EVENT_PAYMENT_ERROR, _handlePaymentError);
      _razorpay!.on(Razorpay.EVENT_EXTERNAL_WALLET, _handleExternalWallet);
    }
  }

  @override
  void didUpdateWidget(ShoppingCartPage oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Update local cart items when widget updates
    if (widget.cartItems != oldWidget.cartItems) {
      _localCartItems = List.from(widget.cartItems);
    }
  }

  @override
  void dispose() {
    if (!kIsWeb && _razorpay != null) {
      _razorpay!.clear();
    }
    super.dispose();
  }

  void _handlePaymentSuccess(PaymentSuccessResponse response) async {
    if (mounted) {
      setState(() {
        _isProcessingPayment = false;
      });
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Payment successful! Order ID: ${response.paymentId}'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 3),
        ),
      );

      // Create order payload
      final prefs = await SharedPreferences.getInstance();
      final userDataJson = prefs.getString('userData');
      Map<String, dynamic>? userData;
      if (userDataJson != null) {
        userData = jsonDecode(userDataJson);
      }

      if (userData != null) {
        // Prepare order items
        List<Map<String, dynamic>> orderItems = [];
        for (var item in _localCartItems) {
          final product = item['product'];
          final quantity = item['quantity'] ?? 1;
          orderItems.add({
            'product_id': _normalizeProductId(product['id']),
            'quantity': quantity,
            'price': product['selling_price'] ?? product['price'] ?? 0.0,
          });
        }

        // Create order
        try {
          final orderResponse = await http.post(
            Uri.parse('${_getBackendBaseUrl()}orders_create.php'),
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode({
              'user_id': userData['id'],
              'items': orderItems,
              'total_amount': _getCartTotal(),
              'payment_id': response.paymentId,
              'payment_method': 'razorpay',
            }),
          );

          if (orderResponse.statusCode == 200) {
            final orderData = jsonDecode(orderResponse.body);
            if (orderData['success'] == true) {
              // Clear cart after successful order
              widget.onClearCart();
              widget.onCartUpdated();
              
              // Navigate back to home
              Navigator.pop(context);
              
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(orderData['message'] ?? 'Order placed successfully! Stock updated.'),
                  backgroundColor: Colors.green,
                  duration: const Duration(seconds: 3),
                ),
              );
            } else {
              // Show error message from backend
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(orderData['message'] ?? 'Order creation failed. Please try again.'),
                  backgroundColor: Colors.orange,
                  duration: const Duration(seconds: 4),
                ),
              );
            }
          } else {
            // Try to parse error message from response body
            String errorMessage = 'Failed to create order. Please try again.';
            try {
              final errorData = jsonDecode(orderResponse.body);
              if (errorData is Map) {
                errorMessage = errorData['error'] ?? errorData['message'] ?? errorMessage;
                debugPrint('Order creation error (status ${orderResponse.statusCode}): ${errorData['error'] ?? errorData['message']}');
              }
            } catch (e) {
              debugPrint('Could not parse error response: $e');
              debugPrint('Response body: ${orderResponse.body}');
            }
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(errorMessage),
                backgroundColor: Colors.red,
                duration: const Duration(seconds: 5),
              ),
            );
          }
        } catch (e) {
          debugPrint('Error creating order: $e');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error creating order: $e'),
              backgroundColor: Colors.red,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      }
    }
  }

  void _handlePaymentError(PaymentFailureResponse response) {
    if (mounted) {
      setState(() {
        _isProcessingPayment = false;
      });
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Payment failed: ${response.message ?? 'Unknown error'}'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  void _handleExternalWallet(ExternalWalletResponse response) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('External wallet selected: ${response.walletName}'),
          backgroundColor: Colors.blue,
          duration: const Duration(seconds: 2),
        ),
      );
    }
  }

  Future<void> _initiatePayment() async {
    if (_isProcessingPayment) return;
    
    // Show immediate feedback
    setState(() {
      _isProcessingPayment = true;
    });
    
    // Check if user is logged in (non-blocking)
    final prefs = await SharedPreferences.getInstance();
    final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
    if (!isLoggedIn) {
      setState(() {
        _isProcessingPayment = false;
      });
      // Store flag to return to cart page after login
      await prefs.setBool('pendingCartCheckout', true);
      // Store cart items so we can restore them after login
      await prefs.setString('pendingCartItems', jsonEncode(_localCartItems));
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please login to proceed with payment'),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 2),
        ),
      );
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const LoginPage()),
      );
      return;
    }
    
    final totalAmount = _getCartTotal();
    if (totalAmount <= 0) {
      setState(() {
        _isProcessingPayment = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Cart total must be greater than zero'),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 2),
        ),
      );
      return;
    }

    // Get user data
    final userDataJson = prefs.getString('userData');
    Map<String, dynamic>? userData;
    if (userDataJson != null) {
      userData = jsonDecode(userDataJson);
    }

    // Prepare product names for description
    final productNames = _localCartItems
        .map((item) => item['product']['name'] ?? 'Product')
        .take(3)
        .join(', ');
    final itemCount = _localCartItems.length;
    final description = itemCount > 3
        ? 'Order: $productNames and ${itemCount - 3} more items'
        : 'Order: $productNames';

    final options = {
      'key': kRazorpayKeyId,
      'amount': (totalAmount * 100).toInt(), // Amount in paise
      'name': 'Super Daily',
      'description': description,
      'prefill': {
        'contact': userData?['phone'] ?? '',
        'email': userData?['email'] ?? '',
      },
      'external': {
        'wallets': ['paytm']
      },
    };

    if (kIsWeb) {
      // For web, show payment dialog
      await _initiateRazorpayWeb(options, totalAmount);
    } else {
      // Use Razorpay Flutter SDK for mobile
      if (_razorpay != null) {
        try {
          _razorpay!.open(options);
        } catch (e) {
          setState(() {
            _isProcessingPayment = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error opening payment gateway: $e'),
              backgroundColor: Colors.red,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      } else {
        setState(() {
          _isProcessingPayment = false;
        });
      }
    }
  }

  Future<void> _initiateRazorpayWeb(Map<String, dynamic> options, double amount) async {
    if (mounted) {
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('Payment', style: GoogleFonts.poppins()),
          content: Text(
            'Amount: â‚¹${amount.toStringAsFixed(2)}\n\nThis is a demo. In production, integrate Razorpay web SDK.',
            style: GoogleFonts.poppins(),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text('Cancel', style: GoogleFonts.poppins()),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text('Pay', style: GoogleFonts.poppins()),
            ),
          ],
        ),
      );

      if (confirm == true) {
        // Simulate payment success for web
        _handlePaymentSuccessWeb();
      } else {
        setState(() {
          _isProcessingPayment = false;
        });
      }
    }
  }

  void _handlePaymentSuccessWeb() async {
    if (mounted) {
      setState(() {
        _isProcessingPayment = false;
      });
      
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Payment successful! (Demo mode)'),
          backgroundColor: Colors.green,
          duration: Duration(seconds: 3),
        ),
      );

      // Create order payload
      final prefs = await SharedPreferences.getInstance();
      final userDataJson = prefs.getString('userData');
      Map<String, dynamic>? userData;
      if (userDataJson != null) {
        userData = jsonDecode(userDataJson);
      }

      if (userData != null) {
        // Prepare order items
        List<Map<String, dynamic>> orderItems = [];
        for (var item in _localCartItems) {
          final product = item['product'];
          final quantity = item['quantity'] ?? 1;
          orderItems.add({
            'product_id': _normalizeProductId(product['id']),
            'quantity': quantity,
            'price': product['selling_price'] ?? product['price'] ?? 0.0,
          });
        }

        // Create order
        try {
          final orderResponse = await http.post(
            Uri.parse('${_getBackendBaseUrl()}orders_create.php'),
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode({
              'user_id': userData['id'],
              'items': orderItems,
              'total_amount': _getCartTotal(),
              'payment_id': 'web_demo_${DateTime.now().millisecondsSinceEpoch}',
              'payment_method': 'razorpay_web',
            }),
          );

          if (orderResponse.statusCode == 200) {
            final orderData = jsonDecode(orderResponse.body);
            if (orderData['success'] == true) {
              // Clear cart after successful order
              widget.onClearCart();
              widget.onCartUpdated();
              
              // Navigate back to home
              Navigator.pop(context);
              
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(orderData['message'] ?? 'Order placed successfully! Stock updated.'),
                  backgroundColor: Colors.green,
                  duration: const Duration(seconds: 3),
                ),
              );
            } else {
              // Show error message from backend
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(orderData['message'] ?? 'Order creation failed. Please try again.'),
                  backgroundColor: Colors.orange,
                  duration: const Duration(seconds: 4),
                ),
              );
            }
          } else {
            // Try to parse error message from response body
            String errorMessage = 'Failed to create order. Please try again.';
            try {
              final errorData = jsonDecode(orderResponse.body);
              if (errorData is Map) {
                errorMessage = errorData['error'] ?? errorData['message'] ?? errorMessage;
                debugPrint('Order creation error (status ${orderResponse.statusCode}): ${errorData['error'] ?? errorData['message']}');
              }
            } catch (e) {
              debugPrint('Could not parse error response: $e');
              debugPrint('Response body: ${orderResponse.body}');
            }
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(errorMessage),
                backgroundColor: Colors.red,
                duration: const Duration(seconds: 5),
              ),
            );
          }
        } catch (e) {
          debugPrint('Error creating order: $e');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error creating order: $e'),
              backgroundColor: Colors.red,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      }
    }
  }

  // Helper to normalize product ID to int for comparison
  int _normalizeProductId(dynamic id) {
    if (id == null) return 0;
    if (id is int) return id;
    if (id is String) {
      final parsed = int.tryParse(id);
      return parsed ?? 0;
    }
    if (id is num) return id.toInt();
    return 0;
  }

  double _getCartTotal() {
    double total = 0.0;
    for (var item in _localCartItems) {
      final product = item['product'];
      final quantity = item['quantity'] ?? 1;
      final sellingPrice = product['selling_price'] ?? product['price'] ?? 0.0;
      final price = _parseNumber(sellingPrice, 0.0);
      total += price * quantity;
    }
    return total;
  }

  double _parseNumber(dynamic value, [double defaultValue = 0.0]) {
    if (value == null) return defaultValue;
    if (value is double) return value.isNaN || value.isInfinite ? defaultValue : value;
    if (value is int) return value.toDouble();
    if (value is String) {
      final parsed = double.tryParse(value.trim());
      if (parsed != null && !parsed.isNaN && !parsed.isInfinite) return parsed;
    }
    return defaultValue;
  }

  int _parseInteger(dynamic value, [int defaultValue = 0]) {
    if (value == null) return defaultValue;
    if (value is int) return value;
    if (value is double) return value.toInt();
    if (value is String) {
      final parsed = int.tryParse(value.trim());
      if (parsed != null) return parsed;
    }
    return defaultValue;
  }

  String _getCategoryName(Map<String, dynamic> product) {
    return product['category_name'] ?? 'Category';
  }

  String _getUnit(Map<String, dynamic> product) {
    return product['unit']?.toString() ?? 'piece';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey.shade50,
      appBar: AppBar(
        backgroundColor: _tealColor,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () {
            widget.onCartUpdated();
            Navigator.pop(context);
          },
        ),
        title: Row(
          children: [
            const Icon(Icons.shopping_cart, color: Colors.white),
            const SizedBox(width: 8),
            Text(
              'Shopping Cart',
              style: GoogleFonts.poppins(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
          ],
        ),
      ),
      body: _localCartItems.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.shopping_cart_outlined,
                    size: 80,
                    color: Colors.grey.shade400,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Your cart is empty',
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                      color: Colors.grey.shade600,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Add some products to get started',
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      color: Colors.grey.shade500,
                    ),
                  ),
                ],
              ),
            )
          : Column(
              children: [
                // Breadcrumb
                Container(
                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                  child: Row(
                    children: [
                      Text(
                        'Home / Shopping Cart',
                        style: GoogleFonts.poppins(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                  ),
                ),
                // Main Content - Two Column Layout
                Expanded(
                  child: LayoutBuilder(
                    builder: (context, constraints) {
                      // Use two columns on larger screens, single column on smaller screens
                      final isWideScreen = constraints.maxWidth > 800;
                      if (isWideScreen) {
                        return Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // Left Column - Product List (70%)
                            Expanded(
                              flex: 7,
                              child: ListView.builder(
                          padding: const EdgeInsets.all(16),
                          itemCount: _localCartItems.length + 1, // +1 for buttons
                          itemBuilder: (context, index) {
                            // Show buttons at the end
                            if (index == _localCartItems.length) {
                              return Column(
                                children: [
                                  const SizedBox(height: 16),
                                  SizedBox(
                                    width: double.infinity,
                                    child: ElevatedButton.icon(
                                      onPressed: () {
                                        showDialog(
                                          context: context,
                                          builder: (context) => AlertDialog(
                                            title: Text(
                                              'Clear Cart',
                                              style: GoogleFonts.poppins(
                                                fontWeight: FontWeight.bold,
                                              ),
                                            ),
                                            content: Text(
                                              'Are you sure you want to remove all items from your cart?',
                                              style: GoogleFonts.poppins(),
                                            ),
                                            actions: [
                                              TextButton(
                                                onPressed: () => Navigator.pop(context),
                                                child: Text(
                                                  'Cancel',
                                                  style: GoogleFonts.poppins(),
                                                ),
                                              ),
                                              ElevatedButton(
                                                onPressed: () {
                                                  widget.onClearCart();
                                                  widget.onCartUpdated();
                                                  Navigator.pop(context);
                                                },
                                                style: ElevatedButton.styleFrom(
                                                  backgroundColor: Colors.red,
                                                ),
                                                child: Text(
                                                  'Clear',
                                                  style: GoogleFonts.poppins(
                                                    color: Colors.white,
                                                  ),
                                                ),
                                              ),
                                            ],
                                          ),
                                        );
                                      },
                                      icon: const Icon(Icons.delete_outline),
                                      label: Text(
                                        'Clear Cart',
                                        style: GoogleFonts.poppins(
                                          fontWeight: FontWeight.w600,
                                        ),
                                      ),
                                      style: ElevatedButton.styleFrom(
                                        backgroundColor: Colors.red,
                                        foregroundColor: Colors.white,
                                        padding: const EdgeInsets.symmetric(vertical: 12),
                                        shape: RoundedRectangleBorder(
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                      ),
                                    ),
                                  ),
                                  const SizedBox(height: 12),
                                  SizedBox(
                                    width: double.infinity,
                                    child: OutlinedButton.icon(
                                      onPressed: () {
                                        widget.onCartUpdated();
                                        Navigator.pop(context);
                                      },
                                      icon: const Icon(Icons.arrow_back),
                                      label: Text(
                                        'â† Continue Shopping',
                                        style: GoogleFonts.poppins(
                                          fontWeight: FontWeight.w600,
                                        ),
                                      ),
                                      style: OutlinedButton.styleFrom(
                                        foregroundColor: Colors.blue,
                                        side: const BorderSide(color: Colors.blue),
                                        padding: const EdgeInsets.symmetric(vertical: 12),
                                        shape: RoundedRectangleBorder(
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              );
                            }
                            
                            final item = _localCartItems[index];
                            final product = item['product'];
                      final quantity = _parseInteger(item['quantity'], 1);
                      final productId = product['id'];
                      final productName = product['name'] ?? 'Product';
                      final categoryName = _getCategoryName(product);
                      final unit = _getUnit(product);
                      final sellingPrice = product['selling_price'] ?? product['price'] ?? 0.0;
                      final price = _parseNumber(sellingPrice, 0.0);
                      final stockQuantity = _parseInteger(product['stock_quantity'] ?? 0);
                      final batch = product['batch']?.toString();
                      final itemTotal = price * quantity;

                      final productImage = product['image']?.toString() ?? '';
                      final imageUrl = productImage.isNotEmpty && productImage.startsWith('http')
                          ? productImage
                          : 'https://superdailys.com/storage/products/${productImage.split('/').last}';

                      return Container(
                        margin: const EdgeInsets.only(bottom: 16),
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(12),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.1),
                              blurRadius: 10,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: Padding(
                          padding: const EdgeInsets.all(12),
                          child: Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Container(
                                width: 80,
                                height: 80,
                                decoration: BoxDecoration(
                                  color: _tealLight,
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(8),
                                  child: productImage.isNotEmpty
                                      ? Image.network(
                                          imageUrl,
                                          fit: BoxFit.cover,
                                          errorBuilder: (context, error, stackTrace) {
                                            return Icon(
                                              Icons.inventory_2,
                                              color: _tealColor,
                                              size: 32,
                                            );
                                          },
                                        )
                                      : Icon(
                                          Icons.inventory_2,
                                          color: _tealColor,
                                          size: 32,
                                        ),
                                ),
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      productName,
                                      style: GoogleFonts.poppins(
                                        fontSize: 14,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.grey.shade900,
                                      ),
                                      maxLines: 2,
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      categoryName,
                                      style: GoogleFonts.poppins(
                                        fontSize: 11,
                                        color: _tealColor,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      'â‚¹${price.toStringAsFixed(2)} per $unit',
                                      style: GoogleFonts.poppins(
                                        fontSize: 12,
                                        color: Colors.grey.shade700,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Row(
                                      children: [
                                        GestureDetector(
                                          behavior: HitTestBehavior.opaque,
                                          onTap: () {
                                            final normalizedProductId = _normalizeProductId(productId);
                                            if (quantity > 1) {
                                              // Update local cart immediately
                                              final itemIndex = _localCartItems.indexWhere(
                                                (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                              );
                                              if (itemIndex != -1) {
                                                setState(() {
                                                  // Create a new map to ensure state change is detected
                                                  final updatedItem = Map<String, dynamic>.from(_localCartItems[itemIndex]);
                                                  updatedItem['quantity'] = quantity - 1;
                                                  _localCartItems[itemIndex] = updatedItem;
                                                });
                                                widget.onUpdateQuantity(normalizedProductId, quantity - 1);
                                              }
                                            } else {
                                              // Remove from local cart immediately
                                              setState(() {
                                                _localCartItems.removeWhere(
                                                  (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                                );
                                              });
                                              widget.onRemoveItem(normalizedProductId);
                                            }
                                            widget.onCartUpdated();
                                          },
                                          child: Container(
                                            width: 28,
                                            height: 28,
                                            decoration: BoxDecoration(
                                              color: _tealColor,
                                              borderRadius: BorderRadius.circular(6),
                                            ),
                                            child: const Icon(
                                              Icons.remove,
                                              color: Colors.white,
                                              size: 16,
                                            ),
                                          ),
                                        ),
                                        const SizedBox(width: 12),
                                        Text(
                                          '$quantity',
                                          style: GoogleFonts.poppins(
                                            fontSize: 16,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.grey.shade900,
                                          ),
                                        ),
                                        const SizedBox(width: 12),
                                        GestureDetector(
                                          behavior: HitTestBehavior.opaque,
                                          onTap: () {
                                            final normalizedProductId = _normalizeProductId(productId);
                                            if (quantity < stockQuantity) {
                                              // Update local cart immediately
                                              final itemIndex = _localCartItems.indexWhere(
                                                (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                              );
                                              if (itemIndex != -1) {
                                                setState(() {
                                                  // Create a new map to ensure state change is detected
                                                  final updatedItem = Map<String, dynamic>.from(_localCartItems[itemIndex]);
                                                  updatedItem['quantity'] = quantity + 1;
                                                  _localCartItems[itemIndex] = updatedItem;
                                                });
                                                widget.onUpdateQuantity(normalizedProductId, quantity + 1);
                                                widget.onCartUpdated();
                                              }
                                            } else {
                                              ScaffoldMessenger.of(context).showSnackBar(
                                                const SnackBar(
                                                  content: Text('Cannot add more. Stock limit reached.'),
                                                  backgroundColor: Colors.orange,
                                                  duration: Duration(seconds: 2),
                                                ),
                                              );
                                            }
                                          },
                                          child: Container(
                                            width: 28,
                                            height: 28,
                                            decoration: BoxDecoration(
                                              color: _tealColor,
                                              borderRadius: BorderRadius.circular(6),
                                            ),
                                            child: const Icon(
                                              Icons.add,
                                              color: Colors.white,
                                              size: 16,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      'Available: $stockQuantity $unit',
                                      style: GoogleFonts.poppins(
                                        fontSize: 10,
                                        color: Colors.grey.shade600,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          'â‚¹${itemTotal.toStringAsFixed(2)}',
                                          style: GoogleFonts.poppins(
                                            fontSize: 14,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.grey.shade900,
                                          ),
                                        ),
                                        GestureDetector(
                                          behavior: HitTestBehavior.opaque,
                                          onTap: () {
                                            final normalizedProductId = _normalizeProductId(productId);
                                            setState(() {
                                              // Remove from local cart immediately
                                              _localCartItems.removeWhere(
                                                (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                              );
                                            });
                                            widget.onRemoveItem(normalizedProductId);
                                            widget.onCartUpdated();
                                          },
                                          child: Container(
                                            padding: const EdgeInsets.symmetric(
                                              horizontal: 12,
                                              vertical: 6,
                                            ),
                                            decoration: BoxDecoration(
                                              color: Colors.red.shade50,
                                              borderRadius: BorderRadius.circular(6),
                                            ),
                                            child: Row(
                                              mainAxisSize: MainAxisSize.min,
                                              children: [
                                                Icon(
                                                  Icons.delete_outline,
                                                  color: Colors.red.shade700,
                                                  size: 16,
                                                ),
                                                const SizedBox(width: 4),
                                                Text(
                                                  'Remove',
                                                  style: GoogleFonts.poppins(
                                                    fontSize: 12,
                                                    fontWeight: FontWeight.w600,
                                                    color: Colors.red.shade700,
                                                  ),
                                                ),
                                              ],
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      );
                          },
                        ),
                      ),
                      // Right Column - Order Summary (30%)
                      Expanded(
                        flex: 3,
                        child: Container(
                          margin: const EdgeInsets.all(16),
                          padding: const EdgeInsets.all(0),
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(12),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.1),
                                blurRadius: 10,
                                offset: const Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Order Summary Header
                              Container(
                                padding: const EdgeInsets.all(16),
                                decoration: BoxDecoration(
                                  color: Colors.blue.shade50,
                                  borderRadius: const BorderRadius.only(
                                    topLeft: Radius.circular(12),
                                    topRight: Radius.circular(12),
                                  ),
                                ),
                                child: Row(
                                  children: [
                                    const Icon(
                                      Icons.list_alt,
                                      color: Colors.blue,
                                      size: 20,
                                    ),
                                    const SizedBox(width: 8),
                                    Text(
                                      'Order Summary',
                                      style: GoogleFonts.poppins(
                                        fontSize: 16,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.blue.shade900,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              // Order Summary Content
                              Padding(
                                padding: const EdgeInsets.all(16),
                                child: Column(
                                  children: [
                                    Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          'Subtotal:',
                                          style: GoogleFonts.poppins(
                                            fontSize: 14,
                                            color: Colors.grey.shade700,
                                          ),
                                        ),
                                        Text(
                                          'â‚¹${_getCartTotal().toStringAsFixed(2)}',
                                          style: GoogleFonts.poppins(
                                            fontSize: 14,
                                            color: Colors.grey.shade700,
                                          ),
                                        ),
                                      ],
                                    ),
                                    const SizedBox(height: 8),
                                    Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          'Total:',
                                          style: GoogleFonts.poppins(
                                            fontSize: 16,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.blue.shade900,
                                          ),
                                        ),
                                        Text(
                                          'â‚¹${_getCartTotal().toStringAsFixed(2)}',
                                          style: GoogleFonts.poppins(
                                            fontSize: 16,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.blue.shade900,
                                          ),
                                        ),
                                      ],
                                    ),
                                    const SizedBox(height: 16),
                                    SizedBox(
                                      width: double.infinity,
                                      child: ElevatedButton.icon(
                                        onPressed: _isProcessingPayment ? null : _initiatePayment,
                                        icon: _isProcessingPayment
                                            ? const SizedBox(
                                                width: 20,
                                                height: 20,
                                                child: CircularProgressIndicator(
                                                  strokeWidth: 2,
                                                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                                ),
                                              )
                                            : const Icon(Icons.payment),
                                        label: Text(
                                          _isProcessingPayment ? 'Processing...' : 'Proceed to Buy',
                                          style: GoogleFonts.poppins(
                                            fontWeight: FontWeight.w600,
                                          ),
                                        ),
                                        style: ElevatedButton.styleFrom(
                                          backgroundColor: Colors.blue,
                                          foregroundColor: Colors.white,
                                          padding: const EdgeInsets.symmetric(vertical: 14),
                                          shape: RoundedRectangleBorder(
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ],
                  );
                      } else {
                        // Single column layout for smaller screens - reuse the same structure
                        return Column(
                          children: [
                            Expanded(
                              child: ListView.builder(
                                padding: const EdgeInsets.all(16),
                                itemCount: _localCartItems.length + 1,
                                itemBuilder: (context, index) {
                                  if (index == _localCartItems.length) {
                                    return const SizedBox(height: 16);
                                  }
                                  final item = _localCartItems[index];
                                  final product = item['product'];
                                  final quantity = _parseInteger(item['quantity'], 1);
                                  final productId = product['id'];
                                  final productName = product['name'] ?? 'Product';
                                  final categoryName = _getCategoryName(product);
                                  final unit = _getUnit(product);
                                  final sellingPrice = product['selling_price'] ?? product['price'] ?? 0.0;
                                  final price = _parseNumber(sellingPrice, 0.0);
                                  final stockQuantity = _parseInteger(product['stock_quantity'] ?? 0);
                                  final batch = product['batch']?.toString();
                                  final itemTotal = price * quantity;
                                  final productImage = product['image']?.toString() ?? '';
                                  final imageUrl = productImage.isNotEmpty && productImage.startsWith('http')
                                      ? productImage
                                      : 'https://superdailys.com/storage/products/${productImage.split('/').last}';
                                  return Container(
                                    margin: const EdgeInsets.only(bottom: 16),
                                    decoration: BoxDecoration(
                                      color: Colors.white,
                                      borderRadius: BorderRadius.circular(12),
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.grey.withOpacity(0.1),
                                          blurRadius: 10,
                                          offset: const Offset(0, 2),
                                        ),
                                      ],
                                    ),
                                    child: Padding(
                                      padding: const EdgeInsets.all(12),
                                      child: Row(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                          Container(
                                            width: 80,
                                            height: 80,
                                            decoration: BoxDecoration(
                                              color: _tealLight,
                                              borderRadius: BorderRadius.circular(8),
                                            ),
                                            child: ClipRRect(
                                              borderRadius: BorderRadius.circular(8),
                                              child: productImage.isNotEmpty
                                                  ? Image.network(
                                                      imageUrl,
                                                      fit: BoxFit.cover,
                                                      errorBuilder: (context, error, stackTrace) {
                                                        return Icon(
                                                          Icons.inventory_2,
                                                          color: _tealColor,
                                                          size: 32,
                                                        );
                                                      },
                                                    )
                                                  : Icon(
                                                      Icons.inventory_2,
                                                      color: _tealColor,
                                                      size: 32,
                                                    ),
                                            ),
                                          ),
                                          const SizedBox(width: 12),
                                          Expanded(
                                            child: Column(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Text(
                                                  productName,
                                                  style: GoogleFonts.poppins(
                                                    fontSize: 14,
                                                    fontWeight: FontWeight.bold,
                                                    color: Colors.grey.shade900,
                                                  ),
                                                  maxLines: 2,
                                                  overflow: TextOverflow.ellipsis,
                                                ),
                                                const SizedBox(height: 4),
                                                Text(
                                                  categoryName,
                                                  style: GoogleFonts.poppins(
                                                    fontSize: 11,
                                                    color: _tealColor,
                                                    fontWeight: FontWeight.w600,
                                                  ),
                                                ),
                                                const SizedBox(height: 4),
                                                Text(
                                                  'â‚¹${price.toStringAsFixed(2)} per $unit',
                                                  style: GoogleFonts.poppins(
                                                    fontSize: 12,
                                                    color: Colors.grey.shade700,
                                                  ),
                                                ),
                                                const SizedBox(height: 8),
                                                Row(
                                                  children: [
                                                    GestureDetector(
                                                      behavior: HitTestBehavior.opaque,
                                                      onTap: () {
                                                        final normalizedProductId = _normalizeProductId(productId);
                                                        if (quantity > 1) {
                                                          // Update local cart immediately
                                                          final itemIndex = _localCartItems.indexWhere(
                                                            (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                                          );
                                                          if (itemIndex != -1) {
                                                            setState(() {
                                                              // Create a new map to ensure state change is detected
                                                              final updatedItem = Map<String, dynamic>.from(_localCartItems[itemIndex]);
                                                              updatedItem['quantity'] = quantity - 1;
                                                              _localCartItems[itemIndex] = updatedItem;
                                                            });
                                                            widget.onUpdateQuantity(normalizedProductId, quantity - 1);
                                                          }
                                                        } else {
                                                          // Remove from local cart immediately
                                                          setState(() {
                                                            _localCartItems.removeWhere(
                                                              (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                                            );
                                                          });
                                                          widget.onRemoveItem(normalizedProductId);
                                                        }
                                                        widget.onCartUpdated();
                                                      },
                                                      child: Container(
                                                        width: 28,
                                                        height: 28,
                                                        decoration: BoxDecoration(
                                                          color: _tealColor,
                                                          borderRadius: BorderRadius.circular(6),
                                                        ),
                                                        child: const Icon(
                                                          Icons.remove,
                                                          color: Colors.white,
                                                          size: 16,
                                                        ),
                                                      ),
                                                    ),
                                                    const SizedBox(width: 12),
                                                    Text(
                                                      '$quantity',
                                                      style: GoogleFonts.poppins(
                                                        fontSize: 16,
                                                        fontWeight: FontWeight.bold,
                                                        color: Colors.grey.shade900,
                                                      ),
                                                    ),
                                                    const SizedBox(width: 12),
                                                    GestureDetector(
                                                      behavior: HitTestBehavior.opaque,
                                                      onTap: () {
                                                        final normalizedProductId = _normalizeProductId(productId);
                                                        if (quantity < stockQuantity) {
                                                          // Update local cart immediately
                                                          final itemIndex = _localCartItems.indexWhere(
                                                            (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                                          );
                                                          if (itemIndex != -1) {
                                                            setState(() {
                                                              // Create a new map to ensure state change is detected
                                                              final updatedItem = Map<String, dynamic>.from(_localCartItems[itemIndex]);
                                                              updatedItem['quantity'] = quantity + 1;
                                                              _localCartItems[itemIndex] = updatedItem;
                                                            });
                                                            widget.onUpdateQuantity(normalizedProductId, quantity + 1);
                                                            widget.onCartUpdated();
                                                          }
                                                        } else {
                                                          ScaffoldMessenger.of(context).showSnackBar(
                                                            const SnackBar(
                                                              content: Text('Cannot add more. Stock limit reached.'),
                                                              backgroundColor: Colors.orange,
                                                              duration: Duration(seconds: 2),
                                                            ),
                                                          );
                                                        }
                                                      },
                                                      child: Container(
                                                        width: 28,
                                                        height: 28,
                                                        decoration: BoxDecoration(
                                                          color: _tealColor,
                                                          borderRadius: BorderRadius.circular(6),
                                                        ),
                                                        child: const Icon(
                                                          Icons.add,
                                                          color: Colors.white,
                                                          size: 16,
                                                        ),
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 8),
                                                Text(
                                                  'Available: $stockQuantity $unit',
                                                  style: GoogleFonts.poppins(
                                                    fontSize: 10,
                                                    color: Colors.grey.shade600,
                                                  ),
                                                ),
                                                const SizedBox(height: 8),
                                                Row(
                                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                                  children: [
                                                    Text(
                                                      'â‚¹${itemTotal.toStringAsFixed(2)}',
                                                      style: GoogleFonts.poppins(
                                                        fontSize: 14,
                                                        fontWeight: FontWeight.bold,
                                                        color: Colors.grey.shade900,
                                                      ),
                                                    ),
                                                    GestureDetector(
                                                      behavior: HitTestBehavior.opaque,
                                                      onTap: () {
                                                        final normalizedProductId = _normalizeProductId(productId);
                                                        setState(() {
                                                          // Remove from local cart immediately
                                                          _localCartItems.removeWhere(
                                                            (item) => _normalizeProductId(item['product']['id']) == normalizedProductId
                                                          );
                                                        });
                                                        widget.onRemoveItem(normalizedProductId);
                                                        widget.onCartUpdated();
                                                      },
                                                      child: Container(
                                                        padding: const EdgeInsets.symmetric(
                                                          horizontal: 12,
                                                          vertical: 6,
                                                        ),
                                                        decoration: BoxDecoration(
                                                          color: Colors.red.shade50,
                                                          borderRadius: BorderRadius.circular(6),
                                                        ),
                                                        child: Row(
                                                          mainAxisSize: MainAxisSize.min,
                                                          children: [
                                                            Icon(
                                                              Icons.delete_outline,
                                                              color: Colors.red.shade700,
                                                              size: 16,
                                                            ),
                                                            const SizedBox(width: 4),
                                                            Text(
                                                              'Remove',
                                                              style: GoogleFonts.poppins(
                                                                fontSize: 12,
                                                                fontWeight: FontWeight.w600,
                                                                color: Colors.red.shade700,
                                                              ),
                                                            ),
                                                          ],
                                                        ),
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                              ],
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                  );
                                },
                              ),
                            ),
                            // Order Summary for mobile
                            Container(
                              margin: const EdgeInsets.all(16),
                              padding: const EdgeInsets.all(0),
                              decoration: BoxDecoration(
                                color: Colors.white,
                                borderRadius: BorderRadius.circular(12),
                                boxShadow: [
                                  BoxShadow(
                                    color: Colors.grey.withOpacity(0.1),
                                    blurRadius: 10,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Container(
                                    padding: const EdgeInsets.all(16),
                                    decoration: BoxDecoration(
                                      color: Colors.blue.shade50,
                                      borderRadius: const BorderRadius.only(
                                        topLeft: Radius.circular(12),
                                        topRight: Radius.circular(12),
                                      ),
                                    ),
                                    child: Row(
                                      children: [
                                        const Icon(
                                          Icons.list_alt,
                                          color: Colors.blue,
                                          size: 20,
                                        ),
                                        const SizedBox(width: 8),
                                        Text(
                                          'Order Summary',
                                          style: GoogleFonts.poppins(
                                            fontSize: 16,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.blue.shade900,
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                  Padding(
                                    padding: const EdgeInsets.all(16),
                                    child: Column(
                                      children: [
                                        Row(
                                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                          children: [
                                            Text(
                                              'Subtotal:',
                                              style: GoogleFonts.poppins(
                                                fontSize: 14,
                                                color: Colors.grey.shade700,
                                              ),
                                            ),
                                            Text(
                                              'â‚¹${_getCartTotal().toStringAsFixed(2)}',
                                              style: GoogleFonts.poppins(
                                                fontSize: 14,
                                                color: Colors.grey.shade700,
                                              ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 8),
                                        Row(
                                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                          children: [
                                            Text(
                                              'Total:',
                                              style: GoogleFonts.poppins(
                                                fontSize: 16,
                                                fontWeight: FontWeight.bold,
                                                color: Colors.blue.shade900,
                                              ),
                                            ),
                                            Text(
                                              'â‚¹${_getCartTotal().toStringAsFixed(2)}',
                                              style: GoogleFonts.poppins(
                                                fontSize: 16,
                                                fontWeight: FontWeight.bold,
                                                color: Colors.blue.shade900,
                                              ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 16),
                                        SizedBox(
                                          width: double.infinity,
                                          child: ElevatedButton.icon(
                                            onPressed: _isProcessingPayment ? null : _initiatePayment,
                                            icon: _isProcessingPayment
                                                ? const SizedBox(
                                                    width: 20,
                                                    height: 20,
                                                    child: CircularProgressIndicator(
                                                      strokeWidth: 2,
                                                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                                    ),
                                                  )
                                                : const Icon(Icons.payment),
                                            label: Text(
                                              _isProcessingPayment ? 'Processing...' : 'Proceed to Buy',
                                              style: GoogleFonts.poppins(
                                                fontWeight: FontWeight.w600,
                                              ),
                                            ),
                                            style: ElevatedButton.styleFrom(
                                              backgroundColor: Colors.blue,
                                              foregroundColor: Colors.white,
                                              padding: const EdgeInsets.symmetric(vertical: 14),
                                              shape: RoundedRectangleBorder(
                                                borderRadius: BorderRadius.circular(8),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        );
                      }
                    },
                  ),
                ),
              ],
      ),
    );
  }
}

// Editable Monthly Service Window Section Widget
class _EditableMonthlyWindowSection extends StatefulWidget {
  final Map<String, dynamic> booking;
  final DateTime? initialFromDate;
  final DateTime? initialToDate;
  final String initialReason;

  const _EditableMonthlyWindowSection({
    required this.booking,
    required this.initialFromDate,
    required this.initialToDate,
    required this.initialReason,
  });

  @override
  State<_EditableMonthlyWindowSection> createState() => _EditableMonthlyWindowSectionState();
}

class _EditableMonthlyWindowSectionState extends State<_EditableMonthlyWindowSection> {
  late DateTime? _delayFromDate;
  late DateTime? _delayToDate;
  late String _delayReason;
  bool _isSaving = false;
  final TextEditingController _reasonController = TextEditingController();
  late final ValueNotifier<DateTime?> _selectedFromDateNotifier;
  late final ValueNotifier<DateTime?> _selectedToDateNotifier;
  String? _dateRangeError;
  String? _weekMonthError;

  @override
  void initState() {
    super.initState();
    _delayFromDate = widget.initialFromDate;
    _delayToDate = widget.initialToDate;
    _delayReason = widget.initialReason;
    _reasonController.text = _delayReason;
    _selectedFromDateNotifier = ValueNotifier(_delayFromDate);
    _selectedToDateNotifier = ValueNotifier(_delayToDate);
  }

  // Check if 4 days have passed since booking date
  bool get _isFieldsEnabled {
    final bookingDateStr = widget.booking['booking_date']?.toString() ?? '';
    DateTime? bookingDate;
    
    if (bookingDateStr.isNotEmpty) {
      bookingDate = _tryParseDate(bookingDateStr);
    }
    
    // Fallback to created_at if booking_date is not available
    if (bookingDate == null && widget.booking['created_at'] != null) {
      bookingDate = _tryParseDate(widget.booking['created_at'].toString());
    }
    
    if (bookingDate == null) {
      // If no booking date found, allow editing (fallback behavior)
      return true;
    }
    
    final now = DateTime.now();
    final difference = now.difference(bookingDate).inDays;
    
    // Fields are enabled only if 4 or more days have passed
    return difference >= 4;
  }

  // Get the number of days remaining before fields are enabled
  int get _daysRemaining {
    final bookingDateStr = widget.booking['booking_date']?.toString() ?? '';
    DateTime? bookingDate;
    
    if (bookingDateStr.isNotEmpty) {
      bookingDate = _tryParseDate(bookingDateStr);
    }
    
    if (bookingDate == null && widget.booking['created_at'] != null) {
      bookingDate = _tryParseDate(widget.booking['created_at'].toString());
    }
    
    if (bookingDate == null) {
      return 0;
    }
    
    final now = DateTime.now();
    final difference = now.difference(bookingDate).inDays;
    final remaining = 4 - difference;
    
    return remaining > 0 ? remaining : 0;
  }

  @override
  void dispose() {
    _selectedFromDateNotifier.dispose();
    _selectedToDateNotifier.dispose();
    _reasonController.dispose();
    super.dispose();
  }

  DateTime? _tryParseDate(String? dateStr) {
    if (dateStr == null || dateStr.isEmpty) return null;
    try {
      return DateTime.parse(dateStr);
    } catch (e) {
      return null;
    }
  }

  String _formatDisplayDateFromDateTime(DateTime? date, {bool useEmptyPlaceholder = false}) {
    if (date == null) {
      return useEmptyPlaceholder ? 'Not set' : '';
    }
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }

  // Get the week number of the month for a given date (1-4 or 5)
  int _getWeekOfMonth(DateTime date) {
    final firstDayOfMonth = DateTime(date.year, date.month, 1);
    final firstDayWeekday = firstDayOfMonth.weekday; // 1 = Monday, 7 = Sunday
    final dayOfMonth = date.day;
    // Calculate which week of the month this day falls into
    return ((dayOfMonth + firstDayWeekday - 2) ~/ 7) + 1;
  }

  // Check if two date ranges are in the same week and month
  bool _isInSameWeekAndMonth(DateTime from1, DateTime to1, DateTime from2, DateTime to2) {
    // Check if they're in the same month and year
    if (from1.year != from2.year || from1.month != from2.month) {
      return false;
    }
    
    // Get week numbers for both ranges
    final week1 = _getWeekOfMonth(from1);
    final week2 = _getWeekOfMonth(from2);
    
    // Check if they're in the same week
    return week1 == week2;
  }

  // Check if user has already applied for dates in the same week/month
  Future<bool> _hasExistingApplicationInSameWeekMonth(DateTime fromDate, DateTime toDate) async {
    try {
      final userId = widget.booking['user_id'];
      if (userId == null) return false;

      final apiUrl = '${kBackendBaseUrl}get_my_bookings.php?user_id=$userId';
      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          'Content-Type': 'application/json',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true && data['bookings'] != null) {
          final bookings = data['bookings'] as List;
          
          for (var booking in bookings) {
            // Skip the current booking
            if (booking['id'] == widget.booking['id']) {
              continue;
            }
            
            final existingFromStr = booking['delay_from_month']?.toString();
            final existingToStr = booking['delay_to_month']?.toString();
            
            if (existingFromStr != null && existingToStr != null && 
                existingFromStr.isNotEmpty && existingToStr.isNotEmpty) {
              try {
                final existingFrom = DateTime.parse(existingFromStr);
                final existingTo = DateTime.parse(existingToStr);
                
                // Check if the existing application is in the same week and month
                if (_isInSameWeekAndMonth(fromDate, toDate, existingFrom, existingTo)) {
                  return true;
                }
              } catch (e) {
                debugPrint('Error parsing existing dates: $e');
              }
            }
          }
        }
      }
    } catch (e) {
      debugPrint('Error checking existing applications: $e');
      // If we can't check, allow the submission (fail open)
    }
    return false;
  }

  // Validate dates immediately and update error states
  Future<void> _validateDatesImmediately() async {
    setState(() {
      _dateRangeError = null;
      _weekMonthError = null;
    });

    if (_delayFromDate == null || _delayToDate == null) {
      return;
    }

    // Check date range
    final daysDifference = _delayToDate!.difference(_delayFromDate!).inDays;
    if (daysDifference > 7) {
      setState(() {
        _dateRangeError = 'The date range cannot exceed 7 days';
      });
      return;
    }

    // Check for existing application in same week/month
    final hasExisting = await _hasExistingApplicationInSameWeekMonth(_delayFromDate!, _delayToDate!);
    if (hasExisting) {
      setState(() {
        _weekMonthError = 'You have already applied for dates in this week of this month';
      });
    }
  }

  Future<void> _saveDelayInfo() async {
    if (_isSaving) return;

    setState(() {
      _isSaving = true;
    });

    try {
      final bookingId = widget.booking['id'];
      if (bookingId == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Booking ID not found')),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      // Validation: Check if both dates are selected
      if (_delayFromDate == null || _delayToDate == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please select both From Date and To Date'),
            backgroundColor: Colors.orange,
          ),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      // Validation: Check that date range does not exceed 7 days
      final daysDifference = _delayToDate!.difference(_delayFromDate!).inDays;
      if (daysDifference > 7) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('The date range cannot exceed 7 days. Please select dates within 7 days.'),
            backgroundColor: Colors.orange,
          ),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      // Validation: Check if user has already applied for dates in the same week/month
      final hasExisting = await _hasExistingApplicationInSameWeekMonth(_delayFromDate!, _delayToDate!);
      if (hasExisting) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('You have already applied for dates in this week of this month. You can only apply once per week per month.'),
            backgroundColor: Colors.orange,
          ),
        );
        setState(() {
          _isSaving = false;
        });
        return;
      }

      // Build payload - include all fields that have values
      final payload = <String, dynamic>{
        'booking_id': bookingId,
      };
      
      // Add from date if filled
      if (_delayFromDate != null) {
        payload['delay_from_month'] = _delayFromDate!.toIso8601String();
      }
      
      // Add to date if filled
      if (_delayToDate != null) {
        payload['delay_to_month'] = _delayToDate!.toIso8601String();
      }
      
      // Always send reason field (even if empty) to ensure it's saved properly
      final reasonText = _reasonController.text.trim();
      payload['delay_reason'] = reasonText;

      final response = await http.post(
        Uri.parse('${kBackendBaseUrl}update_booking_delay.php'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(payload),
      ).timeout(const Duration(seconds: 30));

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Service window updated successfully'),
              backgroundColor: Colors.green,
            ),
          );
          // Update the booking data in the list with all three fields
          if (_delayFromDate != null) {
            widget.booking['delay_from_month'] = _delayFromDate!.toIso8601String();
          } else {
            widget.booking['delay_from_month'] = null;
          }
          if (_delayToDate != null) {
            widget.booking['delay_to_month'] = _delayToDate!.toIso8601String();
          } else {
            widget.booking['delay_to_month'] = null;
          }
          widget.booking['delay_reason'] = _reasonController.text.trim();
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(data['message'] ?? 'Failed to update service window'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to update service window'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      debugPrint('Error updating booking delay: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('An error occurred. Please try again.'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSaving = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        // Stop event propagation to prevent navigation to booking details
      },
      onTapDown: (_) {
        // Consume the tap event to prevent parent GestureDetector from firing
      },
      behavior: HitTestBehavior.opaque,
      child: Card(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Monthly Service Window',
                style: GoogleFonts.poppins(
                  fontSize: 15,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey.shade900,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                'Update the delivery months for this subscription and share a reason.',
                style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey.shade600),
              ),
              if (!_isFieldsEnabled) ...[
                const SizedBox(height: 12),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.orange.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.orange.shade200),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.info_outline, size: 18, color: Colors.orange.shade700),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _daysRemaining == 1
                              ? 'You can update the Monthly Service Window after 1 more day from the booking date.'
                              : 'You can update the Monthly Service Window after $_daysRemaining more days from the booking date.',
                          style: GoogleFonts.poppins(
                            fontSize: 12,
                            color: Colors.orange.shade700,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
              const SizedBox(height: 16),
              LayoutBuilder(
                builder: (context, constraints) {
                  if (constraints.maxWidth < 400) {
                    // Stack vertically on narrow screens
                    return Column(
                      children: [
                        _buildEditableDateField(
                          label: 'From Date',
                          value: _delayFromDate,
                          icon: Icons.date_range,
                          enabled: _isFieldsEnabled,
                          onTap: _isFieldsEnabled ? () async {
                            final picked = await showDatePicker(
                              context: context,
                              initialDate: _delayFromDate ?? DateTime.now(),
                              firstDate: DateTime.now(),
                              lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
                            );
                            if (picked != null) {
                              setState(() {
                                _delayFromDate = picked;
                                _selectedFromDateNotifier.value = picked;
                              });
                              // Validate immediately after selection
                              await _validateDatesImmediately();
                            }
                          } : null,
                        ),
                        const SizedBox(height: 12),
                        _buildEditableDateField(
                          label: 'To Date',
                          value: _delayToDate,
                          icon: Icons.event,
                          enabled: _isFieldsEnabled,
                          errorText: _dateRangeError ?? _weekMonthError,
                          onTap: _isFieldsEnabled ? () async {
                            if (_delayFromDate == null) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Please select From Date first'),
                                  backgroundColor: Colors.orange,
                                ),
                              );
                              return;
                            }
                            final maxDate = _delayFromDate!.add(const Duration(days: 7));
                            final picked = await showDatePicker(
                              context: context,
                              initialDate: _delayToDate ?? _delayFromDate!,
                              firstDate: _delayFromDate!,
                              lastDate: maxDate.isBefore(DateTime.now().add(const Duration(days: 365 * 2)))
                                  ? maxDate
                                  : DateTime.now().add(const Duration(days: 365 * 2)),
                            );
                            if (picked != null) {
                              // Validate that the selected date is within 7 days
                              final daysDiff = picked.difference(_delayFromDate!).inDays;
                              if (daysDiff > 7) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                    content: Text('To Date cannot be more than 7 days from From Date'),
                                    backgroundColor: Colors.orange,
                                  ),
                                );
                                return;
                              }
                              setState(() {
                                _delayToDate = picked;
                                _selectedToDateNotifier.value = picked;
                              });
                              // Validate immediately after selection
                              await _validateDatesImmediately();
                            }
                          } : null,
                        ),
                      ],
                    );
                  }
                  // Side by side on wider screens
                  return Row(
                    children: [
                      Expanded(
                        child: _buildEditableDateField(
                          label: 'From Date',
                          value: _delayFromDate,
                          icon: Icons.date_range,
                          enabled: _isFieldsEnabled,
                          onTap: _isFieldsEnabled ? () async {
                            final picked = await showDatePicker(
                              context: context,
                              initialDate: _delayFromDate ?? DateTime.now(),
                              firstDate: DateTime.now(),
                              lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
                            );
                            if (picked != null) {
                            setState(() {
                              _delayFromDate = picked;
                              _selectedFromDateNotifier.value = picked;
                            });
                              // Validate immediately after selection
                              await _validateDatesImmediately();
                            }
                          } : null,
                        ),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: _buildEditableDateField(
                          label: 'To Date',
                          value: _delayToDate,
                          icon: Icons.event,
                          enabled: _isFieldsEnabled,
                          errorText: _dateRangeError ?? _weekMonthError,
                          onTap: _isFieldsEnabled ? () async {
                            if (_delayFromDate == null) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Please select From Date first'),
                                  backgroundColor: Colors.orange,
                                ),
                              );
                              return;
                            }
                            final maxDate = _delayFromDate!.add(const Duration(days: 7));
                            final picked = await showDatePicker(
                              context: context,
                              initialDate: _delayToDate ?? _delayFromDate!,
                              firstDate: _delayFromDate!,
                              lastDate: maxDate.isBefore(DateTime.now().add(const Duration(days: 365 * 2)))
                                  ? maxDate
                                  : DateTime.now().add(const Duration(days: 365 * 2)),
                            );
                            if (picked != null) {
                              // Validate that the selected date is within 7 days
                              final daysDiff = picked.difference(_delayFromDate!).inDays;
                              if (daysDiff > 7) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                    content: Text('To Date cannot be more than 7 days from From Date'),
                                    backgroundColor: Colors.orange,
                                  ),
                                );
                                return;
                              }
                              setState(() {
                                _delayToDate = picked;
                                _selectedToDateNotifier.value = picked;
                              });
                              // Validate immediately after selection
                              await _validateDatesImmediately();
                            }
                          } : null,
                        ),
                      ),
                    ],
                  );
                },
              ),
              const SizedBox(height: 12),
              _buildEditableReasonField(enabled: _isFieldsEnabled),
              const SizedBox(height: 12),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: (_isSaving || !_isFieldsEnabled) ? null : _saveDelayInfo,
                  icon: _isSaving
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        )
                      : const Icon(Icons.save_alt),
                  label: Text(_isSaving ? 'Saving...' : 'Save'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF00BFA5),
                    padding: const EdgeInsets.symmetric(vertical: 14),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildEditableDateField({
    required String label,
    required DateTime? value,
    required IconData icon,
    required VoidCallback? onTap,
    bool enabled = true,
    String? errorText,
  }) {
    final hasError = errorText != null && errorText.isNotEmpty;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: Colors.grey.shade600,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 6),
        InkWell(
          onTap: enabled ? onTap : null,
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
            decoration: BoxDecoration(
              color: enabled ? Colors.white : Colors.grey.shade100,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: hasError 
                    ? Colors.red.shade400 
                    : (enabled ? Colors.grey.shade300 : Colors.grey.shade200),
                width: hasError ? 2 : 1,
              ),
            ),
            child: Row(
              children: [
                Icon(
                  icon, 
                  size: 18, 
                  color: hasError 
                      ? Colors.red.shade400 
                      : (enabled ? Colors.grey.shade600 : Colors.grey.shade400),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    _formatDisplayDateFromDateTime(value, useEmptyPlaceholder: true),
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      color: hasError
                          ? Colors.red.shade400
                          : (enabled 
                              ? (value == null ? Colors.grey.shade400 : Colors.grey.shade900)
                              : Colors.grey.shade400),
                    ),
                  ),
                ),
                Icon(
                  Icons.arrow_drop_down, 
                  color: hasError 
                      ? Colors.red.shade400 
                      : (enabled ? Colors.grey.shade600 : Colors.grey.shade400),
                ),
              ],
            ),
          ),
        ),
        if (hasError) ...[
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(Icons.error_outline, size: 14, color: Colors.red.shade400),
              const SizedBox(width: 4),
              Expanded(
                child: Text(
                  errorText!,
                  style: GoogleFonts.poppins(
                    fontSize: 11,
                    color: Colors.red.shade400,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }

  Widget _buildEditableReasonField({bool enabled = true}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Reason',
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: Colors.grey.shade600,
          ),
        ),
        const SizedBox(height: 6),
        Container(
          decoration: BoxDecoration(
            color: enabled ? Colors.white : Colors.grey.shade100,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: enabled ? Colors.grey.shade300 : Colors.grey.shade200),
          ),
          child: TextField(
            controller: _reasonController,
            enabled: enabled,
            maxLines: 3,
            decoration: InputDecoration(
              hintText: 'Tell us why you are making a change',
              hintStyle: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade400),
              border: InputBorder.none,
              contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
              prefixIcon: Icon(Icons.edit_note, size: 18, color: enabled ? Colors.grey.shade600 : Colors.grey.shade400),
            ),
            style: GoogleFonts.poppins(
              fontSize: 14, 
              color: enabled ? Colors.grey.shade900 : Colors.grey.shade400,
            ),
          ),
        ),
      ],
    );
  }
}